{
  "index.html": {
    "href": "index.html",
    "title": "",
    "keywords": "Welcome to http://docs.ghielectronics.com where you can find tutorials, samples, documentation, and API references for all GHI Electronics products. This documentation covers three main categories: Hardware: This includes every hardware product GHI Electronics makes. Also included are the needed resources and instructions for the use of these products. It also covers bootloaders. TinyCLR: Everything you need to use and/or port TinyCLR OS. BrainPad: Courses and learning material for the STEM/STEAM focused BrainPad. The GHI Electronics websites: The main website: https://www.ghielectronics.com/ TinyCLR OS: http://www.tinyclr.com BrainPad: http://www.brainpad.com The community forum: https://forums.ghielectronics.com/ You may obtain further assistance by contacting us directly or through our community forums . Note This is a new documentation system and some of the available docs are still in progress. Please check back frequently."
  },
  "hardware/intro.html": {
    "href": "hardware/intro.html",
    "title": "Hardware Introduction",
    "keywords": "Hardware Introduction These pages provide specific details on each of our devices such as technical specifications, schematics, manuals, and datasheets. Tip Products may be grouped under a family, for example FEZ Panda II can be found under the USBizi. Use the search box in the top right corner it is a good tool for finding these products."
  },
  "hardware/legacy_products/filesystem.html": {
    "href": "hardware/legacy_products/filesystem.html",
    "title": "File System",
    "keywords": "File System Since 2003, GHI Electronics has made several industry-first file system chipsets. F40 Originally called ALFAT. Datasheet ALFAT-SD Schematic ALFAT-OEM Schematic Firmware 1.08 Firmware 2.00 (the file name needs changing) F20 Datasheet Firmware v103 F20-uSD Schematic uALFAT User Manual"
  },
  "tinyclr/tutorials/spi.html": {
    "href": "tinyclr/tutorials/spi.html",
    "title": "SPI",
    "keywords": "SPI SPI uses three, sometimes four, wires for transferring data. The bus on SPI consists of a single master and one or more slaves. The master will send clock to the slaves over the SCK pin. It will also send date over MOSI pin, while reading incoming data on the MISO pin. The SCK clock is used to determine how fast the data is moved. If you know electronics, this is simply a shift register. The master selects which slave it will swap the data with using the SSEL pin, sometimes called CS. In its simplest terms, the master will swap data between itself and the slave. You cannot write data without reading at the same time. However, a lot of time you need to write data and you do not care about the incoming data. For that, there is a Write method. But keep in mind that the Write method is also reading, and discarding, whatever the slave is sending. Tip Some SPI devices (slaves) can have more than one select-pin, like the VS1053 MP3 decoder chip that uses one select pin for data and other for commands. Both share the 3 data transfer pins (SCK, >MOSI, MISO). Tip SPI needs more wires than other similar buses but it can transfer data very fast. A 50Mhz clock is possible on SPI, that is 50 million bits in one second. Tip Note that a board running TinyCLR OS is always a SPI masters, not slaves. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Spi; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var settings = new SpiConnectionSettings(0x1C)// the slave's select pin { Mode = SpiMode.Mode1, ClockFrequency = 4* 1000 * 1000,//4Mhz DataBitLength = 8, }; var device = SpiDevice.FromId(FEZ.SpiBus.Spi1, settings); device.Write(new byte[] { 1, 2 });// write something device.TransferSequential(...)// this is good for reading registers device.TransferFullDuplex(...)// this is the only one that trully represents how SPI works } }"
  },
  "tinyclr/accessories/pololu_zumo_robot.html": {
    "href": "tinyclr/accessories/pololu_zumo_robot.html",
    "title": "Pololu Zumo Robot",
    "keywords": "Pololu Zumo Robot The Pololu Zumo Robot from Pololu is one of our favorites, especially the pre-assembled version. Drop your FEZ on top of the Zumo Robot, or any other Arduino-compatible board, and you are ready to make the robot follow lines and dance around. The driver is found here . You are now ready for some serious dancing! public static void Main() { bool state = false; while (!ZumoBot.ButtonIsPressed()) { state = !state; ZumoBot.SetLed(state); ZumoBot.Beep(); Thread.Sleep(500); } Thread.Sleep(300); ZumoBot.SetLed(false); Thread.Sleep(300); ZumoBot.SetLed(true); Thread.Sleep(300); ZumoBot.SetLed(false); Thread.Sleep(300); ZumoBot.SetLed(true); while (true) { long left = ZumoBot.Reflectors.GetLevel(0); long right = ZumoBot.Reflectors.GetLevel(5); //Debug.WriteLine(\">\" + ZumoBot.Reflectors.GetLevel(0)); //System.Diagnostics.Debug.WriteLine(\"l: \" + left + \" r: \" + right); if (left < 8000 && right < 8000) { ZumoBot.Motors.Move(40, 40); } else { // backup and turn ZumoBot.Motors.MoveBackward(); Thread.Sleep(500); ZumoBot.Motors.Stop(); Thread.Sleep(1000); ZumoBot.Motors.TurnLeft(); Thread.Sleep(500); ZumoBot.Motors.Stop(); Thread.Sleep(1000); } Thread.Sleep(30); } }"
  },
  "brainpad/courses/programming/setup_visual_studio.html": {
    "href": "brainpad/courses/programming/setup_visual_studio.html",
    "title": "Setting Up Visual Studio for the BrainPad",
    "keywords": "Setting Up Visual Studio for the BrainPad We recommend all students start with Microsoft Visual Studio. Visual Studio is the most popular desktop program development environment and is used by professional programmers the world over. The experience you gain programming the BrainPad in Visual Studio also applies to programming desktop computers and smart phones, and Visual Studio's advanced debugging and code completion features make writing code a breeze! Step 1: Install Visual Studio on your computer The Visual Studio Community Edition is free and can be found here: . Microsoft Visual Studio 2017 Community Edition Download When the installation program shows the Workloads screen, select .NET desktop development then click the Install button. Step 2: Install the TinyCLR OS extension (.vsix) Click on the link below and under \"Visual Studio Project System\" click on the latest release in the top row of the table. When asked, open the file. TinyCLR OS Visual Studio Extension Congratulations! You have successfully installed Visual Studio 2017 and the TinyCLR OS extension. You can now start programming the BrainPad by picking a language (Visual C# or Visual Basic) and clicking on the link below. Click on a link below to get started: Getting Started on the BrainPad using Visual C# Getting Started on the BrainPad using Visual Basic"
  },
  "brainpad/courses/programming/vb/intro.html": {
    "href": "brainpad/courses/programming/vb/intro.html",
    "title": "Introduction to Visual Basic",
    "keywords": "Introduction to Visual Basic Visual Basic is a modern .NET programming language. It is as powerful as any of the other programmign languiages but its code is more englich-like, making it a student/teacher favorite. The courses are in the process of being created. Please bear with us. Overview Students will learn how to create projects in Visual Studio along with programming basics. Applications in this lesson will be limited to the BrainPad object, If statements, a While loop and the template functions. Guidelines Prerequisites: None Ages 12 and up PC setup with Visual Studio 2017, TinyCLR OS and Nuget packages installed. Supplies: BrainPad and microUSB cable. Install Visual Studio and Download .vsix file Install Visual Studio Community 2017. Select the Community download. Skip this step if you have Visual Studio 2017 installed. Visual Studio 2017 Download Starting a New Project Connect your BrainPad to your computer using a microUSB cable. Next Open Visual Studio select File>New>Project and under Other Languages select Visual Basic>TinyCLR and choose the BrainPad Application . Change the Location to C:\\Users\\<YourUsername>\\Desktop\\ then name the project BrainPad_Project. From Visual Studio, select File > New > Project. Creating the BrainPad_Project BrainPad TinyCLR Application. Once created, you'll be presented with a Program.vb tab. The Program.vb file and its contents are shown. This file contains the default code when you first create a project. The lines in green that begin with ' are called comments, and they generally describe what the code does. Take a moment to review them. Let's run the code to see these comments' descriptions come to life. Connect the BrainPad and press the F5 function key or the Start button. Press the Start button to run the Program. Visual Studio will now run the code, a few things will happen and the display will now have the text \"Hello, world!\" . The display shows \"Hello world\" What happened exactly? Our application began by calling the BrainPadSetup() function. This function is called one time, when the application starts, and is generally used to set things up. In this case, it executed the BrainPad.Display.DrawText line to instruct the display to show the text \"Hello, world!\" After BrainPadSetup() was finished, the application called BrainPadLoop() . Code placed inside this function is executed in an infinite loop. This is why the code that turns the LED on and then off again never stops. Exercise Change the text to make the program print your name on the display. Answer Change this line to your name instead of \"Hello World!\" BrainPad.Display.DrawText(0,0,\"YOUR NAME HERE\") The BrainPad Object The world around us is full of objects. Every person, table or circuit board is an object. If we were to ask a person to say \"hello,\" we'd be asking an object to perform a task. The same concept can be applied to code. Like in the previous application we ran, the BrainPad was asked to control the display and light bulb through the BrainPad object. The BrainPad object itself, is a piece of code that is contained in one file. This was developed by GHI Electronics to cover the internals of the BrainPad . This enables students like you, with an easy way to control the BrainPad circuit board. After typing BrainPad , press the period key to get a list of all available options for this object, like Display . Using IntelliSense we can see the options offered by the BrainPad object. Now we can use the arrow keys to go up and down in the list to find the Display , and then press the period key again to see what options are the available for the Display . Using IntelliSense we can see the options offered by the Display object. Visual Studio does a great deal of simplifying programming by automatically listing the available options for each object. Now that we know how to use the BrainPad object, let's learn about controlling the LED Light Bulb. The BrainPad LightBulb LED lights are used in many different electronic devices. Here we will test the LightBulb by turning it GREEN , then ON and OFF . Copy and paste the code from Example 1 into your project's BrainPadSetup() function. BrainPad.LightBulb.TurnOff() BrainPad.LightBulb.TurnGreen() BrainPad.LightBulb.TurnOff() BrainPad.LightBulb.TurnGreen() Put this code inside the BrainPadSetup() function. Now, press F5 to run the code and you'll see the LightBulb turn GREEN and stay on. This happens because our code is executed faster than we can see. Problem Solving Since applications execute extremely fast, we need to slow them down to figure out the problem. This way we can see what is happening or if the results are as expected. We will start by stepping in code to see what the application does at a slow speed. Stepping in Code Add a breakpoint at the first line of code inside of BrainPadSetup() by moving the cursor to that line and pressing the F9 We've added a breakpoint on line 5. Press F5 to run the application. The project will be built and deployed but then the execution will stop at the breakpoint. The program has executed up to the breakpoint. Press the F10 key to execute the current line, which turns the green light off. Now press the F10 key again, and the LightBulb will turn GREEN . The next steps will continue through the rest of the code. When you reach the closing curly bracket, press F5 to stop. Now that we know our code works (it's just happening too fast) we can add some delays so we can see the light turn on and then off. Delays in Code In order to see what's going on we need to add some delays in the code. This is done by telling the BrainPad to wait between tasks. BrainPad.LightBulb.TurnOff() BrainPad.Wait.Seconds(0.5) BrainPad.LightBulb.TurnGreen() BrainPad.Wait.Seconds(0.5) BrainPad.LightBulb.TurnOff() BrainPad.Wait.Seconds(0.5) BrainPad.LightBulb.TurnGreen() This code waits half a second (0.5) between turning the Lightbulb GREEN and OFF. Copy and paste the code from above into your project's BrainPadSetup() function. Run the code and observe the LightBulb again. You should now see the LightBulb turning GREEN and off every half a second. Exercise Create a Traffic Light simulation using the following logic and the LightBulb: Turn the light on GREEN Wait 5 seconds. Turn the LightBulb off. Turn the light on YELLOW Wait 2 seconds. Turn the LightBulb off. Turn the light on RED Wait 5 seconds. Answer BrainPad.LightBulb.TurnGreen() BrainPad.Wait.Seconds(5) BrainPad.LightBulb.TurnOff() BrainPad.LightBulb.TurnYellow() BrainPad.Wait.Seconds(2) BrainPad.LightBulb.TurnOff() BrainPad.LightBulb.TurnRed() BrainPad.Wait.Seconds(5) While Loop The previous exercise turned the LightBulb several colors but it only did it once. We could repeat the code over and over to make the traffic light run a few more times but what if we want this to run indefinitely? This is where While loops come in handy. While BrainPad.Looping 'Your code End While Code inside a while loop will be executed indefinitely. Code inside a while loop will be executed indefinitely as long as its condition is met. In our case, we'll use a constant value from the BrainPad object called Looping . This constant always returns true, which causes the loop's condition to always be met. While BrainPad.Looping BrainPad.LightBulb.TurnGreen() BrainPad.Wait.Seconds(0.5) BrainPad.LightBulb.TurnOff() BrainPad.Wait.Seconds(0.5) End While This code will blink the LightBulb GREEN on and off for half a second indefinitely. Let's keep things simple and blink the LightBulb GREEN every half a second. Copy and paste the code from above into your project's BrainPadSetup() function. Run the code and observe the LightBulb. Tip The BrainPadLoop() function does the same thing as our While loop behind the scenes, so you can use this function in your application to simplify things. Understanding The Loop To further understand what's going on, add a breakpoint by moving the cursor to the first line where we turn the light GREEN and press F9 . This will add a breakpoint and pause the application as soon as it reaches that line. block Add a breakpoint while the application is running Now use F10 to step through the code and when the program reaches the end of the While loop it will go back to the beginning. Stop the program execution by pressing the STOP button. The stop button will stop the application that's running. Now, reset the BrainPad and note how the green light is still blinking but this time without the need for Visual Studio. In fact, you can connect the BrainPad to any appropriate power source (such as a phone charger) and the LightBulb will turn on GREEN and will blink without the need for a PC. Exercise Make the LightBulb cycle through 3 different colors indefinitely. Answer Public Sub BrainPadSetup() While BrainPad.Looping BrainPad.LightBulb.TurnGreen() BrainPad.Wait.Seconds(0.5) BrainPad.LightBulb.TurnRed() BrainPad.Wait.Seconds(0.5) BrainPad.LightBulb.TurnYellow() BrainPad.Wait.Seconds(0.5) End While End Sub If Statement An If statement (or conditional statement) checks to see if a statement is TRUE or FALSE and then does one of two things depending on the result. Like if the DOWN button is pressed, turn the LightBulb GREEN . Public Sub BrainPadSetup() BrainPad.LightBulb.TurnGreen() If BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnOff() End If End Sub Pressing and hold the down button when running this program will turn the LightBulb GREEN. For the code above to work, you have to be holding the button down at the time the program is deployed. This is because once the If statement is reached, the program will continue executing until the program ends. To solve this hard to reach goal, we need to repeatedly check if the button is pressed, as seen in the above code. This is where a While loop comes in handy. Let's use the BrainPadLoop() function to simplify things per the tip earlier . Public Sub BrainPadSetup() BrainPad.LightBulb.TurnOff() End Sub Public Sub BrainPadLoop() If BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnOff() End If End Sub The above code makes sure the LightBulb is OFF and then it falls into an infinite loop. However, this program still has a bug. Run the program and test it. The LightBulb will be OFF when the program runs and then once the down button is pressed the the LightBulb turn GREEN . That is all good so far, but when the button is released, the LightBulb never turns OFF . Can you guess why? Try stepping in the code to see what happens when the button is pressed and when it is not pressed . Computers are strict on following orders. In previous examples, the LightBulb never turned OFF because we actually never told the program to turn the LightBulb OFF . This means we have to tell the program to turn the LightBulb ON when the button is pressed and we also have to tell it to turn the LightBulb OFF when the button is not pressed . Public Sub BrainPadSetup() BrainPad.LightBulb.TurnOff() End Sub Public Sub BrainPadLoop() If BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnGreen() End If If Not BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnOff() End If End Sub This code loops indefinitely checking if the down button is pressed. If it is pressed, the LightBulb will turn on GREEN The above code first makes sure the LightBulb is off and then it falls into an infinite loop. However, this program still has a bug. Run the program and test it. The LightBulb will be off when the program runs and then once the down button is pressed the the LightBulb turn GREEN . That is all good so far, but when the button is released, the LightBulb never turns off. Can you guess why? Try stepping in the code to see what happens when the button is pressed and when it is not pressed . Computers are strict on following orders. In previous examples, the LightBulb never turned off because we actually never told the program to turn the GREEN LightBulb off. This means we have to tell the program to turn the light on when the button is pressed and we also have to tell it to turn the LightBulb off when the button is not pressed as shown. Public Sub BrainPadSetup() BrainPad.LightBulb.TurnOff() End Sub Public Sub BrainPadLoop() If BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnGreen() End If If Not BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnOff() End If End Sub This code will turn the LightBulb GREEN when the down button is pressed, and off when the down button **is not pressed** the **LightBulb** will turn on While the BrainPad doesn't have a method called BrainPad.Button.IsDownNotPressed() we can continue to use BrainPad.Button.IsDownPressed() but with If Not before it to represent if the button is not pressed . Now when you run it, not pressing the button will turn/keep the LightBulb off. Exercise Turn the LightBulb GREEN when the up button is pressed . Turn the LightBulb off when the down button is pressed . Turn the LightBulb RED on when the left button is pressed and BLUE when right button is pressed Answer Public Sub BrainPadSetup() BrainPad.LightBulb.TurnOff() End Sub Public Sub BrainPadLoop() If BrainPad.Buttons.IsUpPressed() Then BrainPad.LightBulb.TurnGreen() End If If BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnOff() End If If BrainPad.Buttons.IsLeftPressed() Then BrainPad.LightBulb.TurnRed() End If If BrainPad.Buttons.IsRightPressed() Then BrainPad.LightBulb.TurnRed() End If End Sub Else Statement The Else statement is always used with the If statement and has a very useful purpose that would be perfect for the last example. Previously, we needed to check if the button is pressed and if the button is not pressed. We can simplify this by catching when an If statement isn't true using Else as shown in the code below. Public Sub BrainPadSetup() BrainPad.LightBulb.TurnOff() End Sub Public Sub BrainPadLoop() If BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnGreen() Else BrainPad.LightBulb.TurnOff() End If End Sub This code uses an else statement to check if a button is pressed or not to turn the LightBulb green and off. Or & And Operators The most used logical operators are the Or and And operators. These are typically used within the If statement. In the example below, we want the buzzer to generate a 5,000 Hz sound when both the up and down buttons are pressed. This is accomplished by using an && operator between IsUpPressed() and IsDownPressed() . Public Sub BrainPadLoop() If BrainPad.Button.IsUpPressed() And BrainPad.Button.IsDownPressed() Then BrainPad.Buzzer.Start(5000) Else BrainPad.Buzzer.Stop() End If End Sub This code checks if both up and down are pressed, if so it plays a high pitch sound. Exercise Turn the LightBulb GREEN on and play the buzzer at 5,000 Hz whenever the up or down button is pressed. Pressing both or either one will have the same effect. Extra Credit Tip: Use nested statements such as an If statement inside another If statement."
  },
  "hardware/legacy_products/gadgeteering.html": {
    "href": "hardware/legacy_products/gadgeteering.html",
    "title": "Gadgeteering",
    "keywords": "Gadgeteering Gadgeteering was meant to extend Gadgeteer beyond NETMF. We are making our hardware and software available for reference only. All material is found at this github repository"
  },
  "hardware/legacy_products/mbuino.html": {
    "href": "hardware/legacy_products/mbuino.html",
    "title": "mBuino",
    "keywords": "mBuino The mBuino is a tiny keychain circuit. It is GHI Electronics contribution to the mbed community. Learn more here Schematic"
  },
  "hardware/legacy_products/gadgeteer/fez_hydra.html": {
    "href": "hardware/legacy_products/gadgeteer/fez_hydra.html",
    "title": "FEZ Hydra",
    "keywords": "FEZ Hydra FEZ Hydra is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). Resources Schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS If you haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading Bootloader v2 (coming soon!) Loading the Firmware (coming soon!)"
  },
  "hardware/legacy_products/gadgeteer/fez_spider.html": {
    "href": "hardware/legacy_products/gadgeteer/fez_spider.html",
    "title": "FEZ Spider",
    "keywords": "FEZ Spider FEZ Spider is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Spider is the EMX System on Module (SoM). Resources Schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading Bootloader v2 Tip The EMX bootloader version 1 doesn't always work with Windows 7 and newer (Error code 10). You can use the serial option to update the loader. This is a one-time procedure. You should have no issues after the bootloader V2 is loaded. To update using USB Download the EMX bootloader file Set the board's configuration switches in boot mode. That is by setting switches #1, #2 and #3 to the ON position. Connect the FEZ Spider to a power module (red module) and then to a PC. The PC will now detect a virtual serial (COM) device. If you need drivers, they are in the NETMF SDK. Open any terminal software, we recommend Tera Term . Select serial and pick the COM port associated with your board. Enter E and you will see back \"Erase all memory! Are you sure?\" now enter Y . (The bootloader is case sensitive) Enter X and you will see CCCC ... showing on the terminal. Now go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the bootloader file you have downloaded above. You will see File Transfer Finished Successfully . Change the configuration switches back to the off position and reset the board. You are now running GHI Electronics bootloader v2! To update using Serial Connect a USB-serial module to socket 11. Follow the exact same steps above except you need to also switch #4 to ON (serial mode) and you need to set the baud rate to 115200 on the terminal software. The drivers for the USB-serial module should load automatically. If not, get them from http://www.ftdichip.com/ Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, set the configuration switch #1 to the on position and then reset your board. Make sure to set back to off after loading the firmware. Download the EMX firmware and follow Loading the Firmware steps."
  },
  "hardware/legacy_products/netmf/chipworkx.html": {
    "href": "hardware/legacy_products/netmf/chipworkx.html",
    "title": "ChipworkX",
    "keywords": "ChipworkX ChipworkX is a NETMF System on Module. To use with NETMF, follow these setup instructions . Needs the NETMF 4.1 SDK. Resources User Manual"
  },
  "tinyclr/tutorials/gpiopulsereaderwriter.html": {
    "href": "tinyclr/tutorials/gpiopulsereaderwriter.html",
    "title": "Gpio Pulse Reader Writer",
    "keywords": "Gpio Pulse Reader Writer Gpio Pulse Reader Writer works in the current release. Documentation is coming soon. var pulse = new GpioPulseReaderWriter(GpioPulseReaderWriter.Mode.DrainDuration, true, 100, FEZ.GpioPin.A1); See this for now https://old.ghielectronics.com/docs/326/pulse-feedback"
  },
  "tinyclr/tutorials/i2c.html": {
    "href": "tinyclr/tutorials/i2c.html",
    "title": "I2C",
    "keywords": "I2C I2C (pronounced eye-squared-sea, or eye-two-sea) was originally developed by Phillips to allow multiple chipsets to communicate on a 2-wire bus in home consumer devices. It has a master and one or more slaves sharing the same data bus. Instead of selecting the slaves using a digital pin like SPI, which consumes an additional I/O pin, I2C uses an addressing mechanism to communicate to a selected device. Before data is transferred, the master sends out a 7-bit address of the slave device it wants to communicate with. It also sends one bit indicating whether it wants to send data to the slave or receive data from the slave. When a slave sees its address on the bus, it will acknowledge its presence. At this point, the master can send or receive data. The master will start data transfers with a \"start condition\" before it sends any address or data and then end it with \"stop condition\". The two wires used to communicate between the I2C Master and the I2C salves are called SDA and SCL lines; SDA stands for Serial Data, and SCL is Serial Clock. This is a partial demo showing the use of I2C. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.I2c; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var settings = new I2cConnectionSettings(0x1C)// the slave's address { BusSpeed = I2cBusSpeed.FastMode }; var device = I2cDevice.FromId(FEZ.I2cBus.I2c1, settings); device.Write(new byte[] { 1, 2 });// write something device.WriteRead(...)// this is good for reading registers } } Software I2C The I2C bus is relatively simple and can be \"bit banged\" using software. The advantage is that any two GPIO pins can be used. However, software I2C requires more system resources and runs slower. This example initializes the software I2C drivers and then, from this point, using I2C is the same as standard hardware I2C. using GHIElectronics.TinyCLR.Devices.I2c; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var softwareProvider = new I2cSoftwareProvider(FEZ.GpioPin.PA0, FEZ.GpioPin.PA1); var controllers = I2cController.GetControllers(softwareProvider); var controller = controllers[0]; var device = controller.GetDevice(new I2cConnectionSettings(0x22) { BusSpeed = I2cBusSpeed.StandardMode, SharingMode = I2cSharingMode.Exclusive }); } }"
  },
  "brainpad/courses/intro.html": {
    "href": "brainpad/courses/intro.html",
    "title": "Courses Intro",
    "keywords": "Courses Intro Here you will find course to cover many topics, for every level or experience. Are you a teacher? We want to hear from you. Please contact us directly or through our community forum . BrainPad for non-programmers One of the strongest values of the BrainPad is that is is programmed easilly using world-class developer tools. The same tools use by millions of professional developers. But the use of the BrainPad goes beyond to teach non-programming classes. For example, this video doesn't tech programming but it uses the BrainPad to run a stepper motor controller."
  },
  "hardware/legacy_products/intro.html": {
    "href": "hardware/legacy_products/intro.html",
    "title": "Legacy Products Introduction",
    "keywords": "Legacy Products Introduction This section covers some details on legacy products. These products are not recommended for new designs and are no longer covered by our free support. Please contact us directly for details on our paid support services. Tip Our community forums is a great place to get help from our engineers and from the thousands of community members. Producing Legacy Products GHI Electronics is the engineering and the manufacturing behind all its products. While some products have been made legacy and not recommended for new designs, they can still be produced. There may be a required minimum order quantity. We understand the seriousness of the need for a decent product longevity and availability. Please contact us directly to discuss ways to fulfill your immediate needs and also to discuss the upgrade options."
  },
  "hardware/legacy_products/gadgeteer/fez_cobra_ii.html": {
    "href": "hardware/legacy_products/gadgeteer/fez_cobra_ii.html",
    "title": "FEZ Cobra II",
    "keywords": "FEZ Cobra II FEZ Cobra II is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Cobra II is the G120 System on Module (SoM). Resources Schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading Bootloader v2 Download the bootloader file Press and keep holding the LDR0 and LDR1 buttons while resetting the board. Then release the buttons. The PC will now detect a virtual serial (COM) device. If you need drivers, they are in the NETMF SDK. Open any terminal software, we recommend Tera Term . Select serial and pick the COM port associated with your board. Enter E and you will see back \"Erase all memory! Are you sure?\" now enter Y . (The bootloader is case sensitive) Enter X and you will see CCCC ... showing on the terminal. Now go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the bootloader file you have downloaded above. You will see File Transfer Finished Successfully . Reset your board, you are now running GHI Electronics bootloader v2! Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, press and hold the LDR0 button while resetting the board. Download the G120 firmware and follow Loading the Firmware steps."
  },
  "hardware/legacy_products/gadgeteer/fez_reaper.html": {
    "href": "hardware/legacy_products/gadgeteer/fez_reaper.html",
    "title": "FEZ Reaper",
    "keywords": "FEZ Reaper FEZ Reaper is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Reaper is the G80 System on Chip (SoC). Resources Schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading Bootloader v2 The G80 SoC ships with the Bootloader loaded and locked. No further steps are necessary. Loading the Firmware To activate bootloader v2, press and hold both LDR0 and LDR1 buttons down while resetting the board. Download the G80 firmware and follow Loading the Firmware steps."
  },
  "hardware/legacy_products/gadgeteer/fez_spider_ii.html": {
    "href": "hardware/legacy_products/gadgeteer/fez_spider_ii.html",
    "title": "FEZ Spider II",
    "keywords": "FEZ Spider II FEZ Spider II is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Spider II is the G120E System on Module (SoM). Resources Schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading Bootloader v2 Download the bootloader file Set the board's configuration switches in boot mode. That is by setting switches #1 and #2 to the on position. Connect the FEZ Spider to a power module (red module) and then to a PC. The PC will now detect a virtual serial (COM) device. If you need drivers, they are in the NETMF SDK. Open any terminal software, we recommend Tera Term . Select serial and pick the COM port associated with your board. Enter E and you will see back \"Erase all memory! Are you sure?\" now enter Y . (The bootloader is case sensitive) Enter X and you will see CCCC ... showing on the terminal. Now go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the bootloader file you have downloaded above. You will see File Transfer Finished Successfully . Change the configuration switches back to the off position and reset the board. You are now running GHI Electronics bootloader v2! Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, set the configuration switch #1 to the on position and then reset your board. Make sure to set back to off after loading the firmware. Download the G120 firmware and follow Loading the Firmware steps."
  },
  "hardware/legacy_products/gadgeteer/intro.html": {
    "href": "hardware/legacy_products/gadgeteer/intro.html",
    "title": ".NET Gadgeteer Intro",
    "keywords": ".NET Gadgeteer Intro .NET Gadgeteer that was initiated by Microsoft Research and taken to production by GHI Electronics in the year 2011. .NET Gadgeteer had a great few year run, where it was loved for its plug-and-play mainboard and modules. Tip We will refer to .NET Gadgeteer as Gadgeteer throughout the rest of the documentation. The core of .NET Gadgeteer is .NET Micro Framework (NETMF). Like Gadgeteer, NETMF is no longer evolved by Microsoft and left for the community. Learn more about NETMF Sadly, and after 5 years of building modules and mainboards, GHI Electronics had to announce the EOL for Gadgeteer; however, the Gadgeteer hardware can still be used with TinyCLR OS . External resources: Microsoft's .NET Gadgeteer website (down) http://www.gadgeteer.com/ Microsoft's NETMF website (outdated) http://www.netmf.com/ Most of the Gadgeteer ecosystem is open source: Microsoft's .NET Gadgeteer Core GHI Electronics' Software sources and Hardware design files The Gadgeteer graphical designer was never made available by Microsoft. Socket Map The magic of Gadgeteer is in its socket map Socket Pin1 Pin2 Pin3 Pin4 Pin5 Pin6 Pin7 Pin8 Pin9 Pin10 A +3.3V +5V AIN (G!) AIN (G) AIN GPIO [UN] [UN] [UN] GND B +3.3V +5V LCD B0 LCD B1 LCD B2 LCD B3 LCD B4 LCD ENABLE LCD CLK GND C +3.3V +5V GPIO! CAN TD (G) CAN RD (G) GPIO [UN] [UN] [UN] GND D +3.3V +5V GPIO! D- D+ GPIO GPIO [UN] [UN] GND E +3.3V +5V [UN] LED1 (OPT) LED2 (OPT) TX D- TX D+ RX D- RX D+ GND F +3.3V +5V GPIO! DAT0 DAT1 CMD DAT2 DAT3 CLK GND G +3.3V +5V LCD G0 LCD G1 LCD G2 LCD G3 LCD G4 LCD G5 LCD BACKLIGHT GND H +3.3V +5V GPIO! D- D+ [UN] [UN] [UN] [UN] GND I +3.3V +5V GPIO! [UN] [UN] GPIO [UN] SDA SCL GND K +3.3V +5V GPIO! TX (G) RX (G) RTS CTS [UN] [UN] GND O +3.3V +5V GPIO! GPIO AOUT [UN] [UN] [UN] [UN] GND P +3.3V +5V GPIO! [UN] [UN] GPIO PWM (G) PWM (G) PWM GND R +3.3V +5V LCD R0 LCD R1 LCD R2 LCD R3 LCD R4 LCD VSYNC LCD HSYNC GND S +3.3V +5V GPIO! GPIO GPIO CS MOSI MISO SCK GND T +3.3V +5V [UN] YU XL YD XR [UN] [UN] GND U +3.3V +5V GPIO! TX (G) RX (G) GPIO [UN] [UN] [UN] GND X +3.3V +5V GPIO! GPIO GPIO [UN] [UN] [UN] [UN] GND Y +3.3V +5V GPIO! GPIO GPIO GPIO GPIO GPIO GPIO GND Z +3.3V +5V [MS] [MS] [MS] [MS] [MS] [MS] [MS] GND * +3.3V +5V GPIO! GPIO GPIO [MS] [MS] [MS] [MS] GND Symbol Description AIN Analog input pin. GPIO A general-purpose digital input/output pin, operating at 3.3 volts. (G) In addition to another functionality, a pin that is also usable as a GPIO. [UN] Modules must not connect to this pin if using this socket type. Mainboards can support multiple socket types on one socket, as long as individual pin functionalities overlap in a compatible manner, so that a pin from one socket type can overlap with a [UN] pin of another. ! Interrupt-capable and software pull-up capable GPIO (the pull-up is switchable and in the range of 10,000 to 100,000 ohms). +3.3V Connection to the +3.3 V power net. +5V Connection to the +5 V power net. GND Connection the power ground net. Using .NET Gadgeteer To use the .NET Gadgeteer legacy software, install: Visual Studio 20013 (community edition is also supported) Unzip and install netmfvs2013.vsix and MicroFramewrokSDK.msi from here Microsoft's Gadgeteer Core GHI Electronics' NETMF SDK . The latest is recommended. The Gadgeteer for Beginners guide is a good starting point. Tip You can only use Visual Studio 2013, not a newer edition, unless you are using your Gadgeteer hardware with TinyCLR OS . With TinyCLR OS All .NET Gadgeteer devices are still useable today, and with the latest technologies, thanks to efforts by GHI Electronics and the community. It all started in this video! This means you can still use all your beloved .NET Gadgeteer gear with TinyCLR OS . The first step needed to use TinyCLR OS is to load the GHI Bootloader v2 onto your mainboard, then use that to load the TinyCLR OS firmware. Each mainboard product page includes the needed instructions. Once those are loaded, you can start blinking the debug LED, detailed in the next section. Blinking the LED Tip If you have never used TinyCLR OS before, start here This example will blink the debug LED. You only need to add a power module to your mainboard. using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var led = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.DebugLed); led.SetDriveMode(GpioPinDriveMode.Output); while(true) { led.Write(GpioPinValue.High); Thread.Sleep(200); led.Write(GpioPinValue.Low); Thread.Sleep(200); } } } Tip The complete pin mapping is made available through GHIElectronics.TinyCLR.Pins . You should not need to use any schematics. Replace FEZSpider with your mainboard's name. Adding Gadgeteer Modules You are now ready to start adding modules ."
  },
  "hardware/legacy_products/netmf/emx.html": {
    "href": "hardware/legacy_products/netmf/emx.html",
    "title": "EMX System on Module",
    "keywords": "EMX System on Module EMX is a NETMF System on Module. Resources User Manual Using the NETMF software We discourage the use of NETMF software on our products in favor for TinyCLR OS, Read more about the use of NETMF and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET NETMF devices with TinyCLR OS Loading Bootloader v2 Tip The bootloader version 1 doesn't always work with Windows 7 and newer (Error code 10). You can use the serial option to update the loader. This is a one-time procedure. You should have no issues after the bootloader V2 is loaded. To update using USB Download the bootloader file Set EMX in boot mode, by making pins 3,7 and 53 low and reset EMX. (Pin3=P0.4 | Pin7=P2.5 | Pin53=P2.11) The PC will now detect a virtual serial (COM) device. If you need drivers, they are in the NETMF SDK. Open any terminal software, we recommend Tera Term . Select serial and pick the COM port associated with your board. Enter E and you will see back \"Erase all memory! Are you sure?\" now enter Y . (The bootloader is case sensitive) Enter X and you will see CCCC ... showing on the terminal. Now go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the bootloader file you have downloaded above. You will see File Transfer Finished Successfully . Change the configuration switches back to the off position and reset the board. You are now running GHI Electronics bootloader v2! To update using Serial Connect a development PC to COM1 on EMX, Pin5 and Pin6 (through RS232 converter or a USB-Serial TTL cable). SET LMODE pin low. Follow the steps above to load the firmware. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, set Pin3 low (double check) and then reset your board. Download the EMX firmware and follow Loading the Firmware steps. EMX Based products EMX Dev Sys The development system used for evaluating the EMX SoM. Schematics FEZ Cobra A single board computer Schematics"
  },
  "hardware/legacy_products/netmf/intro.html": {
    "href": "hardware/legacy_products/netmf/intro.html",
    "title": "NETMF Intro",
    "keywords": "NETMF Intro .NET Micro Framework (NETMF) is a subset of the full .NET. Initiated by Microsoft for SPOT watches and then later open sourced. The latest working version Visual Studio working with our NETMF products is VS2013. Tip We discourage the use of NETMF on our products in favor of TinyCLR OS . Learn more about using NETMF devices with TinyCLR OS . To use NETMF, install: Visual Studio 20013 (community edition is also supported) Unzip and install netmfvs2013.vsix and MicroFramewrokSDK.msi from here One of the available NETMF SDKs . The latest is recommended. The NETMF for Beginners guide is a good starting point. Available NETMF SDKs Release notes are found within the SDKs. Date NETMF Core Rev SDK Jun 27, 2016 4.3 QFE2 GHI Electronics NETMF SDK 2016 R1 Aug 31, 2015 4.3 QFE2 GHI Electronics NETMF SDK 2015 R1 Oct 29, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R5 Oct 8, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R4 Sep 15, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R3 Jul 31, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R2 Jan 29, 2014 4.3 RTM NETMF and Gadgeteer Package 2014 R1 Oct 23, 2013 4.3 RTM NETMF and Gadgeteer Package 2013 R3 Aug 27, 2013 4.3 RTM NETMF and Gadgeteer Package 2013 R2 Apr 30, 2013 4.3 RTM NETMF and Gadgeteer Package 2013 R1 Update 1 Feb 14, 2013 4.2 QFE2 NETMF and Gadgeteer Package 2013 R1 Feb 17, 2012 4.1 RTM NETMF 4.1 SDK, for Embedded Master, USBizi and ChipworkX (Includes IoT book for FEZ Panda) With TinyCLR OS Most NETMF devices are still useable today, and with the latest technologies. To use TinyCLR OS, you need to load a new bootloader and the TinyCLR OS firmware. Loading the Bootloader v2 Before loading the TinyCLR OS firmware, we need load the GHI Electronics' Bootloader Version 2 . Each board has specific instructions on loading the bootloader. The instructions are found on the individual board's pages. Running TinyCLR OS Individual product pages detail how to put the device into loader mode to load the firmware. Once running TinyCLR OS, start with the TinyCLR OS intro tutorial ."
  },
  "hardware/products/fez.html": {
    "href": "hardware/products/fez.html",
    "title": "FEZ",
    "keywords": "FEZ FEZ (fast and easy) is the official board for TinyCLR OS. This low-cost, WiFi IoT-ready, Arduino-pinout compatible, and TinyCLR-OS-ready board is everything a developer needs to evaluate TinyCLR OS and to build modern IoT applications. We have also handpicked some 3rd-party accessories to help you get going even faster. TinyCLR OS TinyCLR OS allows tiny systems to run .NET applications with rich debugging capabilities though Visual Studio 2017. TinyCLR OS Website TinyCLR on FEZ TinyCLR Ports Repo Other Options TinyCLR OS is the official supported platform for FEZ; however, these are some other good options. GHI Electronics is not affiliated and does not provide support for any of these 3rd party options. Arduino Arduino is simplified multi-platform IDE/C++ combo, with a community STM32 options. This video shows the use of Arduino (The FEZ and the BrainPad share the same hardware core). Arduino Website Arduino STM32 Github mbed mbed is an online compiler platform. There is nothing to install, just log in and start coding! One of the supported boards is Nucleo-F401RE, which uses the exact same microcontroller found on FEZ. Start with it to build and compile then follow the STM32 bootloader instructions on generating and loading DFU files. This video shows the steps needed to use Mbed (The FEZ and the BrainPad share the same hardware core). mbed Website Nucleo-F401RE MicroPython MicroPython allows tiny systems to run Python 3, with a small subset of the standard library. The STM32F4 is already one of available ports, making it easier to run MicroPython on FEZ. This video shows the steps needed to use MicroPython (The FEZ and the BrainPad share the same hardware core). MicroPyho Website GitHub Repo Plain Coding! You can just start coding everything from scratch. The easiest options would be to start with Mbed online tools and then export the project. Wither way, you can use free open-source GNU GCC tools to build your programs, which is what we use to build TinyCLR OS firmware. Another option is to use a commercial compiler, like Keil compiler/IDE. Keil tools are free for 32KB or less program size (MDK-Lite). Tip If you are not adding a SWD-JTAG tool, like ST-Link, follow the STM32 bootloader instructions on generating and loading DFU files. Keil Website Keil ARM MDK tools GNU ARM Tools (GCC)"
  },
  "hardware/products/intro.html": {
    "href": "hardware/products/intro.html",
    "title": "Products Introduction",
    "keywords": "Products Introduction This section covers technical details on our products. You may contact us directly for further assistance or visit our community forums ."
  },
  "hardware/products/ucm/g400.html": {
    "href": "hardware/products/ucm/g400.html",
    "title": "G400",
    "keywords": "G400 G400S and G400D are .NET Micro Framework (NETMF) System on Modules. Datasheet Using the NETMF software We discourage the use of NETMF software on our products in favor for TinyCLR OS. Read more about the use of NETMF and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using NETMF devices with TinyCLR OS Loading Bootloader Version 2 Download the bootloader file . Download and install SAM-BA. We tested SAM-BA.2.12.exe but we should move to SAM-BA.2.16 for Windows Download and unzip the update scripts . You will have a folder called G400 Bootloader Installer . Rename the bootloader file, downloaded earlier, to bootloader.bin and move it to the G400 Bootloader Installer folder. Connect SPI1_MISO pin to ground and reset the board. Wait three seconds and remove the connection between SPI1_MISO and ground. on FEZ Raptor, SPI1_MISO is pin 8 on socket 3. Open up the Device Manager, look under Ports, and find a COM port similar to \"Bossa Program Port\" or \"GPS Detect\". In the G400 Bootloader Installer folder, run Flash Bootloader.bat . When prompted, enter the number of the COM port found under Device Manager. For example: for COM10, enter just 10. You will see \"Bootloader Update Complete\" when the update is finished. The update will take several minutes. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, hold the LDR0 signal low while resetting the board. Download the G400 firmware and follow Loading the Firmware steps. Tip The upload takes several seconds to start. Wait about a minute to start seeing the upload progress. G400 Based products G400 Development Board The development system used for evaluating the G400 SoM. Schematic G400 TH Module A though-hole version of G400. Schematic"
  },
  "hardware/products/ucm/intro.html": {
    "href": "hardware/products/ucm/intro.html",
    "title": "UCM Products Introduction",
    "keywords": "UCM Products Introduction Coming soon."
  },
  "brainpad/expandability.html": {
    "href": "brainpad/expandability.html",
    "title": "Expandability",
    "keywords": "Expandability Additional functionality can be added to the BrainPad through its expansion headers. This can be done through a plug-and-play click modules or by direct wiring. Plug-and-play Click Modules This is an easy option as these modules simply plug in. There are hundreds of available options https://shop.mikroe.com/click This page covers further details on the click modules Advanced users can add any of the available modules. However, there are courses that cover specific modules and include all the needed drivers. Direct Wiring This option is only recommended for advanced users with electronics background. As a demo, we built this robot with a chassis we ordered from Amazon http://a.co/dwzywoI The continuous servo motors simply plug in. Pay attention to wires, where the orange wire should be connected to the pin labeled with ~. We then used a breadboard with an ultrasonic distance sensor. This will be used to detect objects, to back up the robot. BrainPad.ServoMotors.ServoOne.ConfigureAsContinuous(false); BrainPad.ServoMotors.ServoTwo.ConfigureAsContinuous(true); BrainPad.Display.DrawSmallTextAndShowOnScreen(0, 20, \"Press Left\"); while (BrainPad.Buttons.IsLeftPressed() == false) { // Beep BrainPad.Buzzer.Beep(); BrainPad.Wait.Seconds(0.3); } BrainPad.Display.ClearScreen(); BrainPad.Display.DrawSmallTextAndShowOnScreen(40, 20, \"Go!\"); //BrainPad.ServoMotorsIsServoTwoInverted(true); bool dirrection = true; BrainPad.ServoMotors.ServoOne.Set(50); BrainPad.Display.DrawSmallTextAndShowOnScreen(40, 20, \"Reflect\"); // using reflector bool use_builtin = true; if (use_builtin) { GpioPulseReaderWriter echolen = new GpioPulseReaderWriter( GpioPulseReaderWriter.Mode.EchoDuration, true, 10, BrainPad.Expansion.GpioPin.Mosi, true, BrainPad.Expansion.GpioPin.Miso); Move(100, 60); //dance! while (true) { double l = echolen.Read(); BrainPad.Display.DrawSmallTextAndShowOnScreen(0, 0, l.ToString()); if (l < 600) { Move(-100, -100); BrainPad.Wait.Seconds(1); Move(-100, 100); BrainPad.Wait.Seconds(0.5); Move(100, 60); } BrainPad.Wait.Seconds(0.3); } } This other demo video talk about stepper motors and uses the BrainPad."
  },
  "brainpad/courses/programming/intro.html": {
    "href": "brainpad/courses/programming/intro.html",
    "title": "Programming Intro",
    "keywords": "Programming Intro Coming soon."
  },
  "hardware/legacy_products/raspberrypi_hats.html": {
    "href": "hardware/legacy_products/raspberrypi_hats.html",
    "title": "Raspberry Pi Hats",
    "keywords": "Raspberry Pi Hats Several HATs were made for the RPI. The software was focused on the use of Win10. This GitHub repo includes the software for all HATs. FEZ HAT Schematic FEZ ProtoPi Schematic FEZ Utility Schematic FEZ Cream This HAT was part of the Gadgeteering efforts. Schematic"
  },
  "hardware/legacy_products/gadgeteer/fez_raptor.html": {
    "href": "hardware/legacy_products/gadgeteer/fez_raptor.html",
    "title": "FEZ Raptor",
    "keywords": "FEZ Raptor FEZ Raptor is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Spider is the G400S System on Module (SoM). Resources Schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading GHI Bootloader v2 Follow the exact same steps found on the G400 page. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, press and hold the LDR0 button while resetting the board. Download the G400 firmware and follow Loading the Firmware steps."
  },
  "hardware/legacy_products/gadgeteer/modules.html": {
    "href": "hardware/legacy_products/gadgeteer/modules.html",
    "title": ".NET Gadgeteer Modules",
    "keywords": ".NET Gadgeteer Modules This page lists all .NET Gadgeteer modules and how they can be used with TinyCLR OS . If you are planning on using the old NETMF/Gadgeteer software, which we discourage, then read the .NET Gadgeteer Intro page. Tip You can use Intellisense with the pin definition class to quickly determine where things go. For example: Typing FEZSpider.GpioPin.Socket4. lists the available GPIO pins on socket 4 Another example: Typing FEZSpider.UartPort. lists all available UART sockets (that is \"U\" in the old Gadgeteer standard) Tip We will be using the original, and most popular, FEZ Spider as a base for this page but any other mainboard will work very similarly. Accel G248 The Accel G248 measures acceleration though I2C bus. Use the original Gadgteer driver as a reference. Schematic Barometer Measures pressure. Use the original Gadgteer driver as a reference. Schematic Bluetooth Use the original Gadgteer driver as a reference. Schematic Breadboard X1 An easy breadboard option. Simply access the socket directly to wire whatever your heart desires! Schematic Breakout Simply a breakout of all signals. Schematic Breakout TB10 Simply a breakout of all signals, on a terminal block. Schematic Button The Button module is very simple, with a button connected to pin 3 and an LED connected to pin4. This example will blink the LED at different rates, depending on the button press. using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var LED = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.Socket4.Pin4); LED.SetDriveMode(GpioPinDriveMode.Output); var Button = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.Socket4.Pin3); Button.SetDriveMode(GpioPinDriveMode.InputPullUp); var speed = 200; while (true) { if (Button.Read() == GpioPinValue.High) speed = 200;// high = button is not pressed else speed = 500;// low = button is pressed // blink the LED LED.Write(GpioPinValue.High); Thread.Sleep(speed); LED.Write(GpioPinValue.Low); Thread.Sleep(speed); } } } Schematic Button S7 7 buttons on a single module, with LEDs that light up with button presses! Use the same code example provided for the Button Module. Buttons map: Left: Pin Right: Pin 8 Up: Pin 6 Down: Pin 7 Enter: Pin 3 Back: Pin 4 Forward: Pin 9 Schematic CAN DW CAN is not yet supported in TinyCLR OS, you can add it if you are up for a challenge! Schematic Camera USB Host is not supported in TinyCLR OS Schematic Cellular Radio Use the original Gadgteer driver as a reference. Schematic Character Display This is a standard and very common HD44780 display. Use the original Gadgteer driver as a reference. Schematic ColorSense A color sensor that uses software I2C, not yet supported in TinyCLR OS. Use the original Gadgteer driver as a reference. Schematic Compass Use the original Gadgteer driver as a reference. Schematic Current ACS712 This is a current sensor that uses ACS712, which simply outputs an analog voltage. Use the original Gadgteer driver as a reference. Schematic Display CP7 Read more about the display support on TinyCLR OS. The configurations for the display: // these are the wrong values! Width = 800, Height = 480, PixelClockRate = 24 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 16, HorizontalBackPorch = 46, HorizontalSyncPulseWidth = 1, HorizontalSyncPolarity = true, VerticalFrontPorch = 7, VerticalBackPorch = 23, VerticalSyncPulseWidth = 1, VerticalSyncPolarity = true, Schematic Display N18 This is an SPI display that can work on any system with SPI bus, even small ones without TFT display support. See the Display tutorial for more details. Schematic Display N7 Read more about the display support on TinyCLR OS. The configurations for the display: Width = 800, Height = 480, PixelClockRate = 24 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 16, HorizontalBackPorch = 46, HorizontalSyncPulseWidth = 1, HorizontalSyncPolarity = true, VerticalFrontPorch = 7, VerticalBackPorch = 23, VerticalSyncPulseWidth = 1, VerticalSyncPolarity = true, Schematic Display NHVN This allows the use of several displays offered by http://newhavendisplay.com/ Supported displays: NHD-4.3-480272EF-ATXL# NHD-4.3-480272EF-ATXL#-CTP NHD-4.3-480272EF-ATXL#-T NHD-7.0-800480EF-ATXL# NHD-7.0-800480EF-ATXL#-CTP NHD-7.0-800480EF-ATXV# NHD-7.0-800480EF-ATXV#-CTP Read more about the display support on TinyCLR OS. The configurations for all 4.3\" display: Width = 480, Height = 272, PixelClockRate = 20 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, The configurations for all 7\" display: Width = 800, Height = 480, PixelClockRate = 20 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 88, HorizontalBackPorch = 40, HorizontalSyncPulseWidth = 48, HorizontalSyncPolarity = false, VerticalFrontPorch = 13, VerticalBackPorch = 32, VerticalSyncPulseWidth = 3, VerticalSyncPolarity = false, As for the capacitive touch controller, use this old NETMF driver as a reference. Schematic Display T35 Read more about the display support on TinyCLR OS. The configurations for the display: Width = 320, Height = 240, PixelClockRate = 15 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 51, HorizontalBackPorch = 27, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 16, VerticalBackPorch = 8, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Schematic Display T43 Read more about the display support on TinyCLR OS. The configurations for the display: Width = 480, Height = 272, PixelClockRate = 20 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Schematic Display TE35 Read more about the display support on TinyCLR OS. The configurations for the display: Width = 320, Height = 240, PixelClockRate = 15 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 51, HorizontalBackPorch = 29, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 16, VerticalBackPorch = 3, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Schematic Distance US3 A very common ultrasonic sensor that works by sending a pulse on the trig Pin4 and measuring the response time on echo Pin3. GpioPulseReaderWriter echolen = new GpioPulseReaderWriter( GpioPulseReaderWriter.Mode.EchoDuration, true, 10, FEZSpider.GpioPin.Socket4.Pin4, true, FEZSpider.GpioPin.Socket4.Pin3); long time = echolen.Read(); Schematic Ethernet ENC28 Requires an internal support in the TinyCLR OS port or a managed TCP/IP stack. Schematic Ethernet J11D Requires an internal support in the TinyCLR OS port or a managed TCP/IP stack. Schematic Extender No drivers are needed. Schematic FEZtive Use the original Gadgteer driver as a reference. Schematic Flash Use the original Gadgteer driver as a reference. Schematic GPS Use the original Gadgteer driver as a reference. Schematic GasSense This module can host several different air sensors, like Alcohol and CO2. The sensor has an internal heater that needs to be enabled and then it is a simple analog read. using System.Threading; using System.Diagnostics; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var Enable = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.Socket10.Pin4); Enable.SetDriveMode(GpioPinDriveMode.Output); Enable.Write(GpioPinValue.High);// Enable the internal heater var Ain = AdcController.GetDefault().OpenChannel(FEZSpider.AdcChannel.Socket10.Pin3); while (true) { Debug.WriteLine(\"Ain: \" + Ain.ReadRatio()); Thread.Sleep(500); } } } Schematic Gyro Use the original Gadgteer driver as a reference. Schematic HD44780 See the Character Display Module Schematic HubAP5 No hub support is currently planned. Schematic IO60P16 This module provide 60 IOs and 16 PWM pins. Use the original Gadgteer driver as a reference. Schematic IR Receiver Use the original Gadgteer driver as a reference. Schematic Joystick The Joystick module has two analog inputs for X and Y position. Pressing the knob also works like a button. using System.Threading; using System.Diagnostics; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var AinX = AdcController.GetDefault().OpenChannel(FEZSpider.AdcChannel.Socket10.Pin4); var AinY = AdcController.GetDefault().OpenChannel(FEZSpider.AdcChannel.Socket10.Pin5); var Button = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.Socket10.Pin3); Button.SetDriveMode(GpioPinDriveMode.InputPullUp); while (true) { Debug.WriteLine(\"PosX: \" + AinX.ReadRatio() + \"%\"+ \"PosY: \" + AinY.ReadRatio() + \"%\"); if (Button.Read() == GpioPinValue.Low) Debug.WriteLine(\"Pressed!\"); Thread.Sleep(500); } } } Schematic Keypad KP16 Use the original Gadgteer driver as a reference. Schematic LED 7C An LED that can be set to one of 7 colors, 8 if you count off! using System.Threading; using System.Diagnostics; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var GPIO = GpioController.GetDefault(); var Red = GPIO.OpenPin(FEZSpider.GpioPin.Socket8.Pin4); Red.SetDriveMode(GpioPinDriveMode.Output); var Green = GPIO.OpenPin(FEZSpider.GpioPin.Socket8.Pin5); Green.SetDriveMode(GpioPinDriveMode.Output); var Blue = GPIO.OpenPin(FEZSpider.GpioPin.Socket8.Pin3); Blue.SetDriveMode(GpioPinDriveMode.Output); while (true) { // Off Red.Write(GpioPinValue.Low); Green.Write(GpioPinValue.Low); Blue.Write(GpioPinValue.Low); Thread.Sleep(500); // Red Red.Write(GpioPinValue.High); Green.Write(GpioPinValue.Low); Blue.Write(GpioPinValue.Low); Thread.Sleep(500); // Green Red.Write(GpioPinValue.Low); Green.Write(GpioPinValue.High); Blue.Write(GpioPinValue.Low); Thread.Sleep(500); // Blue Red.Write(GpioPinValue.Low); Green.Write(GpioPinValue.Low); Blue.Write(GpioPinValue.High); Thread.Sleep(500); // White Red.Write(GpioPinValue.High); Green.Write(GpioPinValue.High); Blue.Write(GpioPinValue.High); Thread.Sleep(500); // Yellow Red.Write(GpioPinValue.High); Green.Write(GpioPinValue.High); Blue.Write(GpioPinValue.Low); Thread.Sleep(500); // Magenta Red.Write(GpioPinValue.High); Green.Write(GpioPinValue.Low); Blue.Write(GpioPinValue.High); Thread.Sleep(500); // Cyan Red.Write(GpioPinValue.Low); Green.Write(GpioPinValue.High); Blue.Write(GpioPinValue.High); Thread.Sleep(500); } } } Schematic LED 7R This is a ring of 6 LEDs and a 7th center LED. Reference the LED 7C module for using pins. Center LED: pin 9 LEDs going clockwise starting from LEDs D1 to D6 on the board D1, D2, D3, D4, D5, D6 are pins 3 to 8 respectively. Schematic LED Strip A strip of 7 LEDs, connected to pins 3 through 9. Reference the LED 7C module for using pins. Schematic Light Sense Simply using analog on pin 3. Use the same code as the potentiometer. Schematic Load Each one of the 7 GPIO pins are connected to a transistor to handle a load, like a motor. Schematic MaxO Shift registers used to take serial SPI data and put on parallel pins, perfect for driving tons of LEDs. This video explains how this works Use the original Gadgteer driver as a reference. Schematic MicroSD Card No file system support yet. Schematic Moisture This is a simple analog input measuring the direct resistance (moisture). An enable pin needs to be activated. using System.Threading; using System.Diagnostics; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var Enable = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.Socket10.Pin6); Enable.SetDriveMode(GpioPinDriveMode.Output); Enable.Write(GpioPinValue.High);// Enable var Ain = AdcController.GetDefault().OpenChannel(FEZSpider.AdcChannel.Socket10.Pin3); while (true) { Debug.WriteLine(\"Ain: \" + Ain.ReadRatio()); Thread.Sleep(500); } } } Schematic Motor Driver The Motor Driver Module uses L298 H-bridge that can drive two motors up to 4A. Pin 6: Motor A Direction (GPIO) Pin 7: Motor A Speed (PWM) Pin 8: Motor B Direction (GPIO) Pin 9: Motor B Speed (PWM) Tip NETMF didn't handle PWM correctly. TinyCLR OS breaks PWM pins to individual channels. Read more about PWM . This example will setup both motors and then will make motor A go very slow forward then very fast backward, in a loop. using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { // Determine what PWM controller is used for specific pins, use the power of intellisense! // start typing FEZSpider.PwmPin. to navigate the options // Motor A var MotorDirA = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.Socket8.Pin6); MotorDirA.SetDriveMode(GpioPinDriveMode.Output); var ControllerA = PwmController.FromId(FEZSpider.PwmPin.Controller1.Id); ControllerA.SetDesiredFrequency(5000); var MotorSpeedA = ControllerA.OpenPin(FEZSpider.PwmPin.Controller1.Socket8.Pin7); // Motor B var MotorDirB = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.Socket8.Pin8); MotorDirB.SetDriveMode(GpioPinDriveMode.Output); var ControllerB = PwmController.FromId(FEZSpider.PwmPin.Controller1.Id); ControllerB.SetDesiredFrequency(5000); var MotorSpeedB = ControllerB.OpenPin(FEZSpider.PwmPin.Controller1.Socket8.Pin9); while (true) { MotorDirA.Write(GpioPinValue.High);// Forward MotorSpeedA.SetActiveDutyCyclePercentage(0.1);// slow 10% Thread.Sleep(500); MotorDirA.Write(GpioPinValue.Low);// Backwards MotorSpeedA.SetActiveDutyCyclePercentage(0.9);// fast 90% Thread.Sleep(500); } } } Schematic Multicolor LED A DaisyLink module, we will not support. Schematic Music The Music Module uses the popular VS1053 decoder chip that decodes MP3, WMA, OGG, MIDI and WAV files. Use the original Gadgteer driver as a reference. Schematic Null Modem No driver is needed. OBD II Use the original Gadgteer driver as a reference. OneWire X1 A breakout with a terminal block for easily connecting OneWire devices, specifically the common temperature probes. OneWire is not supported yet. Schematic PIR Motion detection. Simply pin 3 changes its state when it detects motion. Schematic Parallel CNC A DaisyLink module, we will not support. Schematic Potentiometer The Potentiometer module is simply a variable resistor connected to pin3. Rotating its knob will result in an analog value changing from min to max. using System.Threading; using System.Diagnostics; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var Ain = AdcController.GetDefault().OpenChannel(FEZSpider.AdcChannel.Socket10.Pin3); while (true) { Debug.WriteLine(\"Pos: \" + Ain.ReadRatio() + \"%\"); Thread.Sleep(500); } } } Schematic Pulse Count Use the original Gadgteer driver as a reference. Schematic Pulse InOut A DaisyLink module, we will not support. Schematic Pulse Oximeter Use the original Gadgteer driver as a reference. Schematic RFID Reader Use the original Gadgteer driver as a reference. Schematic RS232 Simply a serial port. Schematic RS485 Simply a serial port. Schematic Radio FM1 Use the original Gadgteer driver as a reference. Schematic Reflector R3 Use the original Gadgteer driver as a reference. Schematic Relay ISOx16 An array of 16 relays. Operate similar to the MaxO module. Use the original Gadgteer driver as a reference. Schematic Relay X1 Simply set pin 3 high to activate the relay. Schematic Rotary H1 Use the original Gadgteer driver as a reference. Schematic SD Card File system is not supported yet. Schematic S-Plus We will not support hubs. Schematic Serial Camera Use the original Gadgteer driver as a reference. Stepper L6470 Use the original Gadgteer driver as a reference. Schematic TempHumidity Use the original Gadgteer driver as a reference. Schematic Thermocouple Use the original Gadgteer driver as a reference. Schematic Touch C8 Use the original Gadgteer driver as a reference. Schematic Touch L12 Use the original Gadgteer driver as a reference. Schematic Tunes The Tunes Module is a tiny speaker that is connected to pin 9. Use PWM to generate sounds This example will keep changing the frequency. using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var controller = PwmController.FromId(FEZSpider.PwmPin.Controller0.Id); var buzz = controller.OpenPin(FEZSpider.PwmPin.Controller0.Socket11.Pin9); controller.SetDesiredFrequency(500);// change the frequency for sounds buzz.SetActiveDutyCyclePercentage(0.5);// always use this for sounds buzz.Start(); while (true) { controller.SetDesiredFrequency(500); Thread.Sleep(500); controller.SetDesiredFrequency(200); Thread.Sleep(500); } } } Schematic UC Battery 4xAA No driver is needed. Schematic USB Client DP No driver is needed. Schematic USB Client SP No driver is needed. Schematic USB Host USB Host is not currently supported. Schematic USB Serial Simply, a serial port. Schematic USB Serial SP Simply, a serial port. Schematic VideoOut Use the original Gadgteer driver as a reference. Schematic WiFi RN171 Use the original Gadgteer driver as a reference. Schematic WiFi RS21 Will not be supported, NDA issues. Schematic XBee Adapter Simply, a serial port. From there a driver like https://xbee.codeplex.com/ will help. Schematic"
  },
  "brainpad/courses/programming/csharp/intro.html": {
    "href": "brainpad/courses/programming/csharp/intro.html",
    "title": "Introduction to C# on the BrainPad",
    "keywords": "Introduction to C# on the BrainPad It is not a secret that C and C++ are the most popular programming languages among professionals. This is particularly true for programmers that work with small digital systems. C# (pronounced see-sharp) and a modern cousin of the C and C++ family. Its syntax is very close to Java, another very popular programming language. Overview Students will learn how to create projects in Visual Studio along with programming logic. Applications in this lesson will be limited to the BrainPad object, If statements, a While loop and the template methods. Install Visual Studio and TinyCLR OS extension Skip this step if you have Visual Studio 2017 and the TinyCLR OS extension installed: Setting Up Visual Studio for the BrainPad Guidelines Prerequisites: None Ages 6 and up PC setup with Visual Studio 2017 and TinyCLR OS extension installed. Click Here Supplies: BrainPad and microUSB cable. Starting a New C# BrainPad Project Next Open Visual Studio select File > New > Project and under Other Languages select Visual C# > TinyCLR and choose the BrainPad Application . Change the Location to C:\\Users\\<YourUsername>\\Desktop\\ then name the project BrainPad_Project . From Visual Studio, select File > New > Project: Once created, you'll be presented with a Program.cs tab. This file contains the default code when you first create a project. The lines in green that begin with // are called comments, and they generally describe what the code does. Take a moment to review them. You can create your own comments in the code by typing // before any notes you like to add. Comments don't affect how your program runs. Comments are a great place to keep notes about how a piece of code might work. They are helpful if another programmer looks at your code, or you return to look at your own code at a later date, to help you understand what the code is doing behind the scenes. Let's run the code to see these comments' descriptions come to life. Connect the BrainPad and press the F5 function key or the Start button. Visual Studio will now run the code, a few things will happen and the display will now have the text \"Hello!\" . The BrainPad Object The world around us is full of objects. Every person, table or circuit board is an object. If we were to ask a person to say \"hello,\" we'd be asking an object to perform a task. The same concept can be applied to code, specifically object-oriented programming. Like in the previous application we ran, the BrainPad was asked to control the Display through the BrainPad object. The BrainPad object itself, is a piece of code that is contained in one file. This was developed by GHI Electronics to cover the internals of the BrainPad. This enables students like you, with an easy way to control the BrainPad circuit board. After typing BrainPad , press the period key to get a list of all available options for this object, like LightBulb. As shown in the image below. Now we can use the arrow keys to go up and down in the list to find the LightBulb, and then press the period key again to see what options are the available for the LightBulb. Visual Studio does a great deal of simplifying the programming process by automatically listing available options for an object. They call this neat option built into Visual Studio, IntelliSense Now that we know how to use the BrainPad object, let's learn about controlling the LightBulb . The BrainPad LightBulb LED lights are used in many different electronic devices. Here we will test the LightBulb by turning it green, then on, then off. Copy and paste the code from the example below into your project's BrainPadSetup() , between its two curly braces { } . You'll also notice every line of code must ends with a semicolon ; Tip Parentheses ( ) and curly braces { } are used differently in C# programming, do not confuse them? BrainPad.LightBulb.TurnOff(); BrainPad.LightBulb.TurnGreen(); BrainPad.LightBulb.TurnOff(); BrainPad.LightBulb.TurnGreen(); Now, press F5 on the keyboard or the Start button in Visual Studio to run the code and you'll see the LightBulb turn green come on and stay on. This happens because our code is executed faster than we can see. So we never see the LightBulb actually blink. Problem Solving Since applications execute extremely fast, we need to slow them down to figure out the problem. This way we can see what is happening or if the results are as expected. We will start by running the code one line at a time, this is called stepping in code to see what the application does at a slow speed. Stepping in Code With Visual Studio we can \"step\" through the code executing each line separately one at a time. This will help when you're trying to debug a problem. To do this we need to add what is called a breakpoint or (stop point). A breakpoint is a spot in your program where the code will execute up until it reaches the breakpoint then wait for futher instructions. To add a breakpoint at the first line of code inside of BrainPadSetup() moving the cursor to that line and pressing the F9 key as shown below. A red circle will appear to the left of your code. This is where your code will stop and wait. You can also click in the grey area where the breakpoints appear to either remove or create new breakpoints. Your program can have as many breakpoints as you feel necessary to diagnose any programming issues. Press F5 key or Start button in Visual Studio to run the application. The project will be built and deployed but then the execution will stop at the breakpoint as shown below. Once a program reaches a breakpoint it pauses the program, right where it is in the code, as noted by the yellow arrow now in the red circle. You have several options to continue or step through you code line by line, while the program is still running. If you press the Continue button in the top tool bar of Visual Studio as shown below. Your program will continue, to the end of the code or the next breakpoint. To the right of the Continue button are more buttons for navigating the code while the program is running. Unlike the Continue button The Step Into button or F11 key advances your program one line of code at a time. This can be very useful when trying to diagnose programming errors. Adding Delays to Code In order to see what's going on we need to add some delays in the program code. This is done by telling the BrainPad to Wait between tasks. Copy and paste the code from below into your project's BrainPadSetup() , between the two curly braces { } . BrainPad.LightBulb.TurnOff(); BrainPad.Wait.Seconds(1); BrainPad.LightBulb.TurnGreen(); BrainPad.Wait.Seconds(1); BrainPad.LightBulb.TurnOff(); BrainPad.Wait.Seconds(1); BrainPad.LightBulb.TurnGreen(); Run the code by pressing F5 key or Start button in Visual Studo and observe the LightBulb again. You should now see it turn green, then on and off twice. Change the LightBulb Color This works great if you only want the LightBulb green. But what if you want a different color? The LED inside the LightBulb is capable of showing more colors than just green. LED TV's use many tiny LEDS lined up in rows and columns to make up the picture you see. Like the LED lights in a TV they are capable of showing many different colors inside just one LED. First let's use code similar to the last example, only this time will change the LightBulb from green to red to blue, using built-in methods already created. Copy and paste the code from below into your project's BrainPadSetup() , between the two curly braces { } . BrainPad.LightBulb.TurnOff(); BrainPad.LightBulb.TurnGreen(); BrainPad.Wait.Seconds(1); BrainPad.LightBulb.TurnOff(); BrainPad.LightBulb.TurnRed(); BrainPad.Wait.Seconds(1); BrainPad.LightBulb.TurnOff(); BrainPad.LightBulb.TurnBlue(); BrainPad.Wait.Seconds(1); Even more LightBulb Colors. Under the BrainPad.LightBulb object you'll find the method BrainPad.LightBulb.TurnColor() . The TurnColor(r,g,b) method takes three arguments which describe the color of the light bulb. The first argument tells the light bulb how much red to use, the second how much green, and the third how much blue. Each number is a percentage, or a number from 0 to 100 with 0 being off and 100 being full brightness. BrainPad.LightBulb.TurnColor(100, 100, 100); We'll now redo the code above that turns the light from Green to Red to Blue. But this time we'll use the TurnColor() method to achieve the exact same results. Copy and paste the code from below into your project's BrainPadSetup() , between the two curly braces { } . BrainPad.Display.DrawTextAndShowOnScreen(45, 0, \"Red\"); BrainPad.LightBulb.TurnColor(1, 0, 0); BrainPad.Wait.Seconds(2); BrainPad.Display.DrawTextAndShowOnScreen(35, 8, \"Green\"); BrainPad.LightBulb.TurnColor(0, 2, 0); BrainPad.Wait.Seconds(2); BrainPad.Display.DrawTextAndShowOnScreen(40, 16, \"Blue\"); BrainPad.LightBulb.TurnColor(0, 0, 5); BrainPad.Wait.Seconds(2); BrainPad.Display.DrawTextAndShowOnScreen(29, 24, \"Yellow\"); BrainPad.LightBulb.TurnColor(10, 10, 0); BrainPad.Wait.Seconds(2); BrainPad.Display.DrawTextAndShowOnScreen(41, 32, \"Cyan\"); BrainPad.LightBulb.TurnColor(0, 20, 20); BrainPad.Wait.Seconds(2); BrainPad.Display.DrawTextAndShowOnScreen(25, 40, \"Magenta\"); BrainPad.LightBulb.TurnColor(50, 0, 50); BrainPad.Wait.Seconds(2); BrainPad.Display.DrawTextAndShowOnScreen(37, 48, \"White\"); BrainPad.LightBulb.TurnColor(100, 100, 100); BrainPad.Wait.Seconds(2); BrainPad Buzzer Included on your BrainPad is a Buzzer. You can use this Buzzer to program different sounds youd like to use in your program. Like the BrainPad.LightBulb object, youll also have to tell the Buzzer object to Beep , StartBuzzing and StopBuzzing . Will also tell the BrainPad to Wait in between playing and not playing as sound. When you tell the BrainPad to Wait , the sound will play for that duration. Copy and paste the following code into your BrainPadSetUp() between the curly braces {} . Press F5 key or Start button in Visual Studio. BrainPad.Buzzer.StartBuzzing(100); BrainPad.Wait.Seconds(1); BrainPad.Buzzer.StopBuzzing(); You should hear a very low tone, that plays for one(1) second and stops. Inside the BrainPad.Buzzer.StartBuzzing(100) method youll see that in the code weve added the value of 100. This is the frequency of the sound that will be played by the Buzzer. You can change this value to create a bunch of different sounds. Lets try changing it. Copy and paste the following code into your BrainPadSetUp() between the curly braces {} . Press F5 or Start BrainPad.Buzzer.StartBuzzing(400); BrainPad.Wait.Seconds(1); BrainPad.Buzzer.StartBuzzing(100); BrainPad.Wait.Seconds(1); BrainPad.Buzzer.StopBuzzing(); First youll hear the Buzzer make a very high sound, then a very low sound. This is what changing the frequency does to the Buzzer. Try changing the frequency to different values and see what kind of sounds the Buzzer makes. BrainPad Buttons The BrainPad comes with four buttons (Up, Down, Left & Right) that can be programmed to do different things. Such as when a button is pressed the LightBulb turns on or the Buzzer makes a sound. To accomplish this we need to use what is called an \"if statement\" An \"if statement\" will check and see if our buttons are being pressed and then execute a piece of code when they are. If Statement if (condition) { Execute this code; } else { Execute this code; } An if statement (or conditional statement) checks to see if a statement is true or false and then does one of two things depending on the result. The example above shows the framework of the if statement. You'll also notice that the if statement is one of the few lines of code that DOES NOT require a semicolon ; at the end of the line. Although the code within the if statement still require an ending semicolon ; Now we'll use the same structure in our code to detect the LEFT button being pressed. public void BrainPadSetup() { BrainPad.LightBulb.TurnOff(); if (BrainPad.Buttons.IsLeftPressed()) { BrainPad.LightBulb.TurnGreen(); } } public void BrainPadLoop() { } For the above code to work properly, you have to be holding the button down at the time the program starts. This is because the code within the BrainPadSetup() method only executes once. When the program is first started. Holding down the Left button when the program starts is impractical and not very useful to a program. We need to be able to press & read the button anytime the program is running. To do this we will move the button checking \"if statement\" inside the BrainPadLoop() method instead of the BrainPadSetup() public void BrainPadSetup() { BrainPad.LightBulb.TurnOff(); } public void BrainPadLoop() { if (BrainPad.Buttons.IsLeftPressed()) { BrainPad.LightBulb.TurnGreen(); } } The above code, first makes sure the Light Bulb is OFF and then it falls into an infinite loop, the BrainpadLoop() . However, this program still has an operational bug. Run the program and test it. The green light will be off when the program runs and then once the LEFT button is pressed the green light will turn on. That is all good so far, but when the button is released, the green light stays on. Can you guess why? Try stepping in the code to see what happens when the button is pressed and when it is not pressed. Computers are strict at following orders. In the previous examples, the Light Bulb never turned off because we actually never told the program to turn the green light off. This means we have to tell the program to turn the light on when the button is pressed and we also have to tell it to turn the light off when the button is not pressed public void BrainPadSetup() { BrainPad.LightBulb.TurnOff(); } public void BrainPadLoop() { if (BrainPad.Buttons.IsLeftPressed()) { BrainPad.LightBulb.TurnGreen(); } if (!BrainPad.Buttons.IsLeftPressed()) { BrainPad.LightBulb.TurnOff(); } } The ! symbol represents the opposite. While the BrainPad doesnt have a method called BrainPad.Button.IsLeftNotPressed() we can continue to use BrainPad.Button.IsLeftPressed() but with a ! before it to represent if the button is not pressed. Now when you run it, not pressing the button will turn/keep the LightBulb off. Logical Operators -- Or & And -- || and && The Or operator is found by holding the shift key and pressing the || key twice, the And operator can be found by holding the shift key and pressing && twice These are typically used within the if statement . Lets assume in our previous example you wanted to press the Left button to make the LightBulb Green and when you press the Right button you want to make the LightBulb Red. If neither button is pressed the LightBulb is off. To accomplish this youll need to use the And operator && to check and make sure both buttons are Not (!) pressed, and turn off the LightBulb . In the code example below, in our third if statement , you can see where we ask the question, Is the Right button pressed And is the Left button pressed? Both of these condition must be met in order to execute the code in its curly braces { } . When using the Or operator || , only one of the conditions need to be met to run the code within the curly braces {} . public void BrainPadSetup() { BrainPad.LightBulb.TurnOff(); } public void BrainPadLoop() { if (BrainPad.Buttons.IsLeftPressed()) { BrainPad.LightBulb.TurnGreen(); } if (BrainPad.Buttons.IsRightPressed()) { BrainPad.LightBulb.TurnRed(); } if (!BrainPad.Buttons.IsLeftPressed() && !BrainPad.Buttons.IsRightPressed()) { BrainPad.LightBulb.TurnOff(); } } The Else Statement The else statement is always used with the if statement and has a very useful purpose that would be perfect for the last example. In previous code example, we needed to check if the Left button was pressed or not. We can simplify this by catching when an if statement isnt true using else as shown in the code below. public void BrainPadSetup() { BrainPad.LightBulb.TurnOff(); } public void BrainPadLoop() { if (BrainPad.Buttons.IsLeftPressed()) { BrainPad.LightBulb.TurnGreen(); // If TRUE } else { BrainPad.LightBulb.TurnOff(); // Else FALSE } } The Else-If Statement The else-if statement closely resembles the else statement but works like both an if statement and an else statement together. Unlike the else statement by itself, the else-if statement checks to make sure its condition is true before executing the code inside it's curly braces {} rather then just executing it by default. An example of the similar code as earlier but using an \"else-if statement\" instead. public void BrainPadSetup() { BrainPad.LightBulb.TurnOff(); } public void BrainPadLoop() { if (BrainPad.Buttons.IsLeftPressed()) { BrainPad.LightBulb.TurnGreen(); } else if (BrainPad.Buttons.IsRightPressed()) { BrainPad.LightBulb.TurnRed(); } else { BrainPad.LightBulb.TurnOff(); } } Whitespace Spaces and lines are used to make our code more readable to humans. C# programs completely ignore whitespace as shown in the code example below. It will execute correctly, but without whitespaces it can be very difficult to read and debug. public void BrainPadSetup(){BrainPad.TrafficLight.TurnGreenLightOff();}public void BrainPadLoop(){if (BrainPad.Button.IsUpPressed() && BrainPad.Button.IsDownPressed()){BrainPad.Buzzer.PlayFrequency(5000);}else{BrainPad.Buzzer.Stop();}}"
  },
  "brainpad/courses/programming/csharp/variables_and_nested_statements.html": {
    "href": "brainpad/courses/programming/csharp/variables_and_nested_statements.html",
    "title": "Variables and Nested Statements",
    "keywords": "Variables and Nested Statements Calling Methods & Arguments We've already talked a bit about methods like BrainPadSetup() and BrainPadLoop() . A Method Call is nothing more then when the method is used or called in your program. Arguments are values passed into these methods. The following examples list the different ways arguments can be used inside a method call. BrainPad.Buzzer.StartBuzzing(3000); The above example is used to play a sound on the Buzzer. We pass the argument 3000 to the BrainPad.Buzzer.StartBuzzing() method call. The 3000 represents the frequency to play. BrainPad.Wait.Seconds(0.5); The above example is a method that makes the BrainPad wait 0.5 seconds before executing the next line of code. The 0.5 is the argument. BrainPad.Wait.Seconds() is called the method call the argument goes inside the method call between the parenthesis () of the method. The Integer Variable A variable is a location in memory that is reserved for us to use. Instead having to know where the memory is, the system gives us access to that memory using a name we choose as shown in the example below The type tells the system how much memory to reserve for that one variable. The most widely used variable is an Integer , defined by the int before the variable name, which is 4 bytes and can hold large numbers and negative numbers. For now, we suggest using Integers for everything, except when fractions are needed (more on that later). int count; The above line instructs the system to reserve a variable as an that is named count and the variable type is an Integer, or int when coding. A variable name can use any letters and numbers but it cannot start with a number or contain spaces. Using the underscore symbol is allowed. Valid variable names: int count123; int count_me_in; int count2var; In-valid variables names: int count me; int count#; int 2count; Variables in small programs can use any names. It could even be just x. However, using a meaningful name is very important when writing programs, as there maybe hundreds of variables in a large program. One of the benefits of variables, is they can be used to store numbers as shown in the example below. int count; count = 10;  count = 123; In the above example, the count variable is stored with the a value of 10. Later in the code, the same varible is used to store a new number, 123. Varibles can also be used in equation as shown below int count = 5; int result; result = 5 + count; In the above example, we create two variables one named count , which is initilazed with the value of 10, and one named result which is empty. The last line of code, takes the count variable and adds 5 then stores the total in the variable we created named result You can also use the same variable in an equation to increment that variable. Like in the code below. count = count + 1; The code example above takes the current value of count adds 1 to it then stores the result back into the same count variable. This is handy when incrementing a number like the score in a game or counting the number of times something happens in a program. Tip You can shorten the above code to just count++; It means the same as count = count + 1; Using Variables to Change Buzzer Tones In the example below, we create two variables and use them to change the tone of the buzzer, each time a certian button is pressed. public class Program { int frequency; int increment; public void BrainPadSetup() { frequency = 0; increment = 0; } public void BrainPadLoop() { if (BrainPad.Buttons.IsUpPressed()) { increment = 100; } if (BrainPad.Buttons.IsDownPressed()) { increment = -100; } if (increment != 0) { frequency = frequency + increment; increment = 0; BrainPad.Buzzer.StartBuzzing(frequency); BrainPad.WriteToComputer(frequency); BrainPad.Wait.Seconds(0.2); BrainPad.Buzzer.StopBuzzing(); } } } As we use the up and down buttons to change the frequency, the value held by the frequency variable is printed in the Output Window. Using the code above, can we determine the highest frequency a person can hear? The if-statement with Variables The same way the if statement was used to check if a button was pressed, it can be used with variables. In the code below we show that if the frequency is larger than 6,000 turn the red light on, otherwise turn it off. Add the code shown below to the BrainPadLoop() in the example above, right above the BrainPad.Wait.Seconds(0.2) line. if (frequency > 6000) { BrainPad.LightBulb.TurnRed(); } else { BrainPad.LightBulb.TurnOff(); } Pressing the up button will increase the frequency. Once the frequency is greater than 6,000 the red light will turn on. Inspecting Variables Printing the variable value worked well for small programs with a single variable. It is not practical to continuously print every variable out when it comes to larger programs. Instead, we can use the debugger feature to pause the code and inspect variables. public class Program { int count; public void BrainPadSetup() { count = 0; } public void BrainPadLoop() { count = count + 1; BrainPad.WriteToComputer(count); BrainPad.Wait.Seconds(0.2); } } Add a breakpoint to the loop as shown below, then Press F5 key or Start button to start your program and step through the code. Move the mouse over the count variable in your code and wait a second. A pop up window will come up showing the value of the count variable as pictured below. If you press the Continue button the code will continue until the end of the code or it reaches another breakpoint. Since our code is in the BrainPadLoop it will circle around and stop at the same breakpoint, only this time the count variable will be incremented by one. Double Variable While an Integer can hold large numbers, it can't hold fractions. For example, there is no way to set an integer to 0.5 or 123.8. The variable type double should be used whenever fractions are needed. If a double can hold large numbers and fractions, why not just use it for everything? You certainly can but double type variables require more memory and processing. Fractions are not always desirable in the programming world as shown below. public class Program { double frequency; int increment; public void BrainPadSetup() { frequency = 0; increment = 0; } public void BrainPadLoop() { if (BrainPad.Buttons.IsUpPressed()) { increment = 100; } if (BrainPad.Buttons.IsDownPressed()) { increment = -100; } if (increment != 0) { frequency = frequency + increment; increment = 0; BrainPad.Buzzer.StartBuzzing((int)frequency); BrainPad.WriteToComputer(frequency); BrainPad.Wait.Seconds(0.2); BrainPad.Buzzer.StopBuzzing(); } } } The code above shows how a double isn't always the best variable type choice. Instead of simply passing an integer into StartBuzzing method we have to cast it as an integer first. This is done by placing (int) before the variable, which requires additional un-needed processing. Time to go back to our favorite green light! In the code below, we will turn the green light on and off for a specified amount of time, set by a variable called delay. The up and down buttons control the delay variable, causing the light to be on and off longer or shorter. The variable is also printed out using WriteToComputer() method with our delay variable as its argument. public class Program { double delay; public void BrainPadSetup() { delay = 0.20; } public void BrainPadLoop() { if (BrainPad.Buttons.IsUpPressed()) { delay = delay + 0.10; } if (BrainPad.Buttons.IsDownPressed()) { delay = delay - 0.10; if (delay < 0) delay = 0; } BrainPad.WriteToComputer(delay); BrainPad.LightBulb.TurnGreen(); BrainPad.Wait.Seconds(delay); BrainPad.LightBulb.TurnOff(); BrainPad.Wait.Seconds(delay); } } Returned Values Some methods return a value, like when reading the light sensor. This value can be placed into a variable and this variable can be used with if statements. We have lightbulb and light sensor on the BrainPad. Let's turn the light on when it's dark as shown in Example 15. public class Program { double level; public void BrainPadSetup() { level = 0; } public void BrainPadLoop() { level = BrainPad.LightSensor.ReadLightLevel(); BrainPad.WriteToComputer(level); if (level < 0.5) { BrainPad.LightBulb.TurnWhite(); } else { BrainPad.LightBulb.TurnOff(); } } } How can we determine what threshold to use to turn the lightbulb on? This is a perfect example of when inspecting variables is needed. Run the program and test it by placing a finger over the light sensor to block the light. You may need to adjust the threshold from 0.5 to something else. Take a look at the Output Window to see the light levels to determine what value works best for you. Strings A string is a type of variable that holds text as shown in the code example below. The text \"Hello World!\" is considered a string variable. String variables are always surrounded by quotation marks \"\" . BrainPad.WriteToComputer(\"Hello World!\"); It's important to remember that the value 2 and the string \"2\" are not the same thing. They may be the same to us but internally in the system they are very different. When x is an integer adding 2 + 2 means x equals 4, as you would expect. x = 2 + 2; Lets assume str is a string variable in the example below, what is the value of str? str = \"2\" + \"2\"; The plus sign symbol + means something different when dealing with strings. Using the plus sign + to connect strings is called concatenation . Which means a series of interconnected things. When concatenating strings in the example above, the result is \"22\". This will make more sense if you try the code below. str = \"Hello number \" + \"2\"; The result is \"Hello number 2\" . Note how even a space makes a difference with in the string. ToString() One of the important built-in methods for variables is the ToString() method. This method will take the value from count and convert it to a string as shown in the code below. public class Program { double count; public void BrainPadSetup() { count = 0; } public void BrainPadLoop() { count = count + 1; BrainPad.WriteToComputer(\"Count: \" + count.ToString()); } } The code above continiously increase the count variable and display it as a string. The variable count an integer that starts at zero and increments by one in every loop. The string \"Count: \" is concatenated before the value to give us these results. It then prints the variables value in the Output Window, as seen in the image below. Tip BrainPad.WriteToComputer() method is an excellent way to send messages to Visual Studio about things happening in your program while you're debugging. Messages here are only shown in Visual Studio's Output window and don't effect what's displayed on your BrainPad. C# is smart when it comes to concatenation. Try changing code count.ToString() to just count . Concatenating numbers and other objects with strings will automatically call the ToString() method as shown below. BrainPad.WriteToComputer(\"Count: \" + count); While loops A while loop statement in C# repeatedly executes the code within its curly braces {} as long as a given condition is true. The example below shows the structure of the while loop. while(as long as this condition is true){ This code is executed } You can make a while loop run forever by making it's condition always return true. As shown in the example below. 1 equals 1 is always true. public class Program { public void BrainPadSetup() { int count = 0; while (1 == 1) { count = count + 1; BrainPad.WriteToComputer(\"Count: \" + count); BrainPad.Wait.Seconds(0.2); } } public void BrainPadLoop() { //Put your program code here. It runs repeatedly after the BrainPad starts up. } } It should be noted clearly that we used == and not = in the while statement. The single = is used to set a value, not compare them. The code below sets count to the value of 10. int count = 10; While this code below compares count to the value of 10 to see if it's equal. if (count == 10) The Boolean type true can also be used as shown in the example below. public class Program { public void BrainPadSetup() { int count = 0; while (true) { count = count + 1; BrainPad.WriteToComputer(\"Count: \" + count); BrainPad.Wait.Seconds(0.2); } } public void BrainPadLoop() { //Put your program code here. It runs repeatedly after the BrainPad starts up. } } Finite while loops Both of the examples above create while loops that never end. So any code below the infinte while loop will never execute. Sometimes we might want to loop until a condition reaches a certain point or value. The code example demonstrates the use of a finite while loop, meaning it will stop looping at some point. public class Program { public void BrainPadSetup() { int count = 0; while (count < 10) { count = count + 1; BrainPad.WriteToComputer(\"Count: \" + count); BrainPad.Wait.Seconds(0.2); } } public void BrainPadLoop() { //Put your program code here. It runs repeatedly after the BrainPad starts up. } } The above code counts up to 10 before the while loop stops. However, the count started at zero, and not one. Why didn't it show the zero? If we look at the code above carefully you'll notice that the first line of code in our while loop increase the count variable by one. This happens before it is displayed to the Output window. So by the time we reach the line BrainPad.WriteToComputer(\"Count: \" + count); the count variable is already equal to 1 . To fix this we can move the line: count = count + 1 To the bottom of the while loop. This means the entire contents of the while loop will execute before the count variable is incremented by 1 There is another possible issue in our code. If we want it to count to 10. The program never prints the value 10 to the Output window. In plain English, our program says: run the following code as long as count is less than 10. Since 10 is not less than 10, then 10 will not be printed. The while loop can be easily modified so 10 is printed too. The code example below checks if count is less than or equal to 10. while (count <= 10) Nesting Any reasonably sized program will have loops inside loops, or if statements inside loops, maybe even inside other if statements and loops! This is called nesting. While programmers should try to keep this simple to understand, nesting is sometimes required. How do we write a program that prints one to 10 repeatedly forever? This is accomplished by having two nested while loops. One that counts one to 10, which goes inside another loop that loops indefinitely as shown in code example below. public class Program { public void BrainPadSetup() { int count = 0; while (true) { while (count <= 10) { BrainPad.WriteToComputer(\"Count: \" + count); count = count + 1; BrainPad.Wait.Seconds(0.2); } } } public void BrainPadLoop() { // Declared but not used } } The above program still will not work the way we want. It will print 1 to 10 only once. Then the program will continue to loop but will not print anything after count is greater then 10. Can you fix the code without looking at the solution below? public class Program { public void BrainPadSetup() { int count; while (true) { count = 0; while (count <= 10) { BrainPad.WriteToComputer(\"Count: \" + count); count = count + 1; BrainPad.Wait.Seconds(0.2); } } } public void BrainPadLoop() { // Declared but not used } } Instead of intializing the count variable to 0 at the beginning of our code, we do it inside while loop instead. This means after the nested while loop finishs counting to 10, the first while loop goes back to the top and resets our count variable to 0. Which is less than 10, starting our nested while loop to begin printing again."
  },
  "brainpad/courses/programming/vb/variables_and_nested_statements.html": {
    "href": "brainpad/courses/programming/vb/variables_and_nested_statements.html",
    "title": "Variables and Nested Statements",
    "keywords": "Variables and Nested Statements Overview Students will learn about variables, strings, while loops and nested statements. Guidelines Prerequisites: None Ages 12 and up PC setup with Visual Studio 2017, TinyCLR OS and Nuget packages installed. Supplies: BrainPad and Micro USB cable. Arguments Arguments are values passed on to methods. For example, to set the frequency of the buzzer, a value is passed on to that method. The 3000 is the arguments. BrainPad.Buzzer.Start(3000) Arguments are also used when adding delays. Here, the 0.2 is the argument. BrainPad.Wait.Seconds(0.2) Variables can be constants, like the numbers used above. They can also be variables, which will be explained in the coming sections. Also, arguments can also be something completely different! Class Program Public Sub BrainPadSetup() 'Declared but not used End Sub Public Sub BrainPadLoop() If BrainPad.Buttons.IsPressed(BrainPad.Buttons.Button.Up) Then BrainPad.WriteDebugMessage(\"Up button is pressed\") Else BrainPad.WriteDebugMessage(\"Up button is not pressed\") End If End Sub End Class What is that argument used with Button.IsPressed() ? In this case, the Button.IsPressed takes an argument to specify which button is to be checked. This code BrainPad.Buttons.IsPressed(BrainPad.Buttons.Button.Up) Is much clearer than: BrainPad.Button.IsPressed(4) What is button 4? In fact, internally the up button may be number 4 but remembering this will be difficult. Exercise Try to use the wrong argument type then build the project to observe the error messages. Integer Variables Variable is a location in memory that is reserved for us to use. Instead of knowing where the memory is and how it is located, the system gives us an access to that memory using a name we select. Dim count As Integer The above line instructs the system to reserve (Dim) a variable that is named count and the variable type is an Integer. The name can be use any letters from the alphabet and any numbers but it must not start with a number and it cant contain spaces. Here are few allowed name examples: Dim count123 As Integer Dim countMeIn As Integer Dim count2var As Integer Variables in small programs can use simply names. It can simply be just x . However, using a meaningful name is very important when writing any serious program, as there maybe tens, or hundreds, of variables. The variable now can store numbers. Note that the variable can be used in the equation and in the result as well. count = count + 2 The above code will add 2 to the count. Math can be used as well. count = 5 + result After selecting an appropriate name, an appropriate type is needed. The type tell the system how much memory to reserve for that one variable. The most widely used variable is an Integer, and can hold very large numbers, even negative numbers. We suggest the use for Integers for everything, except when fractions are needed. More on fractions later. Changing Tones Use the code below: Class Program Dim frequency As Integer Dim increment As Integer Public Sub BrainPadSetup() frequency = 0 increment = 0 End Sub Public Sub BrainPadLoop() If BrainPad.Button.IsUpPressed() Then increment = 100 End If If BrainPad.Button.IsDownPressed() Then increment = -100 End If If increment <> 0 Then frequency = frequency + increment increment = 0 BrainPad.Buzzer.Start(frequency) BrainPad.WriteDebugMessage(frequency.ToString()) BrainPad.Wait.Seconds(0.2) BrainPad.Buzzer.Stop() End If End Sub End Class The previous example loops 5 times every second and sets the buzzer to a frequency. The frequency is a variable, also named frequency in this example. The buttons will be checked and when the up button is pressed the frequency is incremented by 100 and when the down button is pressed the frequency is decremented by 100. The value held by the frequency variable is also printed using the Debug.Print statement. Can we now determine the highest frequency a person can hear? The if-statement with Variables The same way the if-statement was used to check if a button was pressed, it can be used with variables. If frequency is larger than 6000 then turn the red light off, else turn the red light off. Add this code inside the while-loop in the previous code example. If frequency > 6000 Then BrainPad.LightBulb.TurnRed() Else BrainPad. LightBulb.TurnOff() End If Exercise Add a variable that starts at 0 and then it is incremented by 1 in every loop. Once the variable reaches 1000, turn the LightBulb yellow. Print the variable value on the output window and make sure its incrementing, then verify the LightBulb turns yellow when the variable go over 1000. Inspecting Variables Printing the variable value worked well for small programs with a single variable. It is not practical to continuously print every variable out. Instead, we can use the debugger feature to pause the code and inspect variables. Class Program Dim count As Integer = 0 Dim increment As Integer = 0 Public Sub BrainPadSetup() End Sub Public Sub BrainPadLoop() count = count + 1 BrainPad.DebugPrint(count) BrainPad.Wait.Seconds(0.2) End Sub End Class Add a breakpoint in the loop in the previous program and step through code. Move the mouse over the count variable and wait a second. A pop up window will come up showing the value of the count variable. The watch windows can be used with important variables that need to be inspected regularly. Locate the watch window and type the variable name in the left sell. This will show the variable value and type. Exercise Run the previous program for few loops, then pause the program, or add a breakpoint. Inspect the value on the watch window. It should be something other than 0. Change the value manually to 0 and then re-run the program and observe how the output window now shows the variable going back counting from 0. Double Variable While an Integer can hold very large numbers, it cant hold fractions. For example, there is no way to set an integer to 0.5 or 123.8. The variable type Double should be used whenever fractions are needed. Why not use a Double variable since it can hold large numbers and fractions? You can, but it requires more memory and processing so it isn't as efficient. Class Program Dim frequency As Double Dim increment As Integer Public Sub BrainPadSetup() frequency = 0 increment = 0 End Sub Public Sub BrainPadLoop() If BrainPad.Button.IsUpPressed() Then increment = 100 End If If BrainPad.Button.IsDownPressed() Then increment = -100 End If If increment <> 0 Then frequency = frequency + increment increment = 0 BrainPad.Buzzer.Start(CType(frequency, Integer)) BrainPad.WriteMessageOnComputer(frequency) BrainPad.Wait.Seconds(0.2) BrainPad.Buzzer.Stop() End If End Sub End Class The previous example uses a Double instead of an Integer for the frequency. Since the Buzzer.Start() method expects an integer, the variable need to be converted using the CType(). This is demonstrating how using Double for everything is not desirable. Time to go back and have fun with our favorite green light! This example will turn the green light on for a specific time, set by a variable called delay. It then turns the light off for the same length of time. Pressing the up and down buttons control the delay variable, causing the light to be on and off for longer or shorter periods. The variable is also printed out using DebugOutput() . Class Program Dim delay As Double Public Sub BrainPadSetup() delay = 0.2 End Sub Public Sub BrainPadLoop() If BrainPad.Buttons.IsPressed(BrainPad.Buttons.Button.Up) Then delay = delay + 0.2 End If If BrainPad.Buttons.IsPressed(BrainPad.Buttons.Button.Down) Then delay = delay - 0.2 End If BrainPad.WriteDebugMessage(delay) BrainPad.LightBulb.TurnGreen() BrainPad.Wait.Seconds(delay) BrainPad.LightBulb.TurnOff() BrainPad.Wait.Seconds(delay) End Sub End Class Returned Values Some methods return a value, like when reading the light sensor. This value can be placed into a variable and then the variable can be used with if-statements. We have lights bulb and a light sensor on the BrainPad. Why not turn the light on when it is dark? This can be tested by turning the lights off inside the room or by placing a finger over the light sensor to block the light. Class Program Dim level As Double Public Sub BrainPadSetup() level = 0 End Sub Public Sub BrainPadLoop() level = BrainPad.LightSensor.ReadLightLevel() BrainPad.WriteDebugMessage(level) If level > 0.5 Then BrainPad.LightBulb.TurnOn() Else BrainPad.LightBulb.TurnOff() End If End Sub End Class How do we know what value to use as the threshold on when to turn the light bulb on? This is a perfect example on where inspecting variables is needed. Run the program and test by placing a finger over the light sensor to block the light. This may not work nicely and you need to adjust the threshold from 0.5 to something else. Take a look at the output window to see the light levels to determine what value work best for your needs. Then stop the program, change the threshold and then run the program again to test the results. Exercise Modify the last program to have a way to set the threshold using the up button. Hint, the threshold was a constant before but now it is going to be a variable that is set to whatever the light sensor returns when the button is pressed. Name the variable threshold and make sure it is type Double. Strings A string is a type of variable that holds text. BrainPad.WriteDebugMessage(\"Hello World!\") It is important to remember that the integer 2 and the string \"2\" are not the same thing. This maybe the same for us but internally in the system they are very different. Assuming x is an Integer, what value is in variable x? x = 2 + 2 The result is what you expect, 4. But now assume str is a string variable, what is the value of str? str = \"2\" + \"2\" The string is just text, not a number. When adding strings, the result is a string that combines the strings. The result from above is \"22\". This should make more sense if you try this example. str = \"Hello number \" + \"2\" The result is \"Hello number 2\". Note how even a space makes a difference in the last example. This code will generate an error since 2 is a number here not a string. str = \"Hello number \" + 2 ToString() One of the important built in method for variables is the ToString() method. This method will take the value from the variable and converts it into a string. Class Program Dim count As Integer=0 Public Sub BrainPadSetup() count = 0 End Sub Public Sub BrainPadLoop() count = count + 1 BrainPad.DebugOutput(\"Count: \" + count.ToString()) End Sub End Class The prior example uses a variable type integer that starts at zero and increments by one in every loop. It will then print the variable value in the Output Window. Exercise Show something like this in the output window: Finite while-loops The While loop and BrainPadLoop() have been used extensively so far. The While loop will run while something is true and since we have passed it the value True then it will loop forever. Is this statement true? 1 = 1 Yes 1 equals 1, that is true! So keeping that in mind, we can make a while-loop keep looping forever using this statement. Class Program Public Sub BrainPadSetup() Dim count As Integer count = 0 While 1 = 1 count = count + 1 BrainPad.WriteDebugMessage(\"Count: \" + count.ToString()) End While End Sub Public Sub BrainPadLoop() End Sub End Class Or True can simply be used. Class Program Public Sub BrainPadSetup() Dim count As Integer count = 0 While True count = count + 1 BrainPad.WriteDebugMessage(\"Count: \" + count.ToString()) End While End Sub Public Sub BrainPadLoop() End Sub End Class A While loop can also be finite, meaning will stop looping at some point. Class Program Public Sub BrainPadSetup() Dim count As Integer count = 0 While count < 10 count = count + 1 BrainPad.WriteDebugMessage(\"Count: \" + count.ToString()) End While End Sub Public Sub BrainPadLoop() End Sub End Class What did the last program do? It printed the count from 1 to 10. But count started at 0, not one. Shouldn't it print count 0? Time for debugging (troubleshooting). Start by setting a breakpoint at count = 0 and then step in the code to see what the value of count is (use watch window) and then see why the value 0 was never printed. Think about a fix before looking at the next code. The fix is very easy! Class Program Public Sub BrainPadSetup() Dim count As Integer count = 0 While count < 10 BrainPad.WriteDebugMessage(\"Count: \" + count.ToString()) count = count + 1 End While End Sub Public Sub BrainPadLoop() End Sub End Class What about the 10? Shouldn't the program print Count: 10? The answer is in the while-loop. In plain English, it says: run the following code as long as count is less than 10. Since 10 is not less than 10 then 10 will not be printed. The while-loop can be improved like this: While count <= 10 This new statement says run the loop as long as the count is less than or equals to 10. Exercise Write a program the prints all even numbers between 6 to 66. Nesting Some programs will have loops inside loops, or if-statements inside loops, maybe inside other if-statements and more loops! This is called nesting. While programmers should try to keep this simple to understand, nesting is sometimes required. How do we write a program that prints 1 to 10 repeatedly forever? This is accomplished by having two nested while-loops. One that counts 1 to 10, which goes inside another loop that loops infinitely. Class Program Public Sub BrainPadSetup() Dim count As Integer count = 1 While True While count < 10 BrainPad.WriteDebugMessage(\"Count: \" + count.ToString()) count = count + 1 End While End While End Sub Public Sub BrainPadLoop() End Sub End Class The above program will not work. It will print 1 to 10 one time only then the program will not end and it will not print anything after. Time again for debugging the code to determine what the issue is. Run the program and determine the cause of the error. The fix is simple but try to find it before peeking at the fixed code. Class Program Public Sub BrainPadSetup() Dim count As Integer count = 0 While True count = 1 While count < 10 BrainPad.WriteDebugMessage(\"Count: \" + count.ToString()) count = count + 1 End While End While End Sub Public Sub BrainPadLoop() End Sub End Class Exercise Write a program that prints 0 to 10 repeatedly when the up button is not pressed when it is bright. If it is dark the button doesn't do anything. Do not use And , instead nest the if-statements."
  },
  "hardware/legacy_products/imaging.html": {
    "href": "hardware/legacy_products/imaging.html",
    "title": "Imaging",
    "keywords": "Imaging ALCAM-OEM is a small yet powerful imaging hardware. It could capture stills and videos to SD card and able to fetch images using serial commands. It started in a successful Kickstarter campaign Resources: get them here We have worked on similar custom commercial designs with imaging needs but decided to proceed with a one-size-fits-all. Please contact us to discuss your imaging needs."
  },
  "hardware/legacy_products/gadgeteer/fez_cerberus.html": {
    "href": "hardware/legacy_products/gadgeteer/fez_cerberus.html",
    "title": "FEZ Cerberus",
    "keywords": "FEZ Cerberus FEZ Cerberus is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Cerberus is the G30 System on Chip (SoC). FEZ Cerberus is the mother of the Cerb Family . Resources Schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. The Boot Pins PB10 is the MODE pin, which is used to select between USB and serial interfaces, for loader and for firmware. USART1 is used when in serial mode, that is PB6 and PB7. LDR0 and LDR1 are PC1 and PC3 respectively. Setting LDR0 low on power up puts the device into bootloader mode. Setting LDR1 low will execute the firmware but will stop the application from running. Using TinyCLR OS If haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading Bootloader v2 Download the bootloader file Press and hold BOOT button down while resetting the board. If there is no BOOT button, there will be shunt-footprint labeled BOOT or LDR. Short the 2 pads with a wire while resetting the board. The system will now detect an ST DFU device. Read more on uploading DFU files on STM32 microcontrollers. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, set PC1 pin low. Download the Cerb firmware and follow Loading the Firmware steps. The Cerb Family The FEZ Cerberus come in different form factor, together called the Cerb family. The entire family run the same software. FEZ Cerberus The mother of the family! FEZ Cerbuino Bee An Arduino-pinout compatible for accepting shields and also has some Gadgeteer socket option. Schematic FEZ Cerbuino Net An Arduino-pinout compatible for accepting shields and also has some Gadgeteer socket option. Schematic FEZ Cerb40 DIP40 formfactor board. Not really a Gadgeteer board but it is very small! Schematic FEZ Cerb40 II Same as the FEZ Cerb40 with an added regulator chip Schematic FEZ Cerbot A robot with reflective sensors and tons of LEDs. Gadgeteer sockets are used as an easy way to add features. Schematic FEZ Game-O A programmable console combined with a 320 x 240 color display, 3D accelerometer and audio circuitry. Schematic"
  },
  "hardware/legacy_products/netmf/canxtra.html": {
    "href": "hardware/legacy_products/netmf/canxtra.html",
    "title": "CANxtra",
    "keywords": "CANxtra CANxtra is a hand-held programmable OBD-II tool that includes CAN, LIN and other vehicle buses. Resources below are provided for reference only. Please contact us for all of custom automotive needs. Resources Brochure Schematic"
  },
  "hardware/legacy_products/netmf/usbizi.html": {
    "href": "hardware/legacy_products/netmf/usbizi.html",
    "title": "USBizi",
    "keywords": "USBizi USBizi was the first single chip .NET Micro Framework (NETMF) on the market. It was available in 100pin and 144pin LQFP packages. We are no longer making the chip available but we are making all bootloader binaries (move to new server) available for free, including for commercial use. Resources User Manual build them and do a quick test to make sure V, N, and X/U workManual.pdf Using the NETMF software We discourage the use of NETMF software on our products in favor for TinyCLR OS, Read more . Using TinyCLR OS If haven't yet, read about using .NET NETMF devices with TinyCLR OS Loading Bootloader v2 Tip The instructions apply to all USBizi-based boards but we are using the FEZ Panda II as reference. We first need to erase the old bootloader v1: Connect UART0 TX/RX to your PC. The easiest way would be to use a USB-Serial TTL cable. Those are D0 and D1 on FEZ Panda II. Do not forget to connect the ground. Put the device in serial mode by connecting MOD pin to ground. Open a terminal software and set the baudrate to 115200. Press the enter key and you should see BL coming back. Enter this exact line Unlock This device! (case sensitive). Ignore the BL keeps coming back with every key press. If you entered it correctly, you will see Are you sure? Enter Yes (case sensitive). You now have a blank LPC chip! You can now close the terminal software, release MOD pin, and reset your board. The new bootloader v2 can now be loaded. Download and install Flash Magic . Open Flash Magic and select LPC2378. Check \"Erase all Flash\". Set the correct COM port number of your serial connection. Click the Start button. When done, reset the board and the PC will detect a virtual USB device. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, set LDR pin low. On FEZ Panda II it is a button marked LDR. Simply press it. Once the LDR pin is set low, keep it low while resetting the board. Download the USBizi firmware and follow Loading the Firmware steps. USBizi Based products USBizi DevSys The original development board for USBizi. Schematic FEZ Panda An Arduino-poinout compatible board. Schematic FEZ Panda II An Arduino-poinout compatible board. Schematic FEZ Rhino Schematic FEZ Domino Schematic FEZ Mini Schematic"
  },
  "hardware/loaders/intro.html": {
    "href": "hardware/loaders/intro.html",
    "title": "Loaders Introduction",
    "keywords": "Loaders Introduction A loader is a small software that boots up the system and runs the firmware. It is also used to update the firmware. This section covers different loader features and usage details."
  },
  "hardware/loaders/mikro_bootloader.html": {
    "href": "hardware/loaders/mikro_bootloader.html",
    "title": "Mikro Bootloader",
    "keywords": "Mikro Bootloader MikroElektronika's bootloader is found on several products offered by them. Some of the TinyCLR OS supported boards are made by MikroElectronika and include this loader by default. This page covers it in full details https://learn.mikroe.com/bootloaders/"
  },
  "hardware/products/scm/g120.html": {
    "href": "hardware/products/scm/g120.html",
    "title": "G120",
    "keywords": "G120 G120 and G120E are .NET Micro Framework (NETMF) System on Modules. Datasheet Using the NETMF software We discourage the use of NETMF software on our products in favor for TinyCLR OS. Read more about the use of NETMF and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using NETMF devices with TinyCLR OS Loading Bootloader v2 Download the bootloader file Set the LDR0 and LDR1 signals low while resetting the board. The PC will now detect a virtual serial (COM) device. If you need drivers, they are in the NETMF SDK. Open any terminal software, we recommend Tera Term . Select serial and pick the COM port associated with your board. Enter E and you will see back \"Erase all memory! Are you sure?\" now enter Y . (The bootloader is case sensitive) Enter X and you will see CCCC ... showing on the terminal. Now go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the bootloader file you have downloaded above. You will see File Transfer Finished Successfully . Reset your board, you are now running GHI Electronics bootloader version 2! Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, hold the LDR0 signal low while resetting the board. Download the G120 firmware and follow Loading the Firmware steps. G120 Based products G120 Development Board The development system used for evaluating the EMX SoM. Schematic G120 TH Module A though-hole version of G120. Schematic FEZ Cobra III An Arduino-pinout compatible single board computer. Schematic FEZ Cobra II A single board computer. Schematic"
  },
  "hardware/products/scm/g30.html": {
    "href": "hardware/products/scm/g30.html",
    "title": "G30",
    "keywords": "G30 The G30 System on Chip (SoC) is a low-cost chipsets running the .NET Micro Framework. It is programmed using Microsoft's Visual Studio using C# or Visual Basic which allows developers to take advantage of the extensive built-in NETMF libraries and GHI Electronics added extensions. To use G30 SoC, follow the setup instructions on the NETMF intro page Datasheet Using the NETMF software We discourage the use of NETMF software on our products in favor for TinyCLR OS. Read more about the use of NETMF and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using NETMF devices with TinyCLR OS Loading Bootloader v2 The G30 SoC ships with the Bootloader loaded and locked. No further steps are necessary. Loading the Firmware To activate bootloader v2, LDR0 signal needs to be low while resetting the board. Download the G30 firmware and follow Loading the Firmware steps. G30 Based products G30 Development Board The development system used for evaluating the EMX SoM. Schematic G30 TH Module A though-hole version of G30. Schematic FEZ Lemur A Arduino-pinout compatible single board computer. Schematic"
  },
  "tinyclr/downloads.html": {
    "href": "tinyclr/downloads.html",
    "title": "Downloads",
    "keywords": "Downloads This page includes different download types for individual boards. See individual product pages for details on what to download. Software status legend: Status Meaning Production Ready to be used commercially. RC Release Candidate, stable and can be field tested. Beta No more major changes, use for development. Alpha Use for trying things out and providing feedback. Major changes to come. Visual Studio Project System The extension is what gets loaded on Visual Studio to allow it to communicate with a TinyCLR OS device. It also includes project templates. File Date Status MD5 v0.6.0 2017-08-31 Alpha 68E94D0720CCDAC1A3E9BDEF7704FAAA v0.5.0 2017-07-07 Alpha 58542CEB7DAF6445AD10083ABA73D834 v0.4.0 2017-05-10 Alpha 4D463EA5991EA7698110B79EF4DB6B8B v0.3.0 2017-04-06 Alpha 6094565340EDF8F5445106C2A9B1441C v0.2.0 2017-03-07 Alpha A9CB8E88011AFF28AD88656E86C73A31 v0.1.0 2016-12-16 Alpha D93A8FF13900362FB4528F8036D46612 Libraries Libraries are hosted though a local NuGet feed for now as we are a lot of changes still. These libraries will be hosted on http://www.nuget.org/ in the future. File Date Status MD5 v0.6.0 2017-08-31 Alpha CA9275032B3A2EA403738497C2C0C280 v0.5.0 2017-07-07 Alpha C1768FF218AB1790BD902E52561C0CE5 v0.4.0 2017-05-10 Alpha 1A8B0E28431927FA4716B44B774FDF90 v0.3.0 2017-04-06 Alpha 21D3E9AD37285B231B1E6E605B7CA709 v0.2.0 2017-03-07 Alpha 7CDE2D7ADDD3E490344B1DA8DB342F8D v0.1.0 2016-12-16 Alpha 9E843638A8A4793814D76B522F8CBF1A TinyCLR Config TinyCLR Config is a tool used to update and configure your TinyCLR device. File Date Status MD5 v0.6.0 2017-08-31 Alpha 75743E33D1B98E6999BDCC9936479C14 Firmwares The Firmware is the TinyCLR OS that lives on your hardware. The firmware version loaded on the hardware must match the version number of the extension and the libraries. This will be easier managed once the libraries are hosted on http://www.nuget.org/ FEZCLR This is the reference firmware for TinyCLR OS and it runs on the FEZ and the BrainPad . File Date Status MD5 v0.6.0 2017-08-31 Alpha 3D66C9FF460591AA2DD4B002DE6D9B9A v0.5.0 2017-07-07 Alpha 93094FF58D78DEB36D22FD9450737362 G30 File Date Status MD5 v0.6.0 2017-08-31 Alpha 6AF63423B229CF5A30B6B7E83D877FF9 v0.5.0 2017-07-07 Alpha 4A8479E0D431868ED047CB7C482511CE v0.4.0 2017-05-10 Alpha FCBACDAB7C02E1A855375BF776EEE2FB v0.3.0 2017-04-06 Alpha 59A994B1F4F60FB3AE6CD8F91AB01650 v0.2.0 2017-03-07 Alpha 6E5BB699634D78DD64FFFB69D547A58F v0.1.0 2016-12-16 Alpha 6347B73E93FF9BF7D52ECE142D9F2ECB G80 File Date Status MD5 v0.6.0 2017-08-31 Alpha 61759AB6015BD2B2FE1D9D5B4209BC6A v0.5.0 2017-07-07 Alpha E9256BDB4A0FA61A30BF9B5294354618 v0.4.0 2017-05-10 Alpha E6EB8C753C4CE9A6197EC06F3C4CB848 v0.3.0 2017-04-06 Alpha EDB489B34BC8E249D47160EA3AFE466C v0.2.0 2017-03-07 Alpha 4EAA86216B6FFCDE937D1CCFD9558356 v0.1.0 2016-12-16 Alpha 5C93CCA961904F25BB56A9B9AD7C501A G120 File Date Status MD5 v0.6.0 2017-08-31 Alpha 9418A57C0B5F655F3FD35CBED0CEC16F v0.4.0 2017-05-10 Alpha 1C09A3C7D5305B03F0FF51884ACBD2F2 v0.3.0 2017-04-06 Alpha 57836246074A8E729EE3D6C6BCF76F55 v0.2.0 2017-03-07 Alpha 66EAA71A4A7D1B96AC9CD7C892DAA3CE G400 File Date Status MD5 v0.6.0 2017-09-13 Alpha 81F063028D379699ECE969F45757C801 v0.4.0 2017-05-10 Alpha 03859F270F8B16CE4D40245918065E88 v0.3.0 2017-04-06 Alpha 8AA7E83ED7A62A94F0833569A6A12FEE EMX File Date Status MD5 v0.6.0 2017-08-31 Alpha EA9C0E782CB3AA34EE4852E7538F6138 Embedded Master File Date Status MD5 v0.6.0 2017-08-31 Alpha AD4E022B7F493B60BEEA3EBE685AB525 USBizi File Date Status MD5 v0.6.0 2017-08-31 Alpha 20748AD886D5C20C8EF7B93AD8C522E9 Cerb File Date Status MD5 v0.6.0 2017-08-31 Alpha 92BB5C076086AB581A1C64B40248297D v0.5.0 2017-07-07 Alpha 4F8C039EC6D0206D7FC97083E8765EC7 netduino 3 File Date Status MD5 v0.6.0 2017-08-31 Alpha 5FBCCADDDCF1663E64FA2DDE3A16B745 v0.5.0 2017-07-07 Alpha F6C51E2E7286262D4652D40CAAB1731A Quail File Date Status MD5 v0.6.0 2017-08-31 Alpha F6E6C9D6C05084AB87B79ECA76D867BC v0.5.0 2017-07-07 Alpha 714AD4715964A7B6CA3A23C67370A5EA clicker File Date Status MD5 v0.6.0 2017-08-31 Alpha 6A28632B898EEF7DF56A73D1034FED97 clicker 2 File Date Status MD5 v0.6.0 2017-08-31 Alpha EAC2085E921759ED81E60973C00A0DF5"
  },
  "tinyclr/internetofthings.html": {
    "href": "tinyclr/internetofthings.html",
    "title": "Internet of Things",
    "keywords": "Internet of Things A modern system is not complete without support for the Internet and the cloud. TinyCLR OS includes everything you need to be online. (details coming soon)"
  },
  "tinyclr/tinyclr_config.html": {
    "href": "tinyclr/tinyclr_config.html",
    "title": "TinyCLR Config",
    "keywords": "TinyCLR Config TinyCLR Config is a stand-alone tool to help managing TinyCLR OS devices. The tool is cloud-connected. It automatically finds and downloads newer firmware versions from a list of provided sources. These sources can be on the internet or local on your machine if you don't have or don't want to access to the internet. The firmware update functionality only works for devices that have GHI Bootloader v2 . The TinyCLR Config tool is stil in development. Please stay tuned . Firmware Sources When TinyCLR Config starts up, it looks for a file called FirmwareSources.txt in the same directory as the TinyCLR Config executable itself. If the file isn't present, it's created automatically with one entry pointing to the official GHI firmware store. The file is a comma-separated list of sources, one per line. The first value is an integer priority with lower numbers being searched first. Each source is tried until a newer version than the currently flashed version is found. The next value is either Local or Network which determines where the next value points to: the local disk or the network. The last value is a URI that points to an xml file that defines the list of available firmwares. The firmware xml list is made up of a list of devices. Each device has a name attribute and firmware list child. Within the firmware list is a list of each available firmware. Each firmware must have an MD5 hash that matches the file pointed to, a version of the form major.minor.patch , a release date, and a uri that points to the location of the firmware (the location type must match the location type of the firmware list itself, i.e. local vs network). See the official hosted file for a complete example."
  },
  "tinyclr/porting/native_interops.html": {
    "href": "tinyclr/porting/native_interops.html",
    "title": "Native Interops in TinyCLR",
    "keywords": "Native Interops in TinyCLR Interops allow you to write a class in managed code that is partially or entirely implemented in native code. This is useful for time critical tasks, things that would take too long in managed code, or interacting with native functionality not exposed through managed code. Keep in mind that while native code executes, all managed threads are blocked and if you crash in native code, managed code also crashes. To get started, create a TinyCLR project called InteropTest . In the project properties window, go to the TinyCLR OS tab. Check both the Generate native stubs for internal methods and the Generate bare native stubs checkboxes. Next, define your native API. Any method that you plan to implement in native code must be declared extern and be decorated with the System.Runtime.CompilerServices.MethodImpl attribute that is constructed with MethodImplOptions.InternalCall . Static and instance functions, static and instance constructors, finalizers, and property set and get bodies can all be implemented native. They can have any visibility, can take any number or types of parameters, and can return any type. For example: class MyNativeClass { private int field = 5; [MethodImpl(MethodImplOptions.InternalCall)] public extern string MyNativeFunc(uint param1); public extern int MyNativeProperty { [MethodImpl(MethodImplOptions.InternalCall)] get; } } Once you have your native API defined, build your project. In the output folder, find and open pe and then Interop . In there are three files that let TinyCLR connect the managed methods to the native methods. There are two main files that have the same name as your project. These define the entire API. Importantly, there is an object that has the assembly name, its checksum, and an array of its methods. The remaining file contains function stubs for each native method you need to implement from the MyNativeClass class. Each function has a single parameter of type TinyCLR_Interop_MethodData that can be found in the TinyCLR.h file. This type has two memebers: an opaque stack type that you pass to other interop functions and the API provider that gives you access to the runtime. You can use this API provider to find the interop provider. The interop provider allows you to read and write object fields, read arguments passed to the function, write to reference arguments, set the return value, raise other events, and create new managed objects. The following code shows reading from a field and setting it as the return value of the property: TinyCLR_Result InteropTest_InteropTest_MyNativeClass::MyNativeProperty___I4(const TinyCLR_Interop_MethodData md) { auto ip = (const TinyCLR_Interop_Provider*)md.ApiProvider.FindDefault(&md.ApiProvider, TinyCLR_Api_Type::InteropProvider); TinyCLR_Interop_ManagedValue self; TinyCLR_Interop_ManagedValue ret; TinyCLR_Interop_ManagedValue field; ret.Type = TinyCLR_Interop_ManagedValueType::I4; ip->GetThisObject(ip, md.Stack, self); ip->GetField(ip, self, InteropTest_InteropTest_MyNativeClass::FIELD___field___I4, field); ip->GetReturn(ip, md.Stack, ret); ret.Data.Numeric->I4 = field.Data.Numeric->I4; return TinyCLR_Result::Success; } Now you need tp compile these files. If you don't have GCC yet, see the porting guide to find out how to install GCC. To compile using GCC, the easiest way is to use a makefile and a scatterfile. We've provided samples of each below. The makefile is setup to compile all cpp in the same directory it is and to do using for a Cortex M4 architecture. If you're not on CortexM4, change the MCU_FLAGS parameter accordingly. The output file is InteropTest.bin . You can change that with the OUTPUT_NAME property. OUTPUT_NAME = InteropTest LINKERSCRIPT_NAME = scatterfile MCU_FLAGS = -mcpu=cortex-m4 -mthumb INC_DIRS = -I. CC = arm-none-eabi-g++.exe LD = arm-none-eabi-g++.exe OC = arm-none-eabi-objcopy.exe CC_FLAGS = $(INC_DIRS) $(MCU_FLAGS) -Os -std=c++11 -xc++ -Wall -Wabi -w -mabi=aapcs -fPIC -fno-exceptions -fno-rtti -fno-use-cxa-atexit -fno-threadsafe-statics LD_FLAGS = $(MCU_FLAGS) -nostartfiles -lc -lgcc -T $(LINKERSCRIPT_NAME) -Wl,-Map,$(OUTPUT_NAME).map -Wl,--oformat -Wl,elf32-littlearm OC_FLAGS = -S -O binary SRC_FILES = $(wildcard *.cpp) OBJ_FILES = $(patsubst %.cpp, %.obj, $(SRC_FILES)) rebuild: clean build clean: del $(OBJ_FILES) $(OUTPUT_NAME).bin $(OUTPUT_NAME).elf $(OUTPUT_NAME).map build: $(OBJ_FILES) $(LD) $(LD_FLAGS) -o $(OUTPUT_NAME).elf $^ $(OC) $(OC_FLAGS) $(OUTPUT_NAME).elf $(OUTPUT_NAME).bin %.obj: %.cpp $(CC) -c $(CC_FLAGS) -o $@ $^ Because TinyCLR can't currently dynamically relocate your code, you'll need to provide the proper base and length values for the RLI region in the scatterfile by changing the RLI_BASE and RLI_LENGTH placeholders. You can find the RLI region for your device, if it has one, in the device's specifications. MEMORY { SDRAM (wx) : ORIGIN = RLI_BASE, LENGTH = RLI_LENGTH } SECTIONS { . = ALIGN(4); .text : { *(.text) } .rodata ALIGN(4): { *(.rodata ) } .data ALIGN(4): { *(.data) } .bss ALIGN(4): { *(.bss) } } Lastly, make sure that you place TinyCLR.h in the folder so that the interop files can see it. You need to use the file that corresponds to the release of the firmware you are running. To execute the makefile, you'll need to have make installed. You can get it from a toolkit like MinGW or, if you're on Windows 10, the Windows Subsystem for Linux. Once you have make installed, just navigate to the folder with the makefile and interop files in a shell and execute make build . Tip If you use the Windows Subsystem for Linux, you'll need to change del in the makefile to rm . Once you have a compiled image, look in the map file to find out where the interop definition variable Interop_InteropTest (if you're using the default names) got placed. You'll need to pass this address to the managed function that registers the interop. In managed code, add the compiled binary image as a resource and use the Marshal class to copy it into the correct location in memory. Then call System.Runtime.InteropServices.Interop.Add and pass it the address of the Interop_InteropTest object from the map file. You need to do this every time your program runs and before you call any of the native methods in your interop class. var interop = Resources.GetBytes(Resources.BinaryResources.InteropTest); Marshal.Copy(interop, 0, new IntPtr(0x20016000), interop.Length); Interop.Add(new IntPtr(0x2001607C)); var cls = new MyNativeClass(); var val = cls.MyNativeProperty;"
  },
  "tinyclr/tutorials/adc.html": {
    "href": "tinyclr/tutorials/adc.html",
    "title": "ADC",
    "keywords": "ADC Unlike digital input pins, which can only read high or low; analog pins can read a range of voltage levels. Microcontrollers based on 3.3V can typically read voltages anywhere between zero and 3.3V. Analog inputs connect internally to a Analog to Digital Converter (ADC) that converts the analog voltage level on the pin to a digital value. The resolution of the ADC determines its accuracy. An 8bit ADC has 256 steps to work with, 3.3V/256=0.013V. This means an increase of 0.013V will increase the value by one. In other words, a voltage change of less than 0.013V has no effect. The ADC on FEZ is 12bit and should fit most needs. Tip Note that the analog channel number is not the pin number. We have these easily enumerated for FEZ but you need to determine the channel number on a specific pin using your system's documentation. This example will read the ratio, that is 0 to 1, of an analog input. After running the program, connect a wire from the analog pin to ground and you should see a zero or something really close to zero. Connect to 3.3V and you will see 1 or something close, like 0.99. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { AdcController ADC = AdcController.GetDefault(); AdcChannel analog = ADC.OpenChannel(FEZ.AdcChannel.A0); while(true) { double d = analog.ReadRatio(); Debug.WriteLine(\"An-> \" + d.ToString(\"N2\")); Thread.Sleep(100); } } }"
  },
  "brainpad/courses/electronics/intro.html": {
    "href": "brainpad/courses/electronics/intro.html",
    "title": "Intro",
    "keywords": "Intro Electronics is in everything around us. What is surprising is that, in this modern age, we have more electronic devices but there is a lot less fixing of these electronic devices, when compared to the previous generations. Can we educate the next generation to understand electronics better? The BrainPad, without any additions, is enough to explain all the basics. Then it can also be used to explain digital electronics and processing. Further going into explain data transfers in digital system. This is all before even adding a single wire, but then the possibilities are endless with what sensors and circuits can be wired to the BrainPad. These are the outdated courses that are getting updated soon. Please bear with us. https://old.ghielectronics.com/downloads/BrainPad/BrainPad_EL_Introduction.pdf https://old.ghielectronics.com/downloads/BrainPad/BrainPad_EL_AnalogInputs.pdf https://old.ghielectronics.com/downloads/BrainPad/BrainPad_EL_PulseWidthModulation.pdf"
  },
  "README.html": {
    "href": "README.html",
    "title": "Docs",
    "keywords": "Docs This is the repository for all of our docs. To generate the docs locally: Clone/Fork the repo Open the command prompt in the documents' root folder (\"Run as Administrator\" may be necessary) Execute docfx --serve"
  },
  "brainpad/courses/programming/csharp/threading_and_events.html": {
    "href": "brainpad/courses/programming/csharp/threading_and_events.html",
    "title": "Threading and Events",
    "keywords": "Threading and Events Methods The BrainPad object (or class) includes methods to control many aspects of the BrainPad's hardware. A method is a set of instructions grouped together. If a student is asked to speak, the command may look like Student.Say(\"Hello\") . The Say() method is simple, but speaking requires many things like taking in air and moving your vocal cords. In the same sense, activating the LightBulb and Turning it green is a simple request but internally it does many small tasks to reach the final goal. Methods can also take arguments. For example, you could have a method called Student.Run() to order a student to run or Student.Run(slow) to order them to run slow. Methods can also return a value, like Student.GetAge() which returns the student's age. In the code example below, we show how a method called Add can be add 5 + 2 and print the total integer to the Output window. We've also added an additional line to display the result on the BrainPad's own display too. public class Program { public void BrainPadSetup() { int total = Add(5, 2); BrainPad.WriteToComputer(total); BrainPad.Display.DrawNumberAndShowOnScreen(1, 1, total); } public void BrainPadLoop() { // Declared but not used } public int Add(int a, int b) { return a + b; } } The above example creates a simple method that takes two integer arguments and returns an integer. The method will add the two arguments and return the results. Method names are like variable names, only certain things are allowed. Method names cannot start with a number, contain a symbol besides the underscore _ or have a space in them. The following examples show proper and improper use of method names. Valid Method Names bool AreAll4ButtonsPressed() string Add(int a, int b) Poorly named Methods bool areallbuttonspressed() int method34from94handler() Note: Method names should always be easy to read and meaningful. This allows a programmer to easily discern what it does. Invalid Method Names bool Are All Buttons Pressed() bool AreAllButtonsPressed?() Methods are not required to return anything. To fill that case of not returning a value the keyword void is used. void ActivateAlarm() Finally, methods can also be private or public and static or non-static. This is beyond the scope of this course and public static will always be used. Overloading Methods The same method name can have one or more argument types. Depending on the argument passed to the method, the system will determine which method to call as shown in in the code sample below we create a method called Test which can handle both an integer or a double. public class Program { public void BrainPadSetup() { Test(5); Test(5.0); } public void BrainPadLoop() { // Declared but not used } public void Test(int x) { BrainPad.WriteToComputer(\"integer\"); BrainPad.Display.DrawSmallText(1,1,\"integer\"); BrainPad.Display.ShowOnScreen(); } public void Test(double x) { BrainPad.WriteToComputer(\"double\"); BrainPad.Display.DrawSmallText(1, 20, \"double\"); BrainPad.Display.ShowOnScreen(); } } In the code above, you'll notice in the BrainPadSetup() we use the Test() method twice, once with a integer (5) and then with a double (5.0) . When the Test() method is called the computer determines what the data type is and routes to the appropriate method. This is what is meant by overloading a method. Boolean Variables In programming we use true or false to represent the truth values of logic. These values are known as Boolean or bool when coding. For example, let's say we need to check if the up and down buttons are pressed in multiple spots throughout our program. We could check each button in each spot or we could create a reusable method that returns true if both are pressed or false otherwise, as shown in the code examples below. public class Program { public void BrainPadSetup() { // Declared but not used } public void BrainPadLoop() { if (UpAndDownPressed()) { BrainPad.LightBulb.TurnGreen(); } else { rainPad.LightBulb.TurnOff(); } } public bool UpAndDownPressed() { if (BrainPad.Buttons.IsUpPressed() && BrainPad.Buttons.IsDownPressed()) { return true; } else { return false; } } } The new Keyword In the examples used so far, the BrainPad object has been used directly. This will not work for all object types. Remember the Student.Say(\"Hello\") example? This statement is not completely valid because we don't know which student is going to say Hello. To access a specific student, you need to create a variable named mike to hold the Student object as shown in the code sample below. Student mike = new Student(); Threading Threading in the programming world is a way to describe multitasking. Each task is a thread that runs separately. The threading support in TinyCLR OS on the BrainPad is easy to work with. First, we need to inform the system that the threading library needs to be imported. We do this by adding the code below to the very top of our program, where other libraries are also imported. Like the using GHIElectronics.TinyCLR.BrainPad; library, that allows us to program using the BrainPad object. using System.Threading; Before adding a thread, we need a method for it to use as shown in the code below. public class Program { public void BrainPadSetup() { Thread blinkerThread = new Thread(Blinker); blinkerThread.Start(); while (true) { BrainPad.LightBulb.TurnRed(); BrainPad.Wait.Seconds(0.1); BrainPad.LightBulb.TurnOff(); BrainPad.Wait.Seconds(1); } } public void BrainPadLoop() { // Declared but not used } public void Blinker() { while (true) { BrainPad.LightBulb.TurnGreen(); BrainPad.Wait.Seconds(0.2); BrainPad.LightBulb.TurnOff(); BrainPad.Wait.Seconds(0.2); } } } The previous program will blink the light green Stepping through code, we can easily see how the Blinker method never returns execution to BrainPadSetup(). The program keeps looping infinitely inside the Blinker method. But most programs would probably need to blink the light while doing something else. This is where threads come in very handy. First, we need to construct a Thread object as shown below. This object has special internal control over the program flow. Thread blinkerThread = new Thread(Blinker); Note how the names easily identify what they represent. The blinkerThread() method is a thread that handles the Blinker() method. All we need to do is Start() the thread and the Blinker() method will be executed. However, there is still an issue. The BrainPadSetup() method will reach the end, which will cause the program and all its threads to terminate. A temporary solution is to make the BrainPadSetup() method wait indefinitely is by using -1 milliseconds as shown in the code example below. public class Program { public void BrainPadSetup() { Thread blinkerThread = new Thread(Blinker); blinkerThread.Start(); BrainPad.Wait.Milliseconds(-1); } public void BrainPadLoop() { // Declared but not used } public void Blinker() { while (true) { BrainPad.LightBulb.TurnGreen(); BrainPad.Wait.Seconds(0.2); BrainPad.LightBulb.TurnOff(); BrainPad.Wait.Seconds(0.2); } } } In code example below, while the red light is blinking in its own thread, the system can now go do other things like incrementing our count variable and showing the results on the display. public class Program { int count = 0; public void BrainPadSetup() { Thread blinkerThread = new Thread(Blinker); blinkerThread.Start(); while (true) { BrainPad.LightBulb.TurnRed(); BrainPad.Wait.Seconds(0.1); BrainPad.LightBulb.TurnOff(); BrainPad.Wait.Seconds(1); } } public void BrainPadLoop() { // Declared but not used } public void Blinker() { while (true) { count = count + 1; BrainPad.Display.DrawTextAndShowOnScreen(40,25,\" \"+ count); } } } Events If a program needs to turn a light on via a button press, that program will need to check the button's state indefinitely. How often should we check the button? What if the button was pressed and released before the check? If we check too fast the system cannot enter low power mode. This is important for battery operated devices like circuit boards or mobile phones. If the phone was always fully on, the battery would not last more than a few minutes. The only way a mobile phone can last an entire day on a charged battery is by shutting off unneeded components (like turning the screen off). The proper way to handle the button is to subscribe to an event that is fired when the button is pressed or released. The BrainPad's BrainPad.Buttons.WhenUpButtonPressed event allows us to subscribe using the += symbols. Now every time the Up button is pressed the Buttons_WhenUpButtonPressed() method is called. In the example below we've created event handlers for all the buttons on the BrainPad. There is a handler to also check when the button is released as shown in the code below. public class Program { public void BrainPadSetup() { BrainPad.Buttons.WhenUpButtonPressed += Buttons_WhenUpButtonPressed; BrainPad.Buttons.WhenDownButtonPressed += Buttons_WhenDownButtonPressed; BrainPad.Buttons.WhenRightButtonPressed += Buttons_WhenRightButtonPressed; BrainPad.Buttons.WhenLeftButtonPressed += Buttons_WhenLeftButtonPressed; BrainPad.Buttons.WhenUpButtonReleased += Buttons_WhenUpButtonReleased; BrainPad.Buttons.WhenDownButtonReleased += Buttons_WhenDownButtonReleased; BrainPad.Buttons.WhenRightButtonReleased += Buttons_WhenRightButtonReleased; BrainPad.Buttons.WhenLeftButtonReleased += Buttons_WhenLeftButtonReleased; } private void Buttons_WhenUpButtonPressed() { BrainPad.LightBulb.TurnRed(); } private void Buttons_WhenDownButtonPressed() { BrainPad.LightBulb.TurnGreen(); } private void Buttons_WhenRightButtonPressed() { BrainPad.LightBulb.TurnBlue(); } private void Buttons_WhenLeftButtonPressed() { BrainPad.LightBulb.TurnWhite(); } private void Buttons_WhenUpButtonReleased() { BrainPad.LightBulb.TurnOff(); } private void Buttons_WhenDownButtonReleased() { BrainPad.LightBulb.TurnOff(); } private void Buttons_WhenRightButtonReleased() { BrainPad.LightBulb.TurnOff(); } private void Buttons_WhenLeftButtonReleased() { BrainPad.LightBulb.TurnOff(); } public void BrainPadLoop() { } } When typing, after you enter the += symbols, Visual Studio will instruct you to press TAB to insert a pre-named event handler. After doing so, you'll want to press TAB again to generate the actual handler inside the class. Activating a light on a button press can be done in a loop but then the system is always running. Using events in this example, the system is mostly sleeping (in low power mode). The first thing it does is subscribe to the button event. The system sleeps until one of the buttons is pressed or released, at which point it wakes up and runs the appropriate Button method. But the code above can be simplified a bit more. Since each ButtonReleased method in our program does the same thing we can share a single event as demonstrated in the code below. public class Program { public void BrainPadSetup() { BrainPad.Buttons.WhenUpButtonPressed += Buttons_WhenUpButtonPressed; BrainPad.Buttons.WhenDownButtonPressed += Buttons_WhenDownButtonPressed; BrainPad.Buttons.WhenRightButtonPressed += Buttons_WhenRightButtonPressed; BrainPad.Buttons.WhenLeftButtonPressed += Buttons_WhenLeftButtonPressed; BrainPad.Buttons.WhenUpButtonReleased += Buttons_WhenButtonReleased; BrainPad.Buttons.WhenDownButtonReleased += Buttons_WhenButtonReleased; BrainPad.Buttons.WhenRightButtonReleased += Buttons_WhenButtonReleased; BrainPad.Buttons.WhenLeftButtonReleased += Buttons_WhenButtonReleased; } private void Buttons_WhenUpButtonPressed() { BrainPad.LightBulb.TurnRed(); } private void Buttons_WhenDownButtonPressed() { BrainPad.LightBulb.TurnGreen(); } private void Buttons_WhenRightButtonPressed() { BrainPad.LightBulb.TurnBlue(); } private void Buttons_WhenLeftButtonPressed() { BrainPad.LightBulb.TurnWhite(); } private void Buttons_WhenButtonReleased() { BrainPad.LightBulb.TurnOff(); } public void BrainPadLoop() { } } In the above code, we've accomplish the same thing as before using a few less lines of code. This might not always be the case. But since each button release does the same thing we can simplify our code by sharing the Buttons_WhenButtonReleased() method with all our Button Release events."
  },
  "brainpad/courses/programming/vb/threading_and_events.html": {
    "href": "brainpad/courses/programming/vb/threading_and_events.html",
    "title": "Threading and Events",
    "keywords": "Threading and Events"
  },
  "hardware/legacy_products/netmf/embedded_master.html": {
    "href": "hardware/legacy_products/netmf/embedded_master.html",
    "title": "Embedded Master",
    "keywords": "Embedded Master Embedded Master is a NETMF System on Module. Resources User Manual Using the NETMF software We discourage the use of NETMF software on our products in favor for TinyCLR OS, Read more about the use of NETMF and TinyCLR OS. Embedded Master will only work with the NETMF 4.1 SDK. Using TinyCLR OS If haven't yet, read about using .NET NETMF devices with TinyCLR OS Loading Bootloader v2 Tip The bootloader version 1 doesn't always work with Windows 7 and newer (Error code 10). You can use the serial option to update the loader. This is a one-time procedure. You should have no issues after the bootloader V2 is loaded. To update using USB Download the bootloader file Set Embedded Master in boot mode, by making pins up, down, and select (3, 7, and 53 on TFT or 43 on non-TFT) low and reset the Embedded Master. The PC will now detect a virtual serial (COM) device. If you need drivers, they are in the NETMF SDK. Open any terminal software, we recommend Tera Term . Select serial and pick the COM port associated with your board. Enter E and you will see back \"Erase all memory! Are you sure?\" now enter Y . (The bootloader is case sensitive) Enter X and you will see CCCC ... showing on the terminal. Now go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the bootloader file you have downloaded above. You will see File Transfer Finished Successfully . Change the configuration switches back to the off position and reset the board. You are now running GHI Electronics bootloader v2! To update using Serial Connect a development PC to COM1 on Embedded Master, pins 5 and 6 (through RS232 converter or a USB-Serial TTL cable). Set the down and select pins low. Follow the steps above starting at 4 to load the firmware. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, set the up pin low and then reset your board. To enter USB mode, set the select pin. Download the EMX firmware and follow Loading the Firmware steps."
  },
  "hardware/loaders/ghi_bootloader.html": {
    "href": "hardware/loaders/ghi_bootloader.html",
    "title": "GHI Bootloader",
    "keywords": "GHI Bootloader The GHI Bootloader is used to update the firmware on our devices. It is the first program to run and unless the device specific LDR pins are set (see device documentation for details), it will execute the firmware on the device if present. The bootloader communicates over a USB virtual serial port and a regular serial port. The interface used is controlled by a MODE pin. See your device specifications for details on interface configuration and selection and for which version of the bootloader it runs. Tip If you are running Windows 7 or Windows 8, you must install drivers for the bootloader to appear in Windows. See the downloads section . Bootloader v2 All commands and results are terminated with CR and LF (\\r\\n). \"OK.\" will be sent after each successful command. On startup, a banner is sent that is terminated by \"OK.\". Once the banner is received, you are free to enter any of the case-insensitive single-character commands described below. Most commands require confirmation. Send Y or y followed by a new-line to proceed or anything else to cancel. V: returns the current version. N: returns the current device type. E: erases all user sectors of the device. R: runs the firmware if present. B: increases the baud rate in serial mode to 921,600. X: upload a ghi file to the device using 1K XMODEM. Only send *.ghi files meant for your device. U: upload a glb file to the device using 1K XMODEM. Only send *.glb files meant for your device. Loading the Firmware Using TinyCLR Config TinyCLR Config tool includes multiple features developers need to work with TinyCLR-OS-enabled devices. It simplifies the firmware update and it includes options for accessing the TinyCLR firmware at runtime. Using this tool is the recommended path; however, the manual instructions are included on this page. Read more on the TinyCLR Config page. Manual Loading the Firmware TinyCLR Config tool should be used to update the firmware. As a backup, use these instructions: Set your board in the bootloader mode. Each product has a specific way to enter the boot loader. Open any terminal software, for example Tera Term . Select serial and pick the COM port associated with your board. (If unsure, check Device Manager) Press V and then enter. You will see back the boot loader version number (v2.x.x) Press U or X and then enter. Use X for firmware file type GHI and U for firmware file type GLB. Press Y to confirm then enter. You will now see CCCC ... Go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the firmware file. When the transfer is complete, reset your board. GLB File Format The glb files that are loaded onto devices have some additional metadata that help the bootloader function in addition to the raw data itself. The first 1,024 bytes of a glb file is the upload header. Starting from offset 0 are the below fields. The rest of the header is currently reserved. 32 bit signature number that is unique for each device. 32 bit unsigned address in flash that this image should be copied to. 32 bit unsigned length of the image to flash rounded to the nearest 1,024 bytes. 16 bit CRC-CCITT of the image. After the upload header is the actual image to flash. If its length is not divisible by 1,024 bytes, it is padded until it is. For images that are meant to be bootable, the address in the upload header should be set to the entry point defined for the specific device. Bootable images have an additional 1,024 byte header at the beginning of the image that is used to verify the image before booting it. The boot image is also padded to the nearest 1,024 bytes. Starting from offset 0 are the below fields. The rest of the header is currently reserved. 32 bit signature number that is unique for each device. 32 bit unsigned address in flash that is the entry point the bootloader will invoke. 32 bit unsigned length of the boot image rounded to the nearest 1,024 bytes. 16 bit CRC-CCITT of the boot image bounded by the specified address and length. Bootloader v1 Currently the USBizi, EMX, G120, and G120E ship with this version of the bootloader. All results are terminated with LF (\\n). Commands are executed as soon as they entered without waiting for a new-line. \"BL\" or \"Done.\" will be sent after each command. On startup, a banner is sent that is terminated by \"BL\". Once the banner is received, you are free to enter any of the case-sensitive single-character commands described below. V: returns the current version. E: erases all user sectors of the device (* is sent while erasing). R: runs the firmware if present. B: increases the baud rate in serial mode to 921,600. X: upload a file to the device using 1K XMODEM. Only send *.ghi files meant for your device. The firmware is automatically run after a successful upload. Tip The USB interface on Version 1.0 doesn't always work on Windows 7 and newer operating systems. Use the serial interface instead. Downloads Here you can find the various bootloaders available for the various products. FEZCLR File Date Status MD5 v2.0.4 2017-08-31 Alpha 33F7FCAE266D07209C079CEA38AAB583 v2.0.3 2017-07-07 Alpha 056919694D6A5F06546F9B721AE141CE G120 File Date Status MD5 v2.0.4 2017-08-31 Alpha 7052D6FFB1890987DDCC4043895788D3 v2.0.2 2017-03-07 Alpha 00ECD55A24607336863B1D61B91C3D86 G400 File Date Status MD5 v2.0.4 2017-09-13 Alpha BD46D86D41DCD42C4FC50D27AF02E5EE v2.0.2 2017-04-06 Alpha 81D45A8F078AA8E633C824C7BB3279DC v2.0.1 2016-06-27 Alpha 42CD50E4105939611ABF360475EBF4E5 Cerb File Date Status MD5 v2.0.4 2017-08-31 Alpha 934825046A0245756C2F3B4066E7F79F v2.0.3 2017-07-07 Alpha 6505870259AC8E748FD09EBD00796E2E EMX File Date Status MD5 v2.0.4 2017-08-31 Alpha E728AEFF7737E60B05620F9387FAA373 Embedded Master File Date Status MD5 v2.0.4 2017-08-31 Alpha F39BD6BC7F14855A6B5A557DEF26B720 USBizi File Date Status MD5 v2.0.4 2017-08-31 Alpha 97BF3C83B801CDA6119B149CF339BE7A v1.0.7 144 2015-05-05 Production 853557479D8797EAB650B98E3D333DCF v1.0.7 100 2015-05-05 Production 34D17AA5CA4E13D5447C80AB8094D064 USB Drivers Only needed for Windows 7 and 8 since they do not automatically load drivers for the bootloader interface. File Date Status MD5 v0.6.0 x64 2017-08-31 Alpha AEDD7C00854BBF99AC3FDAB4976E1F33 v0.6.0 x86 2017-08-31 Alpha A0F487D32B882199F0A69E6CAA8DE4CB"
  },
  "hardware/loaders/stm32_bootloader.html": {
    "href": "hardware/loaders/stm32_bootloader.html",
    "title": "STM32 Bootloader",
    "keywords": "STM32 Bootloader The STM32 Bootloader lives on all STM32 chips. It is necessary to load files (loaders and/or firmware) onto the chip. Several TinyCLR OS supported boards will use this loader to load the software. These instructions apply to all STM32 chips with built in USB and DFU features. Creating DFU file The STM32 bootloader only accepts DFU file types, which can be generated from a HEX or BIN files. To generate a DFU file, download the \"DfuSe USB device firmware upgrade STMicroelectronics extension\" software package Depending on using a HEX or BIN files, the instructions are slightly different. From HEX files Find and open \"Dfu file manager\" and select \"I want to generate a DFU file\". Click on \"S19 or Hex...\" button to select the hex file. Click \"Generate...\" You now have the DFU file! From BIN files Find and open \"Dfu file manager\" and select \"I want to generate a DFU file\". Click on \"Multi BIN...\" button to select the bin file. Change the address to 08000000 Click on the \"Add to list >>\" button then click the \"OK\" button. Click \"Generate...\" You now have the DFU file! Uploading DFU Files To set the STM32 chip in DFU mode, BOOT1 pin (if available) needs to be low and and BOOT0 needs to be high when the system powers up. If your system has a BOOT1 button, just hold the button down while powering the system up. The device manager will see the device \"STM Device in DFU Mode\". Find and open \"Open DfuSe Demo\" (from the ST download higher in this page) Under \"Upgrade and Verify Action\", click the \"Chose...\" button and select the firmware DFU file you want to load. Click the \"Upgrade\" button. Click the \"Leave DFU mode\" button. Congratulations, your board is now running the loaded firmware!"
  },
  "hardware/products/brainpad.html": {
    "href": "hardware/products/brainpad.html",
    "title": "BrainPad",
    "keywords": "BrainPad The BrainPad is an educational STEM & STEAM targeted board. Courses and learning materials are found under the BrainPad section. This page has info for advanced users. Resources: The BrainPad's main website: brainpad.com Schematic The Original BrainPad The limited-release original BrainPad was used to iron out the details that helped us in creating the leaner and meaner production BrainPad. The original BrainPad is no longer recommended; however, the latest software is mostly compatible with original BrainPad. Feel free to use the original BrainPad with the latest software to ease into the transition. Resources: Schematic Other Software Options The TinyCLR OS is the official supported system for the BrainPad. However, there are many other options listed on the FEZ hardware page (The BrainPad and the FEZ share the same core)."
  },
  "hardware/products/scm/g80.html": {
    "href": "hardware/products/scm/g80.html",
    "title": "G80",
    "keywords": "G80 The G80 System on Chip (SoC) is a low-cost chipsets running the .NET Micro Framework. It is programmed using Microsoft's Visual Studio using C# or Visual Basic which allows developers to take advantage of the extensive built-in NETMF libraries and GHI Electronics added extensions. To use G80 SoC, follow the setup instructions on the NETMF intro page Datasheet Using the NETMF software We discourage the use of NETMF software on our products in favor for TinyCLR OS. Read more about the use of NETMF and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using NETMF devices with TinyCLR OS Loading Bootloader v2 The G80 SoC ships with the Bootloader loaded and locked. No further steps are necessary. Loading the Firmware To activate bootloader v2, LDR0 signals needs to be low while resetting the board. Download the G80 firmware and follow Loading the Firmware steps. G80 Based products G80 Development Board The development system used for evaluating the EMX SoM. Schematics G80 TH Module A though-hole version of G80. Schematics FEZ Panda II An Arduino-pinout compatible single board computer. Schematics"
  },
  "hardware/products/scm/intro.html": {
    "href": "hardware/products/scm/intro.html",
    "title": "SCM Products Introduction",
    "keywords": "SCM Products Introduction Coming soon."
  },
  "tinyclr/intro.html": {
    "href": "tinyclr/intro.html",
    "title": "TinyCLR OS Introduction",
    "keywords": "TinyCLR OS Introduction TinyCLR OS is our path forward that started with the .NET Micro Framework to enable managed .NET development using Microsoft's Visual Studio on embedded devices -- including debugging features! All you need to get started is Visual Studio, a TinyCLR device, and a USB cable. Tip TinyCLR OS is still an alpha so there is still a lot more to come! TinyCLR OS is made for .NET developers. Threading, memory management, timers, event handlers, and many more exist in TinyCLR OS just like they do on full .NET. For interacting with hardware, TinyCLR OS has an API similar to the Windows 10 IoT Core Extensions API that you may already be familiar with. GPIO, UART, SPI, I2C, ADC, DAC, PWM, and more are all available for you to interact with the embedded world. Better yet, all libraries are available through NuGet. Because of this, there will be no SDK to install or machines to lock to specific versions. Simply use NuGet to download any needed version of any needed library on a per-project basis. To set a system to use TinyCLR OS: If you don't already have Visual Studio 2017, download and install the freely available Visual Studio Community 2017 . Make sure to select the .NET desktop development workload when installing Visual Studio. Download and install the newest TinyCLR OS Visual Studio extension . Connect your device to your PC using a USB cable. Don't have a TinyCLR OS device yet? There are many supported boards . Start Visual Studio and create a new TinyCLR Application under C# > TinyCLR . New to Visual Studio or C#? Take a look at the getting started guide from Microsoft . Add some code and press F5 to deploy and begin debugging your application! Since TinyCLR OS is still so new, we haven't yet uploaded any packages to NuGet, so make sure to download the newest libraries , extract the archive, and place them in a local NuGet feed . Do not forget to update the firmware on your board . You are now ready to get started with TinyCLR! Take a look at the tutorials to get going. Tip If you're an existing user of NETMF and still want to use it in addition to TinyCLR OS, don't worry. TinyCLR OS is completely independent of NETMF and works side-by-side with no issues. Take a look at the release notes to see what's new and the roadmap to see what we have planned. Interested in running TinyCLR OS on your own device? Take a look at the porting guide for information on how to get started."
  },
  "tinyclr/release_notes.html": {
    "href": "tinyclr/release_notes.html",
    "title": "Alpha Release Notes",
    "keywords": "Alpha Release Notes 0.6.0 on 2017-08-31 Notes This release adds support for the G400 and all of our previous NXP based devices: G120, EMX, Embedded Master, and USBizi. There are new LPC17 and LPC24 ports and ARM7, ARM9, and CortexM3 builds of the core now available in the GitHub repo . There are new classes available in the Pins library to go along with these new ports. The other major changes in this release are fixed automatic loading of USB drivers, updated bootloaders for devices, continued improvements to the BrainPad library, Acquire and Release were added to all native APIs, native interops have increased functionality, and sharing modes for devices are now supported. Also available in this release is a very early preview of the new TinyCLR Config tool. It can be used to check your device for updates over the internet and install an update if found (if the device has the GHI Bootloader version 2); save, load, erase, pause, and resume the managed application; and capture debug messages. More functionality is planned. See here for more information. Relatedly, we are also making signed drivers for the GHI Bootloader available for Windows 7 and 8. These drivers are not needed on Windows 10 or newer. Lastly, how we distribute releases is changing going forward. There's no longer one monolithic archive to download. Instead, everything TinyCLR can be found on its downloads page and bootloader binaries are available on the bootloader download page. MD5 hashes are provided for all downloads as well. Libraries Changes Split ReadTemperature in BrainPad to ReadTemperatureInCelsius and ReadTemperatureInFahrenheit . Moved Picture out of BrainPad.Display . Moved BrainPad.Expansion to the pins library. Changed the original BrainPad display driver to only allocate memory on first use. Added basic STM32F4, LPC17, LPC23, LPC24, and AT91 processor definitions to the pins library. Added many more devices to the pins library. Updated many pin names to match the processor name more closely (particularly COM to UART). Calls to *Provider.FromId in devices with the same id now return the same object instance. Sharing modes for the various providers in the devices library are now supported. Software I2C works correctly again. Added Environment.NewLine . Known Issues Formatting numbers that cross an assembly boundary can throw an exception. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. Partially transparent ellipses have weird artifacts. Pins are not currently reserved so you can create multiple objects on the same pin which behave incorrectly. Firmware Changes Fixed the device not loading drivers over USB. Added clicker and clicker2. Added G400, G120, EMX, Embedded Master, and USBizi. Renamed FEZ to FEZCLR and FEZCerberus to Cerb #8 . Refactored specific devices out of the build script and into configuration files #6 . Corrected the incorrect index being passed to TinyCLR_Startup_SetDebugger #3 . Fixed PWM beyond timer 8 on on STM32F4 boards not functioning. Reworked the GPIO functions in the ports to more closely match the processor's API. Added ARM7, ARM9, and Cortex M3 targets. Added a flag for whether or not to run TinyCLR after rebooting. Added Acquire and Release to GPIO, ADC, DAC, PWM, Interop, Task, Memory, and API providers. Interop GetReturn now sets the return type automatically but will no longer create an array, object, or string (call CreateObject yourself after). Interop ReplaceObject now functions. Strings can now be manipulated in interops. Interops now support DateTime and TimeSpan objects by exposing them as U8. Added FindType to interops for finding a specific managed typed by name and assembly. Objects in interops now track the type of the object as well with the TinyCLR_Interop_ManagedObjectType type. Very basic object creation in interops has been added, but it fails in many cases and does not run any constructor. Removed the stack parameter from ReplaceObject in interop. Known Issues Rapidly pressing the buttons on the BrainPad may corrupt the display. Many UART properties and events are not implemented. Deploying over USB when out of memory crashes the board. Arrays of non-primitives in interops are not supported. CAN and USB host are missing. The USB client API is still very rough and will change. An 0xA2000000 error is sent over the debug transport when there is no deployment present. The version passed to SetDeviceInformation is ignored. PWM may jitter when decreasing the pulse length while enabled. Deploying on USBizi sometimes fails. Reset the board and try again to work around it. An internal error may sometimes occur during deployment. Reset the board, cancel deployment, and try again to work around it. Tight loops on LPC24 may prevent the debugger from working. The LCD on EMM sometimes does not work. The LCD has a blue tint on EMX and EMM #29 . Debugging VS through serial on G120 does not work #34 . UART 3 does not work on G120E and 4 does not work on G120 and G120E #35 . Non-blocking GpioChangeWriter does not work on NXP devices #36 . The last two PWM are missing on Cerb #37 . PWM on PB8 and PB9 do not work on Cerb #38 . The run app pin does not work on USBizi #39 . ADC 6 and 7 do not work on USBizi #40 . PWM on 3.27 does not work on EMM #41 . Debugging in VS sometimes pauses forever until you manually break #42 . Debugging in VS with USBizi crashes the firmware sometimes #43 . The ADC on G80 may be slightly inaccurate #45 . TinyCLR Config Changes Initial release. Known Issues The Update Firmware action won't work in this release because changes were needed in the firmware. Use the Loader tab to manually update the firmware. This will not be required in the next release as long as you have the firmware from this release or newer on the device. TinyCLR Config may not function properly with devices running firmwares from before this release due to changes in the communication protocols. Extension Changes Added a using for GHIElectronics.TinyCLR.BrainPad to the C# BrainPad Application template. Removed Expansion from the VB and C# BrainPad application templates. Updated URLs in the various NuGet and VSIX packages. Forced parity to none when using the serial debugger interface instead of using what the port configures. Known Issues Some uses of pattern matching may crash the C# compiler. Visual Basic resources page generates an incompatible resource file. Visual Basic resource files are wrapped in a second namespace. When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. 0.5.0 on 2017-07-07 Notes This release focuses on the public porting library and API -- though there are a few minor fixes and changes in other areas. As part of the new porting experience, we are also releasing a very early build of TinyCLR for the Netduino 3 and Quail mainboard! You can now port TinyCLR OS to run on your own system using the header file and library we provide -- as long as your architecture is supported. Currently, only Cortex M4 is available. Keep in mind the available API is still alpha and may change, especially USB client. See here for details. You can also create your own managed functions that can call into native code that you provide. These will be automatically wired into the system for a seamless experience. See here for details. To support this, we added a few more classes under System.Runtime.InteropServices . Most important is the Interop class. It allows you to add and remove interops from the system by providing it with the address in memory of the interop definition table. It expects you to load it into memory yourself using the Marshal class. You can use FindAll to get back a list of all interops registered in the system and RaiseEvent to trigger an event on the specified native event dispatcher. The NativeEventDispatcher class allows you to get an instance of the class to receive events that the specified dispatcher name receives (either from native code or Interop.RaiseEvent ). It has a single event that gets triggered whenever an event is received. There is only one instance per dispatcher name, so calls to GetDispatcher with the same name will return the same instance. Similar to Interop , Api can be used to add and remove native APIs from the system. It expects you to load the API into memory yourself and pass it the address of the API definition. You can query all registered APIs, find a specific API by name and type, and parse and creator selectors. Selectors are a string that represents an API name and index into its implementations of the form \"name\\index\". A default selector is set so that a specific API type can be returned without knowing the exact name, like the default GPIO controller on a system. The Api class is used internally by the devices library to talk to the native implementation via the implementation IntPtr provided for the given API name and index. In some cases you can use the GetDefault method on a given device provider to return the default registered API. If there is no default, like for PWM and others, you can pass the Id property in the specific pins class to the desired device provider. We added Marshal.GetDelegateForFunctionPointer to enable you to create a quick native interop for a specific address in memory that takes a single ref IntPtr parameter and returns nothing. DeviceInformation was also added to return the device name, manufacturer, and version set on the native side. After flashing the firmware for the first time on any device, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . Libraries Changes Added running device detection. Added listing, adding, and removing system interops. Added listing, adding, and removing system APIs. Added Marshal.GetDelegateForFunctionPointer . Added NativeEventDispatcher . Added provider IDs to pins. Added FEZ pinout. Added Expansion to BrainPad. Updated devices library to use the provider and native API model via a Provider class for each type. Core assembly was renamed to mscorlib . GetDeviceSelector and DeviceInformation.FindAll now throw an exception on use. Opening a non-existent UART now throws on construction. Changed DateTime.Ticks to use the same epoch as the desktop. Gpio write now fires ValueChanged . BrainPad accelerometer now uses the proper axes and scaling. BrainPad Image was renamed to Picture . BrainPad WriteOnComputer was renamed to WriteToComputer . BrainPad Servo SetMaxPulseWidth now has correct range in the exception message. Increased the duration and frequency of the BrainPad buzzer beep. Original BrainPad display now works. Replaced AutoShow flag on BrainPad with DrawTextAndShowOnScreen methods. Reworked BrainPad Servo API. Removed BrainPad Board class. Known Issues Software I2C can lock up the board if a slave device isn't connected or responds improperly. Formatting numbers that cross an assembly boundary can throw an exception. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. Device sharing modes are not respected. Partially transparent ellipses have weird artifacts. Pins are not currently reserved so you can create multiple objects on the same pin which behave incorrectly. Software I2C does not work. Firmware Changes Initial FEZ Cerberus, FEZ, Netduino 3, and Quail firmware release. All peripherals are now properly reset on startup. Gpio write values are stored when not in output model. Fixed PWM jittering. All frequencies now round down. Fixed gpio interrupts being slow and something getting missed. Known Issues Rapidly pressing the buttons on the BrainPad may corrupt the display. GpioChangeWriter generates an incorrect signal for periods above 50ms on G400. An 0xA2000000 error is sent over the debug transport when there is no deployment present. Many UART properties and events are not implemented. There is no firmware for G120 and G400 in this release. PWM on controller 8 and up does not work on the G80. Deploying over USB when out of memory crashes the board. Extension Changes Removed stray semicolon in BrainPad Visual Basic template. Changed BrainPad templates to have a BrainPad static class in them. Reduced the number of retries for connecting to device. Added namespace to C# BrainPad template. Known Issues The device may not load drivers on Windows 7 preventing Visual Studio from seeing it. Some uses of pattern matching may crash the C# compiler. Visual Basic resources page generates an incompatible resource file. Visual Basic resource files are wrapped in a second namespace. When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. Porting Changes Initial release of porting library and API. Known Issues Marshalling strings does not work. Marshalling DateTime and TimeSpan does not work. Creating and replacing managed objects does not work. CAN and USB host are missing. The USB client API is still very rough and will change. 0.4.0 on 2017-05-10 Notes This release primarily fixes several bugs; implements more of the serial API; adds DataReader , DataWriter , and Marshal classes; and reworks a lot of the BrainPad API. A new Storage library was added that moves some large members (like DataReader ) out of Devices that you may not always needed. There is more to be added to this library down the road. SignalGenerator , SignalCapture , and PulseFeedback were renamed to match the Windows 10 counterparts. Their API will be updated to match as well in a future release. The Marshal class under System.Runtime.InteropServices can be used like the old Register and AddressSpace classes to read and write memory. It also adds allocating and releasing unmanaged memory from the managed side that can be manipulated from the other members. You can see a quick example on using the new serial API here . You must use either the DataReader and DataWriter classes or use the WindowsRuntimeBufferExtensions to manipulate a Buffer since the internal array is no longer publicly accessible to match the UWP API. Pay attention to the Load and Store members. You can't read before calling Load and writes do not get flushed until you call Store . There has been no change to the G120 and G400 bootloaders in this release so you do not need to update them if you already have them on your device from the 0.3.0 release. After flashing the firmware for the first time on any device, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . Libraries Changes Fixed GpioPin.ValueChanged sender parameter type to be GpioPin. Fixed many of the Debug and Trace members not functioning properly. Fixed LowLevelDevicesController.DefaultProvider throwing an exception when null instead of falling back to the built-in providers. Fixed SerialDevice.Read not respecting the ReadTimeout value. Fixed SerialDevice.BytesReceived and IBuffer.Length not getting updated when reading. Fixed the exception that was thrown in BrainPad.Buttons when buttons are pressed. Fixed the exception that was thrown when using BrainPad.ServoMotor . Fixed PWM glicthing other pins on the same controller when changing one pin. Fixed Thread.Sleep not always sleeping for the proper amount of time. Fixed SerialDevice.ErrorReceived not being raised. Added EventArgs . Added WindowsRuntimeBufferExtensions . Added DataReader and DataWriter . Added various From methods to TimeSpan . Added InteropServices.Marshal . Added EditorBrowsable attribute to several members inherited from object to the BrainPad members. Added GHIElectronics.TinyCLR.Storage with WindowsRuntimeBufferExtensions , DataReader , and DataWriter in it. Updated the underlying value of the SerialError enum. Updated the BrainPad to be based around instance properties rather than static classes. Updated SerialDevice.Read to only support InputStreamOptions.Partial and InputStreamOptions.None . Moved InputStreamOptions , IInputStream , IOutputStream , IBuffer , and Buffer to the GHIElectronics.TinyCLR.Core assembly. Moved the BrainPad expansion pins to the pins library. Improved support for the original BrainPad in the driver. Improved many of the BrainPad APIs. Removed the members of Buffer that don't conform to the UWP API. Renamed SignalGenerator to GpioChangeWriter , SignalCapture to GpioChangeReader , and PulseFeedback to GpioPulseReaderWriter . Known Issues The original BrainPad display does not currently work with the GHIElectronics.TinyCLR.BrainPad library. Software I2C can lock up the board if a slave device isn't connected or responds improperly. ServoMotors.SetMaxPulseWidth has an invalid range in the exception message. Formatting numbers that cross an assembly boundary can throw an exception. Opening a non-existent UART will only throw when it is used. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. Firmware Changes Fixed the G30 sometimes getting stuck during deployment. Added another sector to the G30 deployment region. Known Issues Rapidly pressing the buttons on the BrainPad may corrupt the display. Gpio interrupts may be slow when Visual Studio is connected. Some frequencies may round up instead of down if the requested frequency cannot be met. An 0xA2000000 error is sent over the debug transport when there is no deployment present. GpioChangeWriter does not generate proper signals for periods above 50ms on G400. Extension Changes Added a flag on the TinyCLR OS property page to control stub generation style. Added the DebuggerNonUserCode attribute to the startup code in BrainPad templates. Removed the public modifier from the C# application template. Known Issues The Visual Basic BrainPad template has a semicolon in the startup file. The device may not load drivers on Windows 7 preventing Visual Studio from seeing it. Some uses of pattern matching may crash the C# compiler. Visual Basic resources page generates an incompatible resource file. Visual Basic resource files are wrapped in a second namespace. When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. 0.3.0 on 2017-04-06 Notes This release has several API additions. Some were added as features themselves (software SPI, SignalGenerator, etc) while others were added to support certain features (the VB runtime, string.Format, MemoryStream and IntPtr for Drawing, etc). We're working to align ourselves with the various .NET Reference Sources available. You'll also see many new icons throughout, application templates for the BrainPad, and common item templates. The NuGet packages that have dependencies (such as on Core), now require the major and minor versions to match. For example, the 0.3.0 Devices library depends on Core [0.3.0,0.4.0). This is to further our use of SemVer so that the native interop checksum only changes in major and minor versions. See the NuGet docs for more information. The biggest addition is the drawing library. It was designed to mirror System.Drawing from the desktop. The basic API is there but there is still more work to be done. To support this, a DisplayController was added to the devices library to configure the display. Since there is no config yet you need to configure the display every time your program starts. A notable change from NETMF is calling flush on a drawing surface the size of the display will no longer draw to the display. Only drawing surfaces created from the FromHdc method passing in the Hdc value from the DisplayController will flush to the display. At this time, only bmp images are supported. Make sure you add a reference to GHIElectronics.TinyCLR.Drawing if using bitmap or font resources. Since it's in NuGet now it isn't automatically added. Support for Visual Basic has also been reenabled. One important thing to keep in mind is that there is no longer a Microsoft.VisualBasic assembly. We are using the embedded runtime option provided by Roslyn. It relies on several APIs being present in the core library. We added several of the key APIs needed to enable common usage scenarios. If you find you're getting cryptic compile errors from locations not in your code, let us know so we can evaluate what additional APIs are required. Since the UWP API only supports a controller wide frequency, we had to rework PWM a little bit. There is no longer one controller like there is for GPIO, instead one controller exists for each frequency source. On devices like the G30 and G80, this is a timer. On devices like the G400, there are independent registers for each channel (so unfortunately there will be one controller per channel). The pins library has been updated to organize PwmPin around controllers. SignalGenerator, SignalCapture, and PulseFeedback have also been added, but their APIs will change in a future release to match the UWP style. You can also now change what gets returned by GetDefault calls on the various controllers by updating LowLevelDevicesController.DefaultProvider. The Diagnostics namespace now matches the desktop version more closely. WriteLineIf and Assert were added to Debug and Trace was added as well. All methods on Debug and Trace are marked with the Conditional attribute as expected using the DEBUG and TRACE constants respectively. There's also now a Listeners property on each. This is a collection that you can add to so you can receive whatever is written to Trace or Debug by registering a class derived from TraceListener. As on the desktop, both Trace and Debug share the same listener collection. By default, the collection is populated with a listener that prints to the debug transport which is now at Debugger.Log. Collect and GetTotalMemory were added to GC. Note that GetTotalMemory returns the amount of memory used, not free, to match the desktop. We're investigating APIs to return the amount free. The last notable change is that we implemented IntPtr and UIntPtr. For now, they're only used as the type of the Hdc property in drawing. We expect them to be used in more places going forward. Since these two types map to native int and native unsigned int in the CLR and the managed compilers emit those types when they encounter IntPtr or UIntPtr, we have also added initial support for those types in the interpreter and runtime as well. Let us know if you encounter any weird or hard to explain runtime issues. This release also includes the firmware for the G400. It requires an updated bootloader from the one provided on the G400 bootloader installation page . Simply download the bootloader installer from the installation page and replace Bootloader.bin with the bootloader provided in the TinyCLR download package (making sure to rename it to Bootloader.bin). This updated bootloader can still be used to install the NETMF G400 firmware. It will eventually replace the one provided on the installation page. After flashing the firmware for the first time on any device, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . You can see some examples of the new APIs added in this release here . Libraries Changes PWM now has one controller per frequency source (usually a hardware timer) allowing different frequencies for each controller. string.Format should now work in all cases. Formatting numbers (ToString(\"N2\"), etc) should now work in all cases. I2C read/write partial functions now return the proper result. Opening non-existent ports no longer crashes the firmware. CultureInfo, NumberFormatInfo, and DateTimeFormatInfo now implement IFormatProvider. Primitives (except Boolean), DateTime, TimeSpan, Guid, and Enum now implement IFormattable. Added the == and != operators to Guid. Added a drawing library and display configuration. Added Enum.GetUnderlyingType Added LowLevelDevicesController and the provider API model for SPI, I2C, GPIO. Added SignalGenerator, SignalCapture, and PulseFeedback. Added software providers for I2C and SPI. Added CompilerGenerated, SuppressMessage, and In attributes. Added class target to Conditional attribute. Added FormatException and OverflowException. Added InvariantCulture and CurrentCulture to CultureInfo. Added FormattableString and FormattableStringFactory. Added Collect and GetTotalMemory to GC. Added MemoryStream. Added parts of the CodeContracts namespace. Added implementations to IntPtr and UIntPtr. Added Debugger.Log. Added Trace. Added Assert and WriteLineIf to Debug. Added listeners collection to Trace and Debug and a default listener mapped to Debugger.Log. Added BrainPad. Known Issues The sender parameter in the ValueChanged event on GpioPin is an instance of IGpioPinProvider, not GpioPin. Opening a non-existent UART will only throw when it is used. SignalGenerator may fail for small durations. An exception is thrown in BrainPad.Buttons when buttons are pressed. An exception is thrown when using BrainPad.ServoMotor. Some frequencies may round up instead of down if the requested frequency cannot be met. In the Debug class, only WriteLine(string) functions correctly. Firmware Changes G30 should no longer get stuck at waiting for device to initialize. PWM no longer takes 40 seconds to start on the G30 and G80. GPIO interrupts now work on the G120E. Added support for native int and native unsigned int in runtime Added G400 firmware. Known Issues Deploying to the G30 sometimes fails when writing a sector. An 0xA2000000 error is sent over the debug transport when there is no deployment present. Extension Changes Assemblies larger than sector size can now be deployed. Added Visual Basic support. Added BrainPad Application templates Added common item templates. Added icons throughout. NuGet packages now have a better range dependency for dealing with assembly checksums. Known Issues Visual Basic resources page generates an incompatible resource file. Visual Basic resource files are wrapped in a second namespace. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. 0.2.0 on 2017-03-07 Notes You cannot use projects you made for the 0.1.0 version. You must recreate them and re-add your code files because of the changes to the project templates to make them more closely align them with the desktop .NET templates -- you'll notice the only difference is a few properties which prevent inclusion of reference assemblies. The templates also use the .NET Framework 4.5.2 target framework. This is only for NuGet compatibility going forward and does not mean you can use other libraries targeting that framework. This was done in anticipation of broader project system support of the new PackageReference format currently used in .NET Core which fails with unknown target frameworks. The MSBuild package is no longer provided or required. The metadata processor tool has moved internally to the extension and is invoked during deployment to the device. This means that pe and pdbx files are no longer redistributed with their assemblies -- they appear in a pe folder under the output directory when you deploy. We have also rewritten how dependencies are detected for deployment. If you notice any weird failures around assembly resolution or deployment, let us know and send us the entire project as-is so we can diagnose it. The information displayed while deploying to the device has also been improved to show more information about what is going on and what stage the deployment is in. We've also reworked incremental deployment so that assemblies are deployed one to a flash sector (if space allows) to enable re-deploying only the assemblies that have changed on a sector by sector basis. This greatly increases deployment speed on devices which a large number of flash sectors allocated to deployment. This release also includes the firmware for the G120 and G120E. Because the current GHI bootloader on the G120 expects to load TinyBooter, we have provided a second stage bootloader with this preview that you must deploy using the existing GHI bootloader as if you were deploying TinyBooter. Once it is deployed and you restart the device, you'll notice that it starts our newer GHI bootloader 2.0 . You can then use this second bootloader to deploy the TinyCLR OS firmware. Asserting LDR0 will enter the second bootloader while asserting both LDR0 and LDR1 will enter the original bootloader and allow you to return to NETMF. After flashing the firmware the first time, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . Libraries Changes Formatting numbers works in more cases. The built in \"en\" culture has been removed. The dependency on GHIElectronics.TinyCLR.MsBuild has been removed. The pe and pdbx files are no longer included with the package. The package now targets the NET452 TFM. The duty cycle and polarity can now be set when the PWM pin is stopped. The frequency for the PWM controller can now be set at any time. PwmController.SetDesiredFrequency and PwmController.ActualFrequency now return the actual frequency the device was able to meet. The min and max frequency for PWM is now returned correctly. Removed analog input and output precision. Added G120, G120E, and FEZ Cobra III. CAN bus definitions now return a friendly name instead of an integer. Renamed Gpio to GpioPin, AnalogInput to AdcChannel, AnalogOutput to DacChannel, and PwmOutput to PwmPin. The pe and pdbx files are no longer included with the package. The package now targets the NET452 TFM. Known Issues Formatting numbers sometimes returns incorrect values. string.Format fails for non-trivial cases. There is only one PWM controller currently and since the Windows API has a controller-wide frequency, all PWM channels use the same frequency. Some frequencies may round up instead of down if the requested frequency cannot be met. Firmware Changes Added G120/G120E firmware. Flushing over USB is quicker. GPIO interrupts are now raised reliably. The maximum allocation is now 51,539,607,484 bytes. Known Issues PWM frequencies beyond 45MHz on G80 and 21MHz on G30 can fail. PWM may take up to a minute to start on G30 and G80. Extension Changes Breakpoints and the commands dependent on them now function properly. References no longer need a solution reload to deploy. The GHIElectronics.TinyCLR.MsBuild package has been removed. PDBX and PE files are now generated at deploy time. The deployment progress log shows more information. Incremental deployment is now better about deploying only what has changed. Debugging stops quicker after all threads in the application exit. The project templates now mirror the desktop templates much more closely. The Visual Studio projects now target .NET Framework v4.5.2. Known Issues Deploying an assembly larger than the flash sector size fails. An 0xA2000000 error will get sent over the debug transport whenever there is no app present. 0.1.0 on 2016-12-16 Known Issues After flashing the firmware the first time, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . Breakpoints and the commands dependent on them (run to cursor, others) do not work. As a work around, add a class library project called mscorlib to your solution and add a project reference to it or insert calls to System.Diagnostics.Debugger.Break. References can fail to deploy unless a solution close and open occurs after adding the reference. Re-deploying immediately after stopping debugging can fail. Try again to work around it. There is only one PWM controller currently and since the Windows API has a controller-wide frequency, all PWM channels use the same frequency. PwmController.SetDesiredFrequency must be called before any call to PwmController.OpenPin. PwmPin.SetActiveDutyCyclePercentage must be called after Start. GPIO interrupts do not always trigger. PWM may take up to a minute to start. Formatting numbers yields incorrect results in some cases. string.Format fails for non-trivial cases. Only Core, Devices, and Pins libraries are available. Only G30 and G80 are available. Packages are not uploaded to the NuGet public gallery. Additions TimeSpan.Total* {int/long/double/...}.TryParse(string source, out value) string.Format(string format, param object[] args) System.Diagnostics.WriteLine(string message)"
  },
  "tinyclr/accessories/intro.html": {
    "href": "tinyclr/accessories/intro.html",
    "title": "TinyCLR OS Accessories",
    "keywords": "TinyCLR OS Accessories There are thousands of accessories that can be used with boards supported by TinyCLR OS, especially FEZ . However, we have hand picked a few of our favorites and then built the necessary drivers for them. Have a list of your own and want to contribute? Talk to us, directly on through the community forum ."
  },
  "tinyclr/accessories/mikroe_arduino_uno_click_shield.html": {
    "href": "tinyclr/accessories/mikroe_arduino_uno_click_shield.html",
    "title": "MikroElektronika Arduino UNO Click Shield",
    "keywords": "MikroElektronika Arduino UNO Click Shield Through MikroElektronika's mikroBUS standard , hundreds of Mikro's Click boards can be easily connected to your board. The BrainPad , Clicker , and Quail boards all have sockets for plugging click boards. This video talks about the technology behind SPI bus, shift registers, and serial-parallel data. It uses the LED ring click on the BrainPad. The source code is found here . You can use these click boards with FEZ , or any other Arduino-pinout compatible board, through the Arduino UNO click shield . The same code used above with the BrainPad can be used with FEZ and the Arduino UNO click shield. Simply, change the pins from BrainPad to FEZ. The pins are labeled right on the shield. For example, the CS pin on socket 1 is labeled CS/D10 . The complete project is found here"
  },
  "tinyclr/boards/intro.html": {
    "href": "tinyclr/boards/intro.html",
    "title": "Boards Intro",
    "keywords": "Boards Intro While TinyCLR OS can be ported to other devices, we are providing a ready port for few popular boards. One of the ports is for FEZ, which is the official TinyCLR OS board. It will always have the latest and greatest and should be used as a reference for new ports. Firmware Update The firmware needs to be updated to match the assemblies loaded by Visual Studio. If you see an error message about a checksum error then your project's assemblies version does not match the veriosn loaded on the device. Each board will have details on how to load its firmware. Other Supported Devices Several of the GHI Electronics' products support TinyCLR OS. Check the individual hardware pages to see which devices support TinyCLR OS."
  },
  "tinyclr/boards/mikroelektronika.html": {
    "href": "tinyclr/boards/mikroelektronika.html",
    "title": "MikroElektronika",
    "keywords": "MikroElektronika MikroElektronika offers multiple boards that are suited for TinyCLR OS. We offer a pre-compiled firmware for a few of thier products. Clicker/Clicker 2 and related boards ship with the Mikro bootloader pre installed. Use it to load the TinyCLR OS firmware. Tip The loader will wait for a few seconds on every power up before it runs TinyCLR OS. If this delay is not desirable, use an ST-Link programmer to flash the firmware onto the board directly, overwriting the bootloader. Clicker MikroElekronika's STM32 M4 Clicker board includes a single mikroBUS socket, for quickly adding one of many available click modules . The TinyCLR OS Clicker firmware . Warning Clicker and Clicker 2 boards use different processors and different system clock. Each board has its own TinyCLR OS firmware. Clicker 2 MikroElekronika's clicker 2 for STM32 board includes dual mikroBUS socket, for quickly adding one of many available click modules . The TinyCLR OS Clicker 2 firmware . MINI-M4 for STM32 The MINI-M4 for STM32 uses the same processor and system clock as the Clicker board. Use the TinyCLR OS Clicker firmware . Buggy Buggy is a robot rover platform that is expandable through the click modules . The Clicker 2 is used to drive this rover, making it a TinyCLR OS rover! Quail Originally a .NET Micro Framework product, Quail board brings the option of using hundreds of plug-and-play sensors and control modules, thanks to Mikro's click modules . Learn more about Quail at: https://www.mikrobusnet.org/ and https://shop.mikroe.com/quail The Quail firmware is located here . To enter the DFU mode, press and hold the Boot button down while pressing and releasing the Reset button. Now, follow the instructions at the STM32 bootloader page to generate and load a DFU firmware file. When done, your PC should detect a TinyCLR device. You are now ready to start coding Tip The region set aside for RLI is 0x2002F000 - 0x2002FFF8"
  },
  "tinyclr/tutorials/dac.html": {
    "href": "tinyclr/tutorials/dac.html",
    "title": "DAC",
    "keywords": "DAC An analog output sets the voltage on its pin anywhere between 0 and the supplied voltage (maximum voltage) which is typically 3.3 volts. The output voltage is only a signal, not meant to drive any loads. An op-amp or similar circuits can be added to drive loads, such as a speaker. The analog out on a micro has precision, listed in its documentation. Due to that precision, the actual output values on the pin is an approximation. For example, an DAC with an 8-bit (256 steps) analog out as a step precision of 3.3V/256. This example will generate a triangular waveform. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Dac; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { DacController DAC = DacController.GetDefault(); DacChannel analog = DAC.OpenChannel(G120.DacChannel.P0_26); double d = 0.5; double dd = 0.01; while (true) { analog.WriteValue(d); d += dd; if (d <= 0 || d >= 1) dd *= -1;// inverse Thread.Sleep(10); } } } Tip Do not use analog outputs to control the power of an LED or a motor. Use PWM for that."
  },
  "tinyclr/tutorials/display.html": {
    "href": "tinyclr/tutorials/display.html",
    "title": "Display",
    "keywords": "Display Displays can be grouped into two distinct interface categories, Parallel TFT Display and Serial SPI/I2C Displays. Parallel TFT Displays These displays connect to special dedicated pins to the processor. Internally, the display controller automatically transfers (refreshes) the display directly from memory, without any processor interaction. When the system needs to update the graphics, it simply writes to memory. The operating system doesn't need to handle any display work. The down side to this is that the system needs to have enough RAM to handle the display. A 800x600 display with 16bpp needs 960,000 bytes! This should be no issues for systems with external memory. TinyCLR OS built in graphics can be used with these displays. You need to add the GHIElectronics.TinyCLR.Drawing NuGet package and also this in your code: using System.Drawing and using GHIElectronics.TinyCLR.Devices.Display var displayController = DisplayController.GetDefault(); // Enter the proper display configurations displayController.ApplySettings(new LcdControllerSettings { Width = 480, Height = 272, PixelClockRate = 20000000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, }); // Some needed objects var screen = Graphics.FromHdc(displayController.Hdc); var GreenPen = new Pen(Color.Green); // Start Drawing (to memroy) screen.Clear(Color.Black); screen.DrawEllipse(GreenPen, 40, 30, 20, 10); // Flush the memory to the display. This is a very fast operation. screen.Flush(); Serial SPI/I2C Displays Serial displays can work on all microcontrollers. They use the very common SPI or I2C busses. These displays have built in memory buffers, freeing resources from the system. However, updating graphics is significantly slower than using Parallel TFT Displays. The system will have to send serial commands to identify the memory region to update and then follow that with the new data. This is why serial display are usually smaller displays. To the system, the serial display is nothing but a serial device. You are expected to write the code to handle graphics. A good example is the Adafruit Display Shield which uses a SPI display. This video features a very low cost I2C display option"
  },
  "tinyclr/tutorials/pwm.html": {
    "href": "tinyclr/tutorials/pwm.html",
    "title": "PWM",
    "keywords": "PWM Pulse Width Modulation (PWM) is a very import feature found in most microcontrollers. PWM is a pulse that is repeated and generated by the internal hardware. The ratio of the pulse width and its frequency is called duty cycle. Through software, you can control the pulse's frequency and duty cycle. Tip We usually use GetDefault() for most peripherals. For example, there is only one GPIO controller on most systems. This is not the case with PWM. Never use the Default controller and always select the proper channel on the corresponding controller. Tip PWM2.3 is channel 3 on controller 2 Energy Level PWM is perfect for dimming an LED or slowing down a motor. This is done by turning power on and off, at a high speed. When power is on half the time and off half the time, only half the energy is transferred, to the LED or a motor. This demo will fade the LED in and out using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { PwmController Controller4 = PwmController.FromId(FEZ.PwmPin.Controller4.Id); PwmPin led = Controller4.OpenPin(FEZ.PwmPin.Controller4.Led1); Controller4.SetDesiredFrequency(10000); double duty = 0.5, speed = 0.01; led.Start(); while (true) { if (duty <= 0 || duty >= 1.0) { speed *= -1; //invert dirrection duty += speed; } led.SetActiveDutyCyclePercentage(duty); duty += speed; Thread.Sleep(10); // always give the system time to think! } } } Musical Tones Music notes have specific frequencies; C for example is about 261Hz. Plugging these numbers into an array and knowing the length of each tone is all that is needed to play some simple music. When playing notes by changing the frequency, keep thee duty cycle set to 0.5. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Pins; class Program { const int NOTE_C = 261; const int NOTE_D = 294; const int NOTE_E = 330; const int NOTE_F = 349; const int NOTE_G = 392; const int WHOLE_DURATION = 1000; const int EIGHTH = WHOLE_DURATION / 8; const int QUARTER = WHOLE_DURATION / 4; const int QUARTERDOT = WHOLE_DURATION / 3; const int HALF = WHOLE_DURATION / 2; const int WHOLE = WHOLE_DURATION; //make sure the two below arrays match in length. each duration element corresponds to //one note element. static int[] note = { NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_E, NOTE_D, NOTE_D, NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_D, NOTE_C, NOTE_C}; static int[] duration = { QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, HALF, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, WHOLE}; static void Main() { PwmController Controller1 = PwmController.FromId(FEZ.PwmPin.Controller1.Id); PwmPin tones = Controller1.OpenPin(FEZ.PwmPin.Controller1.D0); tones.SetActiveDutyCyclePercentage(0.5); tones.Start(); while (true) { for (int i = 0; i < note.Length; i++) { Controller1.SetDesiredFrequency( note[i]); Thread.Sleep(duration[i]); } Thread.Sleep(100); } } } Servo Motors Servo motors are controlled by a repeated pulse. The pulse is generated every 20ms. This pulse will have a width between 1ms and 2ms, for min and max. Positional servos will go to a specific direction based on the pulse width. Full rotational servos can be controlled, speed and direction, through this pulse, where 1.5ms pulse will stop, 1ms is full speed and 1ms is reverse full speed. Tip most servos will have a 1.25ms min and 1.75max. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { PwmController Controller1 = PwmController.FromId(FEZ.PwmPin.Controller1.Id); PwmPin servo = Controller1.OpenPin(FEZ.PwmPin.Controller1.D0); Controller1.SetDesiredFrequency(1 / 0.020);//a pulse every 20ms double maxPulseLength = 1.75; double minPulseLength = 1.25; double position = 90; double speed = 0.5; servo.Start(); while (true) { double duty = ((position / 180.0) * (maxPulseLength / 20 - minPulseLength / 20)) + minPulseLength / 20; servo.SetActiveDutyCyclePercentage(duty); position += speed; if (position <= 0 || position >= 180) duty *= -1;//reverse dirrection Thread.Sleep(10);// always give the system time to think! } } }"
  },
  "tinyclr/accessories/seeed_grove_starter_kit.html": {
    "href": "tinyclr/accessories/seeed_grove_starter_kit.html",
    "title": "Seeed Grove Starter Kit",
    "keywords": "Seeed Grove Starter Kit Grove is a modular electronic platform for quick prototyping. Every module has one function, such as touch sensing, creating audio effect and so on. Just plug the modules you need to the base shield, then you are ready to test your idea buds. We have picked the Seeed Grove Starter Kit for Arduino as starting base but you can add additional Grove modules as well. The included Grove modules plug into the included arduino shield. This shield works with any arduio-pinout compatible board, like the FEZ . Plug the shield on top of your board, and get the drivers . This example that makes some noise! Buzzer buzz = new Buzzer(FEZ.GpioPin.D4); buzz.Beep(); Thread.Sleep(5000); buzz.TurnOn(); Thread.Sleep(1000); buzz.TurnOff(); while(true) { buzz.Beep(); Thread.Sleep(1000); } This example will read the temperature TemperatureSensor temp = new TemperatureSensor(FEZ.AdcChannel.A1); while(true) { Debug.WriteLine(\"-> \" + temp.ReadTemperature()); Thread.Sleep(1000); } This example will show some text on the character display LcdRgbBacklight lcd = new LcdRgbBacklight(); lcd.Clear(); lcd.SetBacklightRGB(100, 100, 0); lcd.BlinkBacklight(true); lcd.BlinkBacklight(false); lcd.Write(\"*** TinyCLR ***\"); Thread.Sleep(1000); lcd.SetCursor(0, 1); lcd.Write(\"Count:\"); int count = 0; while (true) { lcd.SetCursor(7, 1); lcd.Write(count.ToString()); count++; lcd.SetBacklightRGB(100, 100, (byte)count); Thread.Sleep(100); } Warning Pay attention to the 3.3V-5V switch on the shield. The rotary and temperature sensors only work with 3.3V but the RGB character display only works with 5V. Since the character display connects to I2C and only works with 5V. We have modified one of the I2C sockets to be always 5V. This allows us to keep the switch at 3.3V, leaving all other sockets at 3.3V. Warning These steps require some experience and will void your warranty! Start by cutting the power trace going to the last socket. (image) Now, add a wire from the socket directly to 5V. (image)"
  },
  "tinyclr/porting/contributing.html": {
    "href": "tinyclr/porting/contributing.html",
    "title": "Contributing",
    "keywords": "Contributing We are taking contributions to the TinyCLR OS ports and documentation, but we don't have an established process just yet, so standard contributing practices apply. Create a fork of the repo, create a new branch from dev, work on your changes, then submit a PR. Make sure to follow the existing style for the project and keep your changes easily reviewable. Your changes will need to be licensed under Apache 2 and you need to sign a Contributor License Agreement with us before your PR can be accepted."
  },
  "tinyclr/porting/intro.html": {
    "href": "tinyclr/porting/intro.html",
    "title": "Porting TinyCLR",
    "keywords": "Porting TinyCLR TinyCLR OS can be ported to new devices. We provide the precompiled .NET interpreter and runtime for several architectures. Currently Cortex M3, Cortex M4, ARM7, and ARM9 are supported. To get started we'll build the FEZCLR firmware that the FEZ uses. Clone the ports repo to your computer. If you're new to git or haven't even heard of it, take a look at the Git Book to learn more about it. Download and install GCC . The latest version we have tested is 6-2017-q2-update . Download and extract the contents of CMSIS into the CMSIS folder of the cloned repo. While the file extension is *.pack , it's actually a zip that you can extract once you rename it to *.zip . Download and extract the latest TinyCLR OS Core Library into the Core folder of the cloned repo. Open a command prompt, change the directory to the cloned repo, and then execute build.bat FEZCLR . The compiled firmware can then be found in the repo directory under build\\release\\FEZCLR . The build system automatically produces firmware images in hex format (.hex), a raw binary (.bin), and either a binary meant to be loaded by our GHI Bootloader with its U command (.glb) or a binary meant to be loaded by the same bootloader with the X command (.ghi). For the FEZCLR firmware we built, flash the FEZCLR Firmware.glb to your FEZ following the instructions on the bootloader page. When you restart it, it should be running TinyCLR OS and you can deploy to it from Visual Studio. Creating your own device To create a new firmware for a board that a Target already exists for, you just need to create a new folder under Devices to define your board. You can do this easily by copying an existing board, like the FEZ, and making the changes you need for your board. Make sure you update the scatterfile to place the final firmware image in memory where it needs to be. For example, the FEZ scatterfile expects the GHI Bootloader to be present but you need to place your firmware's image at the start of flash. To make using a custom port easier, we're specifically making the USB product ID 0x5000 under our vendor ID (0x1B9F) available for anyone to use for the USB debug interface on their TinyCLR device. Make sure to only use this product ID because other product IDs are assigned by us for our own use. Of course, if you have your own vendor ID, you are free to use it. So when you copy an existing device to make a new one, be sure to verify the USB vendor and product IDs are correct. Creating a new target To port to a new board with a new Target , make sure it is one of the architectures that we have made a core library available for. Then, like above, you'll need to make a new folder for your device under the Devices folder. You'll also need to create a new folder under Targets that implements the needed APIs. The TinyCLR runtime requires you to provide a few APIs for it to function correctly: deployment, interrupt, power, and time. The runtime also makes a few APIs available to you automatically: the API provider itself; a memory allocator; a recurring task creator; and a way to interact with managed objects, arguments, and events. Beyond that, you can provide whatever APIs you need like GPIO and SPI. See the native API document for details on APIs. On top of providing several APIs, you must call all the functions under TinyCLR_Startup_* to properly initialize the system. The main.cpp provided in the repo that our existing ports use and the build system includes is a good starting point."
  },
  "tinyclr/tutorials/gpiochangereader.html": {
    "href": "tinyclr/tutorials/gpiochangereader.html",
    "title": "Gpio Change Reader",
    "keywords": "Gpio Change Reader Gpio Change Reader works in the current release. Documentation is coming soon. var reader = new GpioChangeReader(FEZ.GpioPin.A1, GpioPinDriveMode.InputPullUp); See this for now https://old.ghielectronics.com/docs/106/signal-capture"
  },
  "tinyclr/tutorials/gpiochangewriter.html": {
    "href": "tinyclr/tutorials/gpiochangewriter.html",
    "title": "Gpio Change Writer",
    "keywords": "Gpio Change Writer Gpio Change Writer works in the current release. Documentation is coming soon. var writer = new GpioChangeWriter(FEZ.GpioPin.A1, false); See this for now https://old.ghielectronics.com/docs/24/signal-generator"
  },
  "tinyclr/accessories/adafruit_display_shield.html": {
    "href": "tinyclr/accessories/adafruit_display_shield.html",
    "title": "Adafruit Display Shield",
    "keywords": "Adafruit Display Shield The Adafruit 1.8\" Color TFT Shield w/microSD and Joystick plugs right on top of FEZ, or any other Arduino-pinout compatible board. To use this shield, just plug it on top of your Arduno-pinout compatible board, like the FEZ . The driver is found here ."
  },
  "tinyclr/accessories/sparkfun_ardumoto_shield_kit.html": {
    "href": "tinyclr/accessories/sparkfun_ardumoto_shield_kit.html",
    "title": "Sparkfun Ardumoto Shield Kit",
    "keywords": "Sparkfun Ardumoto Shield Kit The sparkfun Sparkfun Ardumoto Shield Kit is a low cost way of building a robot, somewhat quickly. Plug the shield on top of your FEZ , or any other Arduino-pinout compatible board. You are now ready for some serious dancing! public static void Main() { var GPIO = GpioController.GetDefault(); var DIRA = GPIO.OpenPin(FEZ.GpioPin.D2); var DIRB = GPIO.OpenPin(FEZ.GpioPin.D4); DIRA.SetDriveMode(GpioPinDriveMode.Output); DIRB.SetDriveMode(GpioPinDriveMode.Output); var PWM1 = PwmController.FromId(FEZ.PwmPin.Controller1.Id); var PWM3 = PwmController.FromId(FEZ.PwmPin.Controller3.Id); PWM1.SetDesiredFrequency(5000); PWM3.SetDesiredFrequency(5000); var PWMA = PWM1.OpenPin(FEZ.PwmPin.Controller1.D3); var PWMB = PWM3.OpenPin(FEZ.PwmPin.Controller3.D11); PWMA.Start(); PWMB.Start(); // reverse direction every one second! // Do not foget the shield needs power. Thsi can come from VIN, meaning plug a power pack into your *duino board. PWMB.SetActiveDutyCyclePercentage(0.9); while (true) { DIRA.Write(GpioPinValue.High); DIRB.Write(GpioPinValue.High); System.Threading.Thread.Sleep(1000); //change speed PWMA.SetActiveDutyCyclePercentage(0.9); DIRA.Write(GpioPinValue.Low); DIRB.Write(GpioPinValue.Low); System.Threading.Thread.Sleep(1000); //change speed PWMA.SetActiveDutyCyclePercentage(0.5); } }"
  },
  "tinyclr/boards/netduino.html": {
    "href": "tinyclr/boards/netduino.html",
    "title": "netduino",
    "keywords": "netduino netduino 3 Originally a .NET Micro Framework product, netdunio 3 is available in three flavors: netduino 3 netduino 3 Ethernet netduino 3 WiFi Tip Currently the firmware is the same for all three devices and doesn't include any networking support. The netduino3 firmware is located here . To put the netduino in DFU mode, hold its one button down while plugging in the USB cable. Now follow the instructions at the STM32 bootloader page to generate and load a DFU file. When done, your PC should detect a TinyCLR device. You are now ready to start coding Tip The region set aside for RLI is 0x2002F000 - 0x2002FFF8. Pin Definitions This should help in getting to pins available on the netduino3 namespace GHIElectronics.TinyCLR.Pins { /// <summary>Board definition for the FEZCerbuinoNet.</summary> public static class Netduino3 { /// <summary>GPIO pin definitions.</summary> public static class GpioPin { /// <summary>Debug LED definition</summary> public const int Led = STM32F4.GpioPin.PA10; public const int PowerLed = STM32F4.GpioPin.PC13; /// <summary>SD Card Dectect definition</summary> public const int SdCardDetect = STM32F4.GpioPin.PB2; public const int SdCardPwrCtrl = STM32F4.GpioPin.PB1; /// <summary>GPIO pin.</summary> public const int D0 = STM32F4.GpioPin.PC7; /// <summary>GPIO pin.</summary> public const int D1 = STM32F4.GpioPin.PC6; /// <summary>GPIO pin.</summary> public const int D2 = STM32F4.GpioPin.PA3; /// <summary>GPIO pin.</summary> public const int D3 = STM32F4.GpioPin.PA2; /// <summary>GPIO pin.</summary> public const int D4 = STM32F4.GpioPin.PB12; /// <summary>GPIO pin.</summary> public const int D5 = STM32F4.GpioPin.PB8; /// <summary>GPIO pin.</summary> public const int D6 = STM32F4.GpioPin.PB9; /// <summary>GPIO pin.</summary> public const int D7 = STM32F4.GpioPin.PA1; /// <summary>GPIO pin.</summary> public const int D8 = STM32F4.GpioPin.PA0; /// <summary>GPIO pin.</summary> public const int D9 = STM32F4.GpioPin.PE5; /// <summary>GPIO pin.</summary> public const int D10 = STM32F4.GpioPin.PB10; /// <summary>GPIO pin.</summary> public const int D11 = STM32F4.GpioPin.PB15; /// <summary>GPIO pin.</summary> public const int D12 = STM32F4.GpioPin.PB14; /// <summary>GPIO pin.</summary> public const int D13 = STM32F4.GpioPin.PB13; /// <summary>GPIO pin.</summary> public const int A0 = STM32F4.GpioPin.PC0; /// <summary>GPIO pin.</summary> public const int A1 = STM32F4.GpioPin.PC1; /// <summary>GPIO pin.</summary> public const int A2 = STM32F4.GpioPin.PC2; /// <summary>GPIO pin.</summary> public const int A3 = STM32F4.GpioPin.PC3; /// <summary>GPIO pin.</summary> public const int A4 = STM32F4.GpioPin.PC4; /// <summary>GPIO pin.</summary> public const int A5 = STM32F4.GpioPin.PC5; /// <summary>Socket definition.</summary> public static class GoPort1 { /// <summary>Pin definition.</summary> public const int Pin3 = STM32F4.GpioPin.PD13; /// <summary>Pin definition.</summary> public const int Pin4 = STM32F4.GpioPin.PD8; /// <summary>Pin definition.</summary> public const int Pin5 = STM32F4.GpioPin.PD9; /// <summary>Pin definition.</summary> public const int Pin6 = STM32F4.GpioPin.PD0; /// <summary>LED definition.</summary> public const int Led = STM32F4.GpioPin.PE9; /// <summary>Power On definition.</summary> public const int PwrOn = STM32F4.GpioPin.PD7; } /// <summary>Socket definition.</summary> public static class GoPort2 { /// <summary>Pin definition.</summary> public const int Pin3 = STM32F4.GpioPin.PD14; /// <summary>Pin definition.</summary> public const int Pin4 = STM32F4.GpioPin.PE8; /// <summary>Pin definition.</summary> public const int Pin5 = STM32F4.GpioPin.PE7; /// <summary>Pin definition.</summary> public const int Pin6 = STM32F4.GpioPin.PD1; /// <summary>LED definition.</summary> public const int Led = STM32F4.GpioPin.PE11; /// <summary>Power On definition.</summary> public const int PwrOn = STM32F4.GpioPin.PD10; } /// <summary>Socket definition.</summary> public static class GoPort3 { /// <summary>Pin definition.</summary> public const int Pin3 = STM32F4.GpioPin.PD15; /// <summary>Pin definition.</summary> public const int Pin4 = STM32F4.GpioPin.PE1; /// <summary>Pin definition.</summary> public const int Pin5 = STM32F4.GpioPin.PE0; /// <summary>Pin definition.</summary> public const int Pin6 = STM32F4.GpioPin.PD2; /// <summary>LED definition.</summary> public const int Led = STM32F4.GpioPin.PB0; /// <summary>Power On definition.</summary> public const int PwrOn = STM32F4.GpioPin.PE14; } } /// <summary>Analog channel definition.</summary> public static class AdcChannel { /// <summary>Pin definition.</summary> public const int A0 = STM32F4.AdcChannel.Channel10; /// <summary>Pin definition.</summary> public const int A1 = STM32F4.AdcChannel.Channel11; /// <summary>Pin definition.</summary> public const int A2 = STM32F4.AdcChannel.Channel12; /// <summary>Pin definition.</summary> public const int A3 = STM32F4.AdcChannel.Channel13; /// <summary>Pin definition.</summary> public const int A4 = STM32F4.AdcChannel.Channel14; /// <summary>Pin definition.</summary> public const int A5 = STM32F4.AdcChannel.Channel15; } /// <summary>Uart port definition.</summary> public static class UartPort { /// <summary>Socket definition.</summary> public const string GoPort1 = STM32F4.UartPort.Usart3; /// <summary>Socket definition.</summary> public const string GoPort2 = STM32F4.UartPort.Uart7; /// <summary>Socket definition.</summary> public const string GoPort3 = STM32F4.UartPort.Uart8; /// <summary>UART D0 (RX) and D1 (TX).</summary> public const string Uart6 = STM32F4.UartPort.Uart6; } /// <summary>SPI Bus definition.</summary> public static class SpiBus { /// <summary>Socket definition.</summary> public const string GoPort1 = STM32F4.SpiBus.Spi4; public const string GoPort2 = STM32F4.SpiBus.Spi4; public const string GoPort3 = STM32F4.SpiBus.Spi4; public const string Spi2 = STM32F4.SpiBus.Spi2; } } } netduino 2 This board uses STM32F2, which is very similar to the STM32F4 used on the netduino 3. Porting TinyCLR OS to netduino 2 should not be very difficult. netduino 1 This board uses an Atmel micocontroller. The G400 uses an Atmel processor and can be a good starting point for posting TinyCLR OS."
  },
  "tinyclr/porting/native_apis.html": {
    "href": "tinyclr/porting/native_apis.html",
    "title": "Native APIs in TinyCLR",
    "keywords": "Native APIs in TinyCLR The TinyCLR runtime provides several built in APIs for you to use and allows you to register APIs of your own that other parts of the system can later use. These APIs are also exposed to managed code to query and use. Looking inside the TinyCLR.h file provided in the porting repo, you'll see several types defined under TinyCLR_Api_Type . Each of those types has an associated provider somewhere else in the file that defines its API. The GPIO API for example allows you to read and write a pin that that provider has. APIs can also be set as the default API for a given type. This makes it easier for managed code to get access to a resource without knowing the exact name. Notice also that APIs are all defined as a struct with a field to access the owning API and a number of function pointers that provide the API. Most function pointers in avaialble APIs take a pointer to the owning struct as a this reference, since one is not implicitly provided because they're not traditional classes with instance members. Ports will register various providers to expose some functionality to other parts of the system, including native code. Our GHIElectronics.TinyCLR.Devices library allows you to specify which native provider you want to use and will automatically acquire and interface with it. It also uses the default API functionality to power the various GetDefault methods. All access to APIs is handled by the TinyCLR_Api_Provider type that is passed to the TinyCLR_Startup_SoftResetHandler you register. The base function to find APIs is Find . You provide it an API name and the type that API should be and then it returns a TinyCLR_Api_Info type if it is found, or nullptr otherwise. The info struct contains information on the API like name, author, version, and type. It may also provide zero or more implementations specified by the Count field. When providing zero implementations, Implementation is nullptr . When providing one, Implementation points direcetly to the an instance of the corresponding API struct. If providing more than one, it points to an array of pointers, each of which its a pointer to an instance of the corresponding API struct. The functions SetDefaultSelector and GetDefaultSelector allow you to set and get the default selector used for a given API type. A selector takes the form \"{API name}{API index}\" (excluding the braces). This selector can be used by the FindBySelector method. It'll look for an API with the given name and then find the implementation with the given index, making sure not to go out of bounds for the specified API. FindByIndex does the same thing except you manually provide it with the name and index. FindByDefault finds the default selector for the type if present and returns the API implementation it corresponds to. You can also add your own API using the Add function. Just provide it with a pointer to a TinyCLR_Api_Info struct that is properly constructed and it can later be found by calls to Find . You can add APIs from within native interops or your own native code if you're building your own firmware. The below code shows you how to find and interact with the default GPIO provider in the system. It assumes one is present and that the API provider is available as a global variable in your code. void gpioTest() { auto gpioProvider = (const TinyCLR_Gpio_Provider*)apiProvider->FindDefault(apiProvider, TinyCLR_Api_Type::GpioProvider); if (gpioProvider != nullptr) { gpioProvider->AcquirePin(gpioProvider, 0); gpioProvider->WritePin(gpioProvider, 0, TinyCLR_Gpio_PinValue::High); gpioProvider->ReleasePin(gpioProvider, 0); } }"
  },
  "tinyclr/tutorials/gpio.html": {
    "href": "tinyclr/tutorials/gpio.html",
    "title": "General Purpose Input Output (GPIO)",
    "keywords": "General Purpose Input Output (GPIO) Microcontrollers include pins that can be controlled through software. They can be inputs or outputs, hence the name general purpose input output, or GPIO for short. Tip GPIO is handled by using GHIElectronics.TinyCLR.Devices.Gpio through the Devices NuGet package. Digital Outputs A digital output pin can be set to either high or low. There are different ways of describing these two states. High can also be called \"true\" or \"one;\" low can be called \"false\" or \"zero\". If the processor is powered from 3.3V, then the state high means that there is 3.3V on the output pin. It is not going to be exactly 3.3V but very close. When the pin is set to low then it is voltage is very close to zero volts. Warning Never connect two output pins together. If they are connected and one is high and the other is low, the entire processor can be damaged. Warning Digital pins on microcontrollers are weak. They can only be used to control small LEDs or transistors. Those transistors can in turn control devices with high power needs, like a motor. This example will blink an LED on FEZ. using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; class Program { static void Main() { GpioPin led = GpioController.GetDefault().OpenPin( GHIElectronics.TinyCLR.Pins.FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); while (true) { led.Write(GpioPinValue.High); Thread.Sleep(100); led.Write(GpioPinValue.Low); Thread.Sleep(100); } } } The previous example use the FEZ pin class that includes enumerate all pins available on FEZ. To blink an LED on a different hardware that does not have pins class, you can calculate the pin number easily. This example can work on any STM32 chip. As every port has 16 pins, we can calculate the pin as shown. using System; using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; class Program { static int PinNumber(char port, byte pin) { if (port < 'A' || port > 'E') throw new ArgumentException(); return ((port - 'A')*16) + pin; } static void Main() { var led = GpioController.GetDefault().OpenPin( //PinNumber('E', 2));// Buggy bot right flash //PinNumber('C', 4));// Buggy bot left flash //PinNumber('C', 12));// mini M4 //PinNumber('B', 2));// Cerbuino //PinNumber('A', 1));// clicker //PinNumber('E', 12));// clicker2 //PinNumber('E', 15));// Quail //PinNumber('A', 10));//netduino 3 //PinNumber('D', 5));//411 red Discovery //PinNumber('D', 15));//411 blue Discovery STM32F4.GpioPin.PA15); led.SetDriveMode(GpioPinDriveMode.Output); while(true) { led.Write(GpioPinValue.High); Thread.Sleep(100); led.Write(GpioPinValue.Low); Thread.Sleep(100); } } } Digital Inputs Digital inputs sense if the state of its pin is high or low based on the voltage. Every pin has a maximum & minimum supported voltage. For example, the typical minimum voltage on most pins is 0 volts; a negative voltage may damage the pin or the processor. Also, the maximum that can be supplied to most pins must be less than the processor power source voltage. Since most processors run on 3.3V, the highest voltage a pin should see is 3.3V; however, some processors that are powered by 3.3V are 5V tolerant; that is, they can accept up to 5V on their inputs. FEZ is 5V tolerant. Warning 5V-tolerant doesn't mean the processor can be powered by 5V. Only the input pins can tolerate 5V. Unconnected input pins are called \"floating\" as they are open for any surrounding noise, which can make the pin high or low. A resistor can be added to pull the pin high or low. Modern processors include internal pull-down or pull-up resistors, that are controlled by software. Note that the pull-up resistor doesn't make a pin high but it pulls it high. If nothing is connected then the pin is high by default. In this example, a button is connected between ground and the input pin. We will also enable the pull-up resistor, making that pin high when the button is not pressed, and low when the button is pressed. We will read the status of the button and pass its state to the LED. Tip Never use an infinite loop without giving the system time to think, use events or simply add a small sleep. using System; using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { GpioController GPIO = GpioController.GetDefault(); GpioPin led = GPIO.OpenPin(FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); GpioPin button = GPIO.OpenPin(FEZ.GpioPin.Btn1); button.SetDriveMode(GpioPinDriveMode.InputPullUp); while(true) { if(button.Read() == GpioPinValue.Low) { // button is pressed led.Write(GpioPinValue.High); } else { led.Write(GpioPinValue.Low); } Thread.Sleep(10);//always give the system time to think! } } } Tip if you are not using FEZ, see the Output Port example above to see how to determine the pin number. Digital Input Events In the previous example, the program just looped, and looped, and looped; each time checking the status of the pin attached to the button. The pin is checked maybe a million times before the button is pressed! Events solves this by invoking (calling) a method when an event occur. In this case the event is raised when the value on an input pin is changed. Meaning a button is pressed or released. A RisingEdge happen when the state of a pin changes from low to high, it \"rises\". This is the same button controlling LED example, but using events. using System; using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static GpioPin led; static void Main() { GpioController GPIO = GpioController.GetDefault(); led = GPIO.OpenPin(FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); GpioPin button = GPIO.OpenPin(FEZ.GpioPin.Btn1); button.SetDriveMode(GpioPinDriveMode.InputPullUp); button.ValueChanged += Button_ValueChanged; Thread.Sleep(-1);// sleep for low power, or do other tasks here! } private static void Button_ValueChanged(GpioPin sender, GpioPinValueChangedEventArgs e) { if (e.Edge == GpioPinEdge.FallingEdge) led.Write(GpioPinValue.Low); else led.Write(GpioPinValue.High); } } Warning Once you type += after the event, hit the tab key twice. Visual Studio will automatically create the event for you."
  },
  "tinyclr/tutorials/uart.html": {
    "href": "tinyclr/tutorials/uart.html",
    "title": "UART",
    "keywords": "UART Serial data ports, called UART, transfers data between two pins TXD (transmit) and RXD (receive). There is no clock between the two sides so they both need to agree on the data slow rate, called baudrate. Tip the TXD on one end (output) goes to the RXD on the other side (input) and vice versa. The easiest way to test UART is by wiring TXD to RXD and then any data transmitted is also received. This demo will send a number every half a second and wait for it on the receive end. Tip Serial uses Storage Streams to handle the data. Add the Storage NuGet package. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Storage.Streams; using GHIElectronics.TinyCLR.Devices.SerialCommunication; using GHIElectronics.TinyCLR.Pins; class Program { static DataReader serReader; static DataWriter serWriter; static void Sender() { byte b = 0; while(true) { serWriter.WriteByte(b++); serWriter.Store(); Debug.WriteLine(\"Sent: \" + b); Thread.Sleep(500); } } static void Main() { SerialDevice ser = SerialDevice.FromId(FEZ.UartPort.Usart1); ser.BaudRate = 115200; ser.ReadTimeout = TimeSpan.Zero; serReader = new DataReader(ser.InputStream); serWriter = new DataWriter(ser.OutputStream); Thread SenderT = new Thread(Sender); SenderT.Start(); while (true) { var i = serReader.Load(1); if(i>0) { byte b = serReader.ReadByte(); Debug.WriteLine(\"Recieved: \" + b); } Thread.Sleep(10);// always give the system time to think! } } } RS232 UART uses the processor's voltage levels for transferring data, called TTL voltage levels. Systems from back in the 80s needed a way to transfer data over long distances and so the UART levels changed to be -12V to +12V instead of TTL 0V to 3.3V on FEZ for example. This standard is called RS232. Some PCs still include serial ports to this day, but those are RS232 serial ports. A level shifter chip is needed to convert the voltages properly. Warning connecting your circuit to RS232 port without proper level shifter wil damage your circuit."
  },
  "tinyclr/roadmap.html": {
    "href": "tinyclr/roadmap.html",
    "title": "Roadmap",
    "keywords": "Roadmap Since TinyCLR OS is still in early alpha, we will be adding more libraries and functionality over time. Some of the things on our wish list in no particular order: USB host and client File system Graphics Secure networking Device updating Controller Area Network Runtime Loadable Procedures Generics .NET Standard The focus now is on making the core essentials available for many devices to prove the stability and portability of the core."
  },
  "tinyclr/boards/fez.html": {
    "href": "tinyclr/boards/fez.html",
    "title": "FEZ",
    "keywords": "FEZ FEZ is the official TinyCLR OS board and reference design. Its port, called FEZCLR , has the latest and greatest software, and should be used as a reference for starting new ports.  Find Hardware resources and other 3rd party software on the FEZ hardware page FEZ includes the GHI Electronics bootloader for making software update easier. The board comes pre-loaded with the loader. In case you erased the board and want to reload the bootloader, you can download it here . To load the bootloader file onto FEZ, use the DFU tools as explained here Using TinyCLR OS This requires loading the GHI Bootloader v2 and the FEZCLR firmware.  Loading Bootloader v2 The loader comes loaded by default and does not need to be updated. However, if the loader was erased and needs to be loaded: Download and save the bootloader file . Press and hold BOOT0 button while resetting the FEZ. Follow the instructions for Uploading DFU Files . Loading the Firmware Press and hold the BTN1 button down while resetting the board. Download the FEZCLR firmware and follow Loading the Firmware steps."
  },
  "tinyclr/boards/stm32_boards.html": {
    "href": "tinyclr/boards/stm32_boards.html",
    "title": "STM32 Boards",
    "keywords": "STM32 Boards The market is full of STM32 boards, especially the ones from ST Microelectronics, who offers several evaluation boards for their STM32 product families. The STM32F4 is the most popular family and it is what the FEZCLR reference firmware use. STM32F4 Discovery The ST Microelectronics STM32F411 Discovery board board works with the FEZCLR firmware. Simply, follow the FEZ board instructions. STM32F4 Nucleo The ST Microelectronics Nucleo-F401RE board works with the FEZCLR firmware. Simply, follow the FEZ board instructions. Tip The Nucleo board doesn't include a USB connector by default but has the needed connections needed to add a USB connector. See this TinyCLR Fork started with the FEZCLR port to create a port for Nucleo-F411RE port. The docs include instructions on how to wire USB to the discovery board. Other STM32F4 boards All STM32F4 microcontrollers are very similar. Any board (Discovery, Nucleo and others) with an 8Mhz crystal should simply run the FEZCLR firmware. However, you can simply change the crystal clock in the port and recompile the firmware. Start porting TinyCLR OS now."
  },
  "tinyclr/tutorials/intro.html": {
    "href": "tinyclr/tutorials/intro.html",
    "title": "TinyCLR Tutorials",
    "keywords": "TinyCLR Tutorials Here you will find tutorials covering different features of the TinyCLR OS. We try to keep the documents hardware-generic as much as possible but when we can't, we use FEZ as a reference. System Setup Follow these steps to setup your development machine. Starting a New Project Open Visual Studio, select File > New Project . There should be a TinyCLR option under Visual C# Click the \"OK\" button a project and program are created. The project has only one C# file, called Program.cs . C# source files are listed in the Solution Explorer window. If the Solution Explorer is not opened, use the View > Solution Explorer menu. Adding NuGet Packages TinyCLR OS uses NuGet packages, all libraries will be downloaded through NuGet. Because of this, there will be no SDK to install or machines to lock to specific versions. Simply use NuGet to download any needed version of any needed library on a per-project basis. To manage your NuGet packages, right click on your Project in the Solution Explorer and select Manage NuGet Packages Local Hosting NuGet packages Since TinyCLR OS is still so new, we haven't yet uploaded any packages to NuGet, so make sure to download the available libraries, extract the archive, and place them in a local NuGet feed. To do this you'll have to point Visual Studio to that local NuGet feed. After selecting Manage NuGet Packages select the \"Package Source\" Setting icon. Next you'll click the \"+\" to add an new Package source. Then select the location where the NuGet packages are stored locally, by pressing the ... icon. After Selecting the local folder where the downloaded NuGet packages are. You can select the \"Installed\" Tab to view the NuGet Packages installed. Selecting the \"Browse\" Tab will show all the NuGet packages located in your local NuGet feed. Those installed are noted with a GREEN check mark in front of the name. To install one of the packages. The last thing to do is accept the licensing agreement. And, that's it! You're now ready to start programming using TinyCLR OS. Fit the F5 key to build and deploy your application. (add more images for build and deploy and see a message on the output window)"
  },
  "brainpad/intro.html": {
    "href": "brainpad/intro.html",
    "title": "BrainPad Intro",
    "keywords": "BrainPad Intro The BrainPad is a revolutionized board for STEM and STEAM programs. It is very simple with much to offer out of the box, yet it is expandable. It is simple enough that a beginner can start with, but powerful that an advanced user can use it to expand their knowledge. It works with higher elementary kids to a retired person. Visit the official BrainPad website at www.brainpad.com This video shows a 6-year-old using a PC for the first time! And her first PC experience was in programming the BrainPad. The BrainPad design is based on the TinYCLR OS's official FEZ hardware. This means that the BrainPad will always receive the latest TinyCLR OS updates. The Future Plan We want your feedback. After years of work with hundreds of students, the BrainPad setup is simple and works through the TinyCLR OS ecosystem of boards. However, we are constantly working on making the use of the BrainPad yet simpler. This video shows one of the schools we worked with: The Community We have been working with local and online communities for years. Hop on our forum and share the discussion now. Or talk to us directly about our next local community gathering. Teachers and students like you are also interested in STEM & STEAM. Firmware Update Using TinyCLR Config (coming soon) Manual Loading the Firmware TinyCLR Config tool should be used to update the firmware. As a backup, use the instructions on the bootloader page for manual update. Here is a video that shows the manual firmware update. It also includes the steps needed for the old BrainPad and steps for updating the bootloader. The BrainPad uses the FEZCLR firmware Advance Hardware Info Advance hardware info are found on the hardware page. Also, learn about the magic TinyCLR OS . The Original BrainPad The Original (old) BrainPad (the large one) has been decommissioned. It has served well in working with schools to help us make a lot of decisions. Tip You can determine if you have the old BrainPad by looking for the traffic light in the top right corner. Only the old BrainPad has the traffic light. As a bonus, we will continue to support the original BrainPad with the new software. However, emulating the old display with the new software is severely effecting the system's performance. The display will not be enabled by default. We do not recommend the use of display on the old BrainPad. Using the Traffic Light The new software does not include the traffic light as the new BrainPad doesn't have a traffic light. However, this can be added as shown in this video."
  }
}