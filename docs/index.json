{
  "hardware/bootloader.html": {
    "href": "hardware/bootloader.html",
    "title": "Bootloader",
    "keywords": "Bootloader The GHI Bootloader is used to update the firmware on our devices. It is the first program to run and unless the device specific LDR pins are set (see device documentation for details), it will execute the firmware on the device if present. The bootloader communicates over a USB virtual serial port or a regular serial port. The interface used is usually controlled by a MODE pin. See your device specifications for details on interface configuration and selection and for which version of the bootloader it runs. Version 2.0 All commands and results are terminated with CR and LF (\\r\\n). \"OK.\" will be sent after each successful command. On startup, a banner is sent that is terminated by \"OK.\". Once the banner is received, you are free to enter any of the case-insensitive single-character commands described below. Most commands require confirmation. Send Y or y followed by a new-line to proceed or anything else to cancel. V: returns the current version. N: returns the current device type. E: erases all user sectors of the device. R: runs the firmware if present. B: increases the baud rate in serial mode to 921,600. X: upload a file to the device using 1K XMODEM. Only send *.ghi files meant for your device. U: upload a file to the device using 1K XMODEM. Only send *.glb files meant for your device. Version 1.0 Currently the EMX, G120, and G120E use this version of the bootloader. All results are terminated with LF (\\n). Commands are executed as soon as they entered without waiting for a new-line. \"BL\" or \"Done.\" will be sent after each command. On startup, a banner is sent that is terminated by \"BL\". Once the banner is received, you are free to enter any of the case-sensitive single-character commands described below. V: returns the current version. E: erases all user sectors of the device (* is sent while erasing). R: runs the firmware if present. B: increases the baud rate in serial mode to 921,600. X: upload a file to the device using 1K XMODEM. Only send *.ghi files meant for your device. The firmware is automatically run after a successful upload. GLB File Format The glb files that are loaded onto devices have some additional metadata that help the bootloader function in addition to the raw data itself. The first 1,024 bytes of a glb file is the upload header. Starting from offset 0 are the below fields. The rest of the header is currently reserved. 32 bit signature number that is unique for each device. 32 bit unsigned address in flash that this image should be copied to. 32 bit unsigned length of the image to flash rounded to the nearest 1,024 bytes. 16 bit CRC-CCITT of the image. After the upload header is the actual image to flash. If its length is not divisible by 1,024 bytes, it is padded until it is. For images that are meant to be bootable, the address in the upload header should be set to the entry point defined for the specific device. Bootable images have an additional 1,024 byte header at the beginning of the image that is used to verify the image before booting it. The boot image is also padded to the nearest 1,024 bytes. Starting from offset 0 are the below fields. The rest of the header is currently reserved. 32 bit signature number that is unique for each device. 32 bit unsigned address in flash that is the entry point the bootloader will invoke. 32 bit unsigned length of the boot image rounded to the nearest 1,024 bytes. 16 bit CRC-CCITT of the boot image bounded by the specified address and length."
  },
  "hardware/g120.html": {
    "href": "hardware/g120.html",
    "title": "G120",
    "keywords": "G120 G120 and G120E are .NET Micro Framework (NETMF) System on Modules. To use G120, follow the setup instructions on the NETMF into page (link). Resources: � Datasheet � Development board reference schematic G400D is compatible the GHI Electronics� Universal Compute Modules (UCM). Please consider one of these modules as a drop-in hardware replacement for G400d www.ghi.co/products/usm We recommend TinyCLR OS as a replacement for NETMF. Learn more about TinyCLR at www.tinyclr.com To help you evaluate TinyCLR OS, we are providing a preview firmware for G120. First, load the boot loader and then load this firmware, and then G120 will run TinyCLR-OS G120 Bootloader 2.1.0 (link) G120 TinyCLR OS firmware 0.5.0 (link)"
  },
  "hardware/intro.html": {
    "href": "hardware/intro.html",
    "title": "Hardware Introduction",
    "keywords": "Hardware Introduction These pages provide specific details on each of our devices such as technical specifications, schematics, manuals, and datasheets. Products are grouped under the chip family they're based on, so for example FEZ Panda II can be found under the USBizi."
  },
  "hardware/legacy/gadgeteering.html": {
    "href": "hardware/legacy/gadgeteering.html",
    "title": "Gadgeteering",
    "keywords": "Gadgeteering Gadgeteering was meant to extend Gadgeteer beyond NETMF. We are making our hardware and software available for reference only. All material is found at this github repository (link)"
  },
  "hardware/legacy/imaging.html": {
    "href": "hardware/legacy/imaging.html",
    "title": "Imaging",
    "keywords": "Imaging ALCAM-OEM is a small yet powerful imaging hardware. It could capture stills and videos to SD card and able to fetch images using serial commands. It started in a successful Kickstarter campaign https://www.kickstarter.com/projects/1359959821/alcam-oem Resources: get from https://www.ghielectronics.com/downloads/ALCAM/ We have worked on similar custom commercial designs with imaging needs but decided to proceed with a one-size-fits-all. Please contact us to discuss your imaging needs."
  },
  "hardware/legacy/netmf/fez_hydra.html": {
    "href": "hardware/legacy/netmf/fez_hydra.html",
    "title": "FEZ Hydra",
    "keywords": "FEZ Hydra FEZ Hydra is an open source gadgeteer board running NETMF. Please follow the Gadgeteer into instructions on using gadgeteer devices. Resources: � Schematics"
  },
  "hardware/legacy/netmf/intro.html": {
    "href": "hardware/legacy/netmf/intro.html",
    "title": "NETMF Intro",
    "keywords": "NETMF Intro .NET Micro Framework (NETMF) is a subset of the full .NET. Initiated by Microsoft for SPOT watches and then later open sourced. The latest working version Visual Studio working with our NETMF products is VS2013. GHI Electronics� TinyCLR OS is the upgrade path to NETMF on all our future products. Learn more about TinyCLR (www.tinyclr.com) To use NETMF, install these components: Visual Studio 20013 (community edition is also supported) NETMF VS2013 extension (we need to move locally) NETMF 4.3 libraries (move locally) GHI Electronics NETMF SDK. We recommend the latest (link) but older versions are available below for your convenience. (add a list of all SDKs, with release notes) https://www.ghielectronics.com/support/netmf/sdks"
  },
  "tinyclr/roadmap.html": {
    "href": "tinyclr/roadmap.html",
    "title": "Roadmap",
    "keywords": "Roadmap Since TinyCLR OS is still in early alpha, we will be adding more libraries and functionality over time. Some of the things on our wish list in no particular order: USB host and client File system Graphics Secure networking Device updating Controller Area Network Runtime Loadable Procedures Generics .NET Standard"
  },
  "tinyclr/boards/brainpad.html": {
    "href": "tinyclr/boards/brainpad.html",
    "title": "BrainPad",
    "keywords": "BrainPad The BrainPad is an aeducational STEM and STEAM focused board. Please read more on its hardware page http://docs.ghielectronics.com/hardware/brainpad.html"
  },
  "tinyclr/accessories/adafruit_display_shield.html": {
    "href": "tinyclr/accessories/adafruit_display_shield.html",
    "title": "Adafruit Display Shield",
    "keywords": "Adafruit Display Shield The Adafruit 1.8� Color TFT Shield w/microSD and Joystick https://www.adafruit.com/product/802 plugs right on top of FEZ, or any other Arduino-pinout compatible board. To use this shield, just plug it on top of your board (picture) The driver is found at (link). Import this NuGet Package, as explained here http://docs.ghielectronics.com/tinyclr/tutorials/intro.html You are now ready to use the shield Display18.Display n18 = new Display18.Display(FEZ.GpioPin.A0, FEZ.GpioPin.A1, FEZ.SpiBus.Spi1); int count = 0; while (true) { count++; n18.DrawLargeText(10, 10, \"Count \" + count, Display18.Color.Green); Thread.Sleep(30); }"
  },
  "tinyclr/accessories/seeed_grove_starter_kit.html": {
    "href": "tinyclr/accessories/seeed_grove_starter_kit.html",
    "title": "Seeed Grove Starter Kit",
    "keywords": "Seeed Grove Starter Kit Grove is a modular electronic platform for quick prototyping. Every module has one function, such as touch sensing, creating audio effect and so on. Just plug the modules you need to the base shield, then you are ready to test your idea buds. We have picked the Seeed Grove Starter Kit for Arduino https://www.seeedstudio.com/Grove-Starter-Kit-for-Arduino-p-1855.html as starting base but you can add additional Grove modules as well. (image) The included Grove modules plug into the included arduino shield. This shield works with FEZ, or any other arduino-pinout compatible board. Plug the shield on top of your board, and include this one of the NuGet drivers in our project, as explained here http://docs.ghielectronics.com/tinyclr/tutorials/intro.html The NuGet drivers are: � Grove Button � Grove This example that makes some noise! Buzzer buzz = new Buzzer(FEZ.GpioPin.D4); buzz.Beep(); Thread.Sleep(5000); buzz.TurnOn(); Thread.Sleep(1000); buzz.TurnOff(); while(true) { buzz.Beep(); Thread.Sleep(1000); } This example will read the temperature TemperatureSensor temp = new TemperatureSensor(FEZ.AdcChannel.A1); while(true) { Debug.WriteLine(\"-> \" + temp.ReadTemperature()); Thread.Sleep(1000); } This example will show some text on the character display LcdRgbBacklight lcd = new LcdRgbBacklight(); lcd.Clear(); lcd.SetBacklightRGB(100, 100, 0); lcd.BlinkBacklight(true); lcd.BlinkBacklight(false); lcd.Write(\"*** TinyCLR ***\"); Thread.Sleep(1000); lcd.SetCursor(0, 1); lcd.Write(\"Count:\"); int count = 0; while (true) { lcd.SetCursor(7, 1); lcd.Write(count.ToString()); count++; lcd.SetBacklightRGB(100, 100, (byte)count); Thread.Sleep(100); } Warning Pay attention to the 3.3V-5V switch on the shield. The rotary and temperature sensors only work with 3.3V but the RGB character display only works with 5V. Since the character display connects to I2C and only works with 5V. We have modified one of the I2C sockets to be always 5V. This allows us to keep the switch at 3.3V, leaving all other sockets at 3.3V. Warning These steps require some experience and will void your warranty! Start by cutting the power trace going to the last socket. (image) Now, add a wire from the socket directly to 5V. (image)"
  },
  "tinyclr/boards/clicker2.html": {
    "href": "tinyclr/boards/clicker2.html",
    "title": "Clicker 2",
    "keywords": "Clicker 2 The Clicker board brings the option of using hundreds of plug-and-play sensors and control modules, thanks to Mikro�s mikroBUS and the click modules. Learn more at https://shop.mikroe.com/clicker-2-stm32f4 Use the ST DFU tool to load the �????? firmware 0.5.0� onto your Clicker 2 board. When done, your PC should detect a TinyCLR device. You are now ready to start coding http://docs.ghielectronics.com/tinyclr/tutorials/intro.html"
  },
  "tinyclr/boards/netduino_3.html": {
    "href": "tinyclr/boards/netduino_3.html",
    "title": "Netduino 3",
    "keywords": "Netduino 3 Originally a .NET Micro Framework product, netdunio 3 is available in three flavors: netduino 3 http://www.netduino.com/netduino3/specs.htm netduino 3 Ethernet http://www.netduino.com/netduino3ethernet/specs.htm netduino 3 WiFi: http://www.netduino.com/netduino3wifi/specs.htm Use the ST DFU tool to load the �netduino3 firmware 0.5.0� onto your netduino 3. Currently the firmware is the same for all three devices and doesn�t include any networking support. When done, your PC should detect a TinyCLR device. You are now ready to start coding http://docs.ghielectronics.com/tinyclr/tutorials/intro.html"
  },
  "tinyclr/porting/native_interops.html": {
    "href": "tinyclr/porting/native_interops.html",
    "title": "Native Interops in TinyCLR",
    "keywords": "Native Interops in TinyCLR Interops allow you to write a class in managed code that is partially or entirely implemented in native code. This is useful for time critical tasks, things that would take too long in managed code, or interacting with native functionality not exposed through managed code. Keep in mind that while native code executes, all managed threads are blocked and if you crash in native code, managed code also crashes. To get started, create a TinyCLR project called InteropTest . In the project properties window, go to the TinyCLR OS tab. Check both the Generate native stubs for internal methods and the Generate bare native stubs checkboxes. Next, define your native API. Any method that you plan to implement in native code must be declared extern and be decorated with the System.Runtime.CompilerServices.MethodImpl attribute that is constructed with MethodImplOptions.InternalCall . Static and instance functions, static and instance constructors, finalizers, and property set and get bodies can all be implemented native. They can have any visibility, can take any number or types of parameters, and can return any type. For example: class MyNativeClass { private int field = 5; [MethodImpl(MethodImplOptions.InternalCall)] public extern string MyNativeFunc(uint param1); public extern int MyNativeProperty { [MethodImpl(MethodImplOptions.InternalCall)] get; } } Once you have your native API defined, build your project. In the output folder, find and open pe and then Interop . In there are three files that let TinyCLR connect the managed methods to the native methods. There are two main files that have the same name as your project. These define the entire API. Importantly, there is an object that has the assembly name, its checksum, and an array of its methods. The remaining file contains function stubs for each native method you need to implement from the MyNativeClass class. Each function has a single parameter of type TinyCLR_Interop_MethodData that can be found in the TinyCLR.h file. This type has two memebers: an opaque stack type that you pass to other interop functions and the API provider that gives you access to the runtime. You can use this API provider to find the interop provider. The interop provider allows you to read and write object fields, read arguments passed to the function, write to reference arguments, set the return value, raise other events, and create new managed objects. The following code shows reading from a field and setting it as the return value of the property: TinyCLR_Result InteropTest_InteropTest_MyNativeClass::MyNativeProperty___I4(const TinyCLR_Interop_MethodData md) { auto ip = (const TinyCLR_Interop_Provider*)md.ApiProvider.FindDefault(&md.ApiProvider, TinyCLR_Api_Type::InteropProvider); TinyCLR_Interop_ManagedValue self; TinyCLR_Interop_ManagedValue ret; TinyCLR_Interop_ManagedValue field; ret.Type = TinyCLR_Interop_ManagedValueType::I4; ip->GetThisObject(ip, md.Stack, self); ip->GetField(ip, self, InteropTest_InteropTest_MyNativeClass::FIELD___field___I4, field); ip->GetReturn(ip, md.Stack, ret); ret.Data.Numeric->I4 = field.Data.Numeric->I4; return TinyCLR_Result::Success; } Now you can compile these files using GCC. If you don't have GCC yet, see the porting guide to find out how to install GCC. To compile, you can use the sample build and linker scripts from here . Because TinyCLR can't currently dynamically relocate your code, you'll need to tell the scatterfile where to place the final binary image in memory. The sample files automatically place the image in the region dedicated for native interops for the FEZ . Make sure to adjust it for your device and that you don't overlap other images. Once you have a compiled image, look in the map file to find out where the interop definition variable Interop_InteropTest got placed. You'll need to pass this address to the managed function that registers the interop. In managed code, add the compiled binary image as a resource and use the Marshal class to copy it into the correct location in memory. Then call System.Runtime.InteropServices.Interop.Add and pass it the address of the Interop_InteropTest object from the map file. You need to do this every time your program runs and before you call any of the native methods in your interop class._"
  },
  "tinyclr/tutorials/gpiochangereaderwriter.html": {
    "href": "tinyclr/tutorials/gpiochangereaderwriter.html",
    "title": "Gpio Change Reader Writer",
    "keywords": "Gpio Change Reader Writer Gpio Change Reader Writer works in the current release. Documentation is coming soon."
  },
  "tinyclr/tutorials/gpiochangewriter.html": {
    "href": "tinyclr/tutorials/gpiochangewriter.html",
    "title": "Gpio Change Writer",
    "keywords": "Gpio Change Writer Gpio Change Writer works in the current release. Documentation is coming soon."
  },
  "index.html": {
    "href": "index.html",
    "title": "",
    "keywords": "Welcome to our future home for documentation. You will find a lot of missing or wrong information, but feel free to browse around while we clean things up. http://docs.ghielectronics.com is where you can find tutorials, samples, documentation, and API references for all GHI Electronics products. The available docs are not yet complete and those that are present are very rough, so please check back frequently."
  },
  "brainpad/courses/csharp/variables_and_nested_statements.html": {
    "href": "brainpad/courses/csharp/variables_and_nested_statements.html",
    "title": "Variables and Nested Statements",
    "keywords": "Variables and Nested Statements"
  },
  "brainpad/courses/vb/variables_and_nested_statements.html": {
    "href": "brainpad/courses/vb/variables_and_nested_statements.html",
    "title": "Variables and Nested Statements",
    "keywords": "Variables and Nested Statements"
  },
  "hardware/g30.html": {
    "href": "hardware/g30.html",
    "title": "G30",
    "keywords": "G30 The G30 System on Chip (SoC) is a low-cost chipsets running the .NET Micro Framework. It is programmed using Microsoft's Visual Studio using C# or Visual Basic which allows developers to take advantage of the extensive built-in NETMF libraries and GHI Electronics added extensions. To use G30 SoC, follow the setup instructions on the NETMF into page (link). Resources: � G30 Datasheet � G30 Development board reference schematic We recommend TinyCLR OS as a replacement for NETMF. Learn more about TinyCLR at www.tinyclr.com To help you evaluate TinyCLR OS, we are providing a preview firmware for G30. Load this firmware using our boot loader (link) and then G30 will run TinyCLR-OS G30 TinyCLR OS firmware 0.5.0 (link)"
  },
  "hardware/g80.html": {
    "href": "hardware/g80.html",
    "title": "G80",
    "keywords": "G80 The G80 System on Chip (SoC) is a low-cost chipsets running the .NET Micro Framework. It is programmed using Microsoft's Visual Studio using C# or Visual Basic which allows developers to take advantage of the extensive built-in NETMF libraries and GHI Electronics added extensions. To use G80 SoC, follow the setup instructions on the NETMF into page (link). Resources: � G80 Datasheet � G80 Development board reference schematic We recommend TinyCLR OS as a replacement for NETMF. Learn more about TinyCLR at www.tinyclr.com To help you evaluate TinyCLR OS, we are providing a preview firmware for G80. Load this firmware using our boot loader (link) and then G80 will run TinyCLR-OS G80 TinyCLR OS firmware 0.5.0 (link)"
  },
  "hardware/legacy/filesystem.html": {
    "href": "hardware/legacy/filesystem.html",
    "title": "File System",
    "keywords": "File System Since 2003, GHI Electronics have made several industry-first file system chipsets. Here is a list of chipsets and available resources. ALFAT datasheet uALFAT F40 F20 Firmare"
  },
  "hardware/legacy/raspberrypi_hats.html": {
    "href": "hardware/legacy/raspberrypi_hats.html",
    "title": "Raspberry Pi Hats",
    "keywords": "Raspberry Pi Hats Those HATS, FEZ HAT, FEZ Creme, FEZ ProtoPi, FEZ Utility, are accessories to the Raspberry Pi. Design files and driver sources are found at this GitHub repository."
  },
  "tinyclr/porting/native_apis.html": {
    "href": "tinyclr/porting/native_apis.html",
    "title": "Native APIs in TinyCLR",
    "keywords": "Native APIs in TinyCLR The TinyCLR runtime provides several built in APIs for you to use and allows you to register APIs of your own that other parts of the system can later use. These APIs are also exposed to managed code to query and use. Looking inside the TinyCLR.h file provided in the porting repo, you'll see several types defined under TinyCLR_Api_Type . Each of those types has an associated provider somewhere else in the file that defines its API. The GPIO API for example allows you to read and write a pin that that provider has. APIs can also be set as the default API for a given type. This makes it easier for managed code to get access to a resource without knowing the exact name. Notice also that APIs are all defined as a struct with a field to access the owning API and a number of function pointers that provide the API. Most function pointers in avaialble APIs take a pointer to the owning struct as a this reference, since one is not implicitly provided because they're not traditional classes with instance members. Ports will register various providers to expose some functionality to other parts of the system, including native code. Our GHIElectronics.TinyCLR.Devices library allows you to specify which native provider you want to use and will automatically acquire and interface with it. It also uses the default API functionality to power the various GetDefault methods. All access to APIs is handled by the TinyCLR_Api_Provider type that is passed to the TinyCLR_Startup_SoftResetHandler you register. The base function to find APIs is Find . You provide it an API name and the type that API should be and then it returns a TinyCLR_Api_Info type if it is found, or nullptr otherwise. The info struct contains information on the API like name, author, version, and type. It may also provide zero or more implementations specified by the Count field. When providing zero implementations, Implementation is nullptr . When providing one, Implementation points direcetly to the an instance of the corresponding API struct. If providing more than one, it points to an array of pointers, each of which its a pointer to an instance of the corresponding API struct. The functions SetDefaultSelector and GetDefaultSelector allow you to set and get the default selector used for a given API type. A selector takes the form \"{API name}{API index}\" (excluding the braces). This selector can be used by the FindBySelector method. It'll look for an API with the given name and then find the implementation with the given index, making sure not to go out of bounds for the specified API. FindByIndex does the same thing except you manually provide it with the name and index. FindByDefault finds the default selector for the type if present and returns the API implementation it corresponds to. You can also add your own API using the Add function. Just provide it with a pointer to a TinyCLR_Api_Info struct that is properly constructed and it can later be found by calls to Find . You can add APIs from within native interops or your own native code if you're building your own firmware. The below code shows you how to find and interact with the default GPIO provider in the system. It assumes one is present and that the API provider is available as a global variable in your code. void gpioTest() { auto gpioProvider = (const TinyCLR_Gpio_Provider*)apiProvider->FindDefault(apiProvider, TinyCLR_Api_Type::GpioProvider); if (gpioProvider != nullptr) { gpioProvider->AcquirePin(gpioProvider, 0); gpioProvider->WritePin(gpioProvider, 0, TinyCLR_Gpio_PinValue::High); gpioProvider->ReleasePin(gpioProvider, 0); } }"
  },
  "tinyclr/tutorials/dac.html": {
    "href": "tinyclr/tutorials/dac.html",
    "title": "DAC",
    "keywords": "DAC DAC works in the current release. Documentation is coming soon."
  },
  "brainpad/courses/csharp/threading_and_events.html": {
    "href": "brainpad/courses/csharp/threading_and_events.html",
    "title": "Threading and Events",
    "keywords": "Threading and Events"
  },
  "brainpad/courses/electronics/intro.html": {
    "href": "brainpad/courses/electronics/intro.html",
    "title": "Intro",
    "keywords": "Intro"
  },
  "README.html": {
    "href": "README.html",
    "title": "Docs",
    "keywords": "Docs This is the repository for all of our docs."
  },
  "hardware/legacy/intro.html": {
    "href": "hardware/legacy/intro.html",
    "title": "Legacy Intro",
    "keywords": "Legacy Intro We are, at GHI Electronics, the engineering the manufacturing behind all of our products. While some products have been made legacy and not recommended for new designs, we can still make any of these products available. There may be required minimum order quantity. We understand the seriousness of product longevity and will work with you till your product have been updated with one of the newer production products. Please contact us (link) to work together on helping you in upgrading your products. Pages in this section will include some support information."
  },
  "hardware/legacy/netmf/chipworkx.html": {
    "href": "hardware/legacy/netmf/chipworkx.html",
    "title": "ChipworkX",
    "keywords": "ChipworkX G400D is compatible the GHI Electronics� Universal Compute Modules (UCM). Please consider one of these modules as a drop-in hardware replacement for ChipworkX www.ghi.co/products/usm"
  },
  "hardware/legacy/netmf/emx.html": {
    "href": "hardware/legacy/netmf/emx.html",
    "title": "EMX",
    "keywords": "EMX Replaced by G120E. A NETMF System on Module. Was also the core of the original FEZ Cobra https://www.ghielectronics.com/downloads/FEZ/Cobra/ To use EMX, follow the setup instructions on the NETMF into page (link). Resources: � Datasheet � Development board reference schematic"
  },
  "tinyclr/release_notes.html": {
    "href": "tinyclr/release_notes.html",
    "title": "Alpha Release Notes",
    "keywords": "Alpha Release Notes 0.4.0 on 2017-05-10 Notes This release primarily fixes several bugs; implements more of the serial API; adds DataReader , DataWriter , and Marshal classes; and reworks a lot of the BrainPad API. A new Storage library was added that moves some large members (like DataReader ) out of Devices that you may not always needed. There is more to be added to this library down the road. SignalGenerator , SignalCapture , and PulseFeedback were renamed to match the Windows 10 counterparts. Their API will be updated to match as well in a future release. The Marshal class under System.Runtime.InteropServices can be used like the old Register and AddressSpace classes to read and write memory. It also adds allocating and releasing unmanaged memory from the managed side that can be manipulated from the other members. You can see a quick example on using the new serial API here . You must use either the DataReader and DataWriter classes or use the WindowsRuntimeBufferExtensions to manipulate a Buffer since the internal array is no longer publicly accessible to match the UWP API. Pay attention to the Load and Store members. You can't read before calling Load and writes do not get flushed until you call Store . There has been no change to the G120 and G400 bootloaders in this release so you do not need to update them if you already have them on your device from the 0.3.0 release. After flashing the firmware for the first time on any device, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . Libraries Changes Fixed GpioPin.ValueChanged sender parameter type to be GpioPin. Fixed many of the Debug and Trace members not functioning properly. Fixed LowLevelDevicesController.DefaultProvider throwing an exception when null instead of falling back to the built-in providers. Fixed SerialDevice.Read not respecting the ReadTimeout value. Fixed SerialDevice.BytesReceived and IBuffer.Length not getting updated when reading. Fixed the exception that was thrown in BrainPad.Buttons when buttons are pressed. Fixed the exception that was thrown when using BrainPad.ServoMotor . Fixed PWM glicthing other pins on the same controller when changing one pin. Fixed Thread.Sleep not always sleeping for the proper amount of time. Fixed SerialDevice.ErrorReceived not being raised. Added EventArgs . Added WindowsRuntimeBufferExtensions . Added DataReader and DataWriter . Added various From methods to TimeSpan . Added InteropServices.Marshal . Added EditorBrowsable attribute to several members inherited from object to the BrainPad members. Added GHIElectronics.TinyCLR.Storage with WindowsRuntimeBufferExtensions , DataReader , and DataWriter in it. Updated the underlying value of the SerialError enum. Updated the BrainPad to be based around instance properties rather than static classes. Updated SerialDevice.Read to only support InputStreamOptions.Partial and InputStreamOptions.None . Moved InputStreamOptions , IInputStream , IOutputStream , IBuffer , and Buffer to the GHIElectronics.TinyCLR.Core assembly. Moved the BrainPad expansion pins to the pins library. Improved support for the original BrainPad in the driver. Improved many of the BrainPad APIs. Removed the members of Buffer that don't conform to the UWP API. Renamed SignalGenerator to GpioChangeWriter , SignalCapture to GpioChangeReader , and PulseFeedback to GpioPulseReaderWriter . Known Issues The original BrainPad display does not currently work with the GHIElectronics.TinyCLR.BrainPad library. Software I2C can lock up the board if a slave device isn't connected or responds improperly. ServoMotors.SetMaxPulseWidth has an invalid range in the exception message. Formatting numbers that cross an assembly boundary can throw an exception. Opening a non-existent UART will only throw when it is used. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. Firmware Changes Fixed the G30 sometimes getting stuck during deployment. Added another sector to the G30 deployment region. Known Issues Rapidly pressing the buttons on the BrainPad may corrupt the display. Gpio interrupts may be slow when Visual Studio is connected. Some frequencies may round up instead of down if the requested frequency cannot be met. An 0xA2000000 error is sent over the debug transport when there is no deployment present. GpioChangeWriter does not generate proper signals for periods above 50ms on G400. Extension Changes Added a flag on the TinyCLR OS property page to control stub generation style. Added the DebuggerNonUserCode attribute to the startup code in BrainPad templates. Removed the public modifier from the C# application template. Known Issues The Visual Basic BrainPad template has a semicolon in the startup file. The device may not load drivers on Windows 7 preventing Visual Studio from seeing it. Some uses of pattern matching may crash the C# compiler. Visual Basic resources page generates an incompatible resource file. Visual Basic resource files are wrapped in a second namespace. When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. 0.3.0 on 2017-04-06 Notes This release has several API additions. Some were added as features themselves (software SPI, SignalGenerator, etc) while others were added to support certain features (the VB runtime, string.Format, MemoryStream and IntPtr for Drawing, etc). We're working to align ourselves with the various .NET Reference Sources available. You'll also see many new icons throughout, application templates for the BrainPad, and common item templates. The NuGet packages that have dependencies (such as on Core), now require the major and minor versions to match. For example, the 0.3.0 Devices library depends on Core [0.3.0,0.4.0). This is to further our use of SemVer so that the native interop checksum only changes in major and minor versions. See the NuGet docs for more information. The biggest addition is the drawing library. It was designed to mirror System.Drawing from the desktop. The basic API is there but there is still more work to be done. To support this, a DisplayController was added to the devices library to configure the display. Since there is no config yet you need to configure the display every time your program starts. A notable change from NETMF is calling flush on a drawing surface the size of the display will no longer draw to the display. Only drawing surfaces created from the FromHdc method passing in the Hdc value from the DisplayController will flush to the display. At this time, only bmp images are supported. Make sure you add a reference to GHIElectronics.TinyCLR.Drawing if using bitmap or font resources. Since it's in NuGet now it isn't automatically added. Support for Visual Basic has also been reenabled. One important thing to keep in mind is that there is no longer a Microsoft.VisualBasic assembly. We are using the embedded runtime option provided by Roslyn. It relies on several APIs being present in the core library. We added several of the key APIs needed to enable common usage scenarios. If you find you're getting cryptic compile errors from locations not in your code, let us know so we can evaluate what additional APIs are required. Since the UWP API only supports a controller wide frequency, we had to rework PWM a little bit. There is no longer one controller like there is for GPIO, instead one controller exists for each frequency source. On devices like the G30 and G80, this is a timer. On devices like the G400, there are independent registers for each channel (so unfortunately there will be one controller per channel). The pins library has been updated to organize PwmPin around controllers. SignalGenerator, SignalCapture, and PulseFeedback have also been added, but their APIs will change in a future release to match the UWP style. You can also now change what gets returned by GetDefault calls on the various controllers by updating LowLevelDevicesController.DefaultProvider. The Diagnostics namespace now matches the desktop version more closely. WriteLineIf and Assert were added to Debug and Trace was added as well. All methods on Debug and Trace are marked with the Conditional attribute as expected using the DEBUG and TRACE constants respectively. There's also now a Listeners property on each. This is a collection that you can add to so you can receive whatever is written to Trace or Debug by registering a class derived from TraceListener. As on the desktop, both Trace and Debug share the same listener collection. By default, the collection is populated with a listener that prints to the debug transport which is now at Debugger.Log. Collect and GetTotalMemory were added to GC. Note that GetTotalMemory returns the amount of memory used, not free, to match the desktop. We're investigating APIs to return the amount free. The last notable change is that we implemented IntPtr and UIntPtr. For now, they're only used as the type of the Hdc property in drawing. We expect them to be used in more places going forward. Since these two types map to native int and native unsigned int in the CLR and the managed compilers emit those types when they encounter IntPtr or UIntPtr, we have also added initial support for those types in the interpreter and runtime as well. Let us know if you encounter any weird or hard to explain runtime issues. This release also includes the firmware for the G400. It requires an updated bootloader from the one provided on the G400 bootloader installation page . Simply download the bootloader installer from the installation page and replace Bootloader.bin with the bootloader provided in the TinyCLR download package (making sure to rename it to Bootloader.bin). This updated bootloader can still be used to install the NETMF G400 firmware. It will eventually replace the one provided on the installation page. After flashing the firmware for the first time on any device, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . You can see some examples of the new APIs added in this release here . Libraries Changes PWM now has one controller per frequency source (usually a hardware timer) allowing different frequencies for each controller. string.Format should now work in all cases. Formatting numbers (ToString(\"N2\"), etc) should now work in all cases. I2C read/write partial functions now return the proper result. Opening non-existent ports no longer crashes the firmware. CultureInfo, NumberFormatInfo, and DateTimeFormatInfo now implement IFormatProvider. Primitives (except Boolean), DateTime, TimeSpan, Guid, and Enum now implement IFormattable. Added the == and != operators to Guid. Added a drawing library and display configuration. Added Enum.GetUnderlyingType Added LowLevelDevicesController and the provider API model for SPI, I2C, GPIO. Added SignalGenerator, SignalCapture, and PulseFeedback. Added software providers for I2C and SPI. Added CompilerGenerated, SuppressMessage, and In attributes. Added class target to Conditional attribute. Added FormatException and OverflowException. Added InvariantCulture and CurrentCulture to CultureInfo. Added FormattableString and FormattableStringFactory. Added Collect and GetTotalMemory to GC. Added MemoryStream. Added parts of the CodeContracts namespace. Added implementations to IntPtr and UIntPtr. Added Debugger.Log. Added Trace. Added Assert and WriteLineIf to Debug. Added listeners collection to Trace and Debug and a default listener mapped to Debugger.Log. Added BrainPad. Known Issues The sender parameter in the ValueChanged event on GpioPin is an instance of IGpioPinProvider, not GpioPin. Opening a non-existent UART will only throw when it is used. SignalGenerator may fail for small durations. An exception is thrown in BrainPad.Buttons when buttons are pressed. An exception is thrown when using BrainPad.ServoMotor. Some frequencies may round up instead of down if the requested frequency cannot be met. In the Debug class, only WriteLine(string) functions correctly. Firmware Changes G30 should no longer get stuck at waiting for device to initialize. PWM no longer takes 40 seconds to start on the G30 and G80. GPIO interrupts now work on the G120E. Added support for native int and native unsigned int in runtime Added G400 firmware. Known Issues Deploying to the G30 sometimes fails when writing a sector. An 0xA2000000 error is sent over the debug transport when there is no deployment present. Extension Changes Assemblies larger than sector size can now be deployed. Added Visual Basic support. Added BrainPad Application templates Added common item templates. Added icons throughout. NuGet packages now have a better range dependency for dealing with assembly checksums. Known Issues Visual Basic resources page generates an incompatible resource file. Visual Basic resource files are wrapped in a second namespace. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. 0.2.0 on 2017-03-07 Notes You cannot use projects you made for the 0.1.0 version. You must recreate them and re-add your code files because of the changes to the project templates to make them more closely align them with the desktop .NET templates -- you'll notice the only difference is a few properties which prevent inclusion of reference assemblies. The templates also use the .NET Framework 4.5.2 target framework. This is only for NuGet compatibility going forward and does not mean you can use other libraries targeting that framework. This was done in anticipation of broader project system support of the new PackageReference format currently used in .NET Core which fails with unknown target frameworks. The MSBuild package is no longer provided or required. The metadata processor tool has moved internally to the extension and is invoked during deployment to the device. This means that pe and pdbx files are no longer redistributed with their assemblies -- they appear in a pe folder under the output directory when you deploy. We have also rewritten how dependencies are detected for deployment. If you notice any weird failures around assembly resolution or deployment, let us know and send us the entire project as-is so we can diagnose it. The information displayed while deploying to the device has also been improved to show more information about what is going on and what stage the deployment is in. We've also reworked incremental deployment so that assemblies are deployed one to a flash sector (if space allows) to enable re-deploying only the assemblies that have changed on a sector by sector basis. This greatly increases deployment speed on devices which a large number of flash sectors allocated to deployment. This release also includes the firmware for the G120 and G120E. Because the current GHI bootloader on the G120 expects to load TinyBooter, we have provided a second stage bootloader with this preview that you must deploy using the existing GHI bootloader as if you were deploying TinyBooter. Once it is deployed and you restart the device, you'll notice that it starts our newer GHI bootloader 2.0 . You can then use this second bootloader to deploy the TinyCLR OS firmware. Asserting LDR0 will enter the second bootloader while asserting both LDR0 and LDR1 will enter the original bootloader and allow you to return to NETMF. After flashing the firmware the first time, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . Libraries Changes Formatting numbers works in more cases. The built in \"en\" culture has been removed. The dependency on GHIElectronics.TinyCLR.MsBuild has been removed. The pe and pdbx files are no longer included with the package. The package now targets the NET452 TFM. The duty cycle and polarity can now be set when the PWM pin is stopped. The frequency for the PWM controller can now be set at any time. PwmController.SetDesiredFrequency and PwmController.ActualFrequency now return the actual frequency the device was able to meet. The min and max frequency for PWM is now returned correctly. Removed analog input and output precision. Added G120, G120E, and FEZ Cobra III. CAN bus definitions now return a friendly name instead of an integer. Renamed Gpio to GpioPin, AnalogInput to AdcChannel, AnalogOutput to DacChannel, and PwmOutput to PwmPin. The pe and pdbx files are no longer included with the package. The package now targets the NET452 TFM. Known Issues Formatting numbers sometimes returns incorrect values. string.Format fails for non-trivial cases. There is only one PWM controller currently and since the Windows API has a controller-wide frequency, all PWM channels use the same frequency. Some frequencies may round up instead of down if the requested frequency cannot be met. Firmware Changes Added G120/G120E firmware. Flushing over USB is quicker. GPIO interrupts are now raised reliably. The maximum allocation is now 51,539,607,484 bytes. Known Issues PWM frequencies beyond 45MHz on G80 and 21MHz on G30 can fail. PWM may take up to a minute to start on G30 and G80. Extension Changes Breakpoints and the commands dependent on them now function properly. References no longer need a solution reload to deploy. The GHIElectronics.TinyCLR.MsBuild package has been removed. PDBX and PE files are now generated at deploy time. The deployment progress log shows more information. Incremental deployment is now better about deploying only what has changed. Debugging stops quicker after all threads in the application exit. The project templates now mirror the desktop templates much more closely. The Visual Studio projects now target .NET Framework v4.5.2. Known Issues Deploying an assembly larger than the flash sector size fails. An 0xA2000000 error will get sent over the debug transport whenever there is no app present. 0.1.0 on 2016-12-16 Known Issues After flashing the firmware the first time, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . Breakpoints and the commands dependent on them (run to cursor, others) do not work. As a work around, add a class library project called mscorlib to your solution and add a project reference to it or insert calls to System.Diagnostics.Debugger.Break. References can fail to deploy unless a solution close and open occurs after adding the reference. Re-deploying immediately after stopping debugging can fail. Try again to work around it. There is only one PWM controller currently and since the Windows API has a controller-wide frequency, all PWM channels use the same frequency. PwmController.SetDesiredFrequency must be called before any call to PwmController.OpenPin. PwmPin.SetActiveDutyCyclePercentage must be called after Start. GPIO interrupts do not always trigger. PWM may take up to a minute to start. Formatting numbers yields incorrect results in some cases. string.Format fails for non-trivial cases. Only Core, Devices, and Pins libraries are available. Only G30 and G80 are available. Packages are not uploaded to the NuGet public gallery. Additions TimeSpan.Total* {int/long/double/...}.TryParse(string source, out value) string.Format(string format, param object[] args) System.Diagnostics.WriteLine(string message)"
  },
  "tinyclr/accessories/mikroeelectronika_click.html": {
    "href": "tinyclr/accessories/mikroeelectronika_click.html",
    "title": "MikroeElectronika Click",
    "keywords": "MikroeElectronika Click Through Mikro Electronica�s mikroBUS standard https://www.mikroe.com/mikrobus/ , hundreds of Mikro�s click modules https://shop.mikroe.com/click can be easily connected to your board. The BrainPad, Clicker, Clicker2 and Quail bards all have sockets for plugging click modules. You can also use FEZ, or any other Arduino-pinout compatible board through the Arduino UNO Click shield https://shop.mikroe.com/arduino-uno-click-shield Current available Click module drivers: FM Radio click https://shop.mikroe.com/fm-click Touch Clamp https://shop.mikroe.com/touchclamp-click Alcohol sensor: https://shop.mikroe.com/alcohol-click This example shows the FM Radio working with the FEZ through the uno click shield (picture) (code)"
  },
  "tinyclr/accessories/pololu_zumo_robot.html": {
    "href": "tinyclr/accessories/pololu_zumo_robot.html",
    "title": "Pololu Zumo Robot",
    "keywords": "Pololu Zumo Robot The Arduino Zumo Robot from Pololu is one of our favorites, especially the pre-assembled version. https://www.pololu.com/category/169/zumo-robot-for-arduino Drop your FEZ on top of the Zumo Robot, or any other Arduino-compatible board, and you are ready to make the robot follow lines and dance around. Thanks to FEZ�s built in WiFi, you can drive the robot right from your phone. The driver is found at (link). Import this NuGet Package, as explained here http://docs.ghielectronics.com/tinyclr/tutorials/intro.html You are now ready for some serious dancing! public static void Main() { bool state = false; while (!ZumoBot.ButtonIsPressed()) { state = !state; ZumoBot.SetLed(state); ZumoBot.Beep(); Thread.Sleep(500); } Thread.Sleep(300); ZumoBot.SetLed(false); Thread.Sleep(300); ZumoBot.SetLed(true); Thread.Sleep(300); ZumoBot.SetLed(false); Thread.Sleep(300); ZumoBot.SetLed(true); while (true) { long left = ZumoBot.Reflectors.GetLevel(0); long right = ZumoBot.Reflectors.GetLevel(5); //Debug.WriteLine(\">\" + ZumoBot.Reflectors.GetLevel(0)); //System.Diagnostics.Debug.WriteLine(\"l: \" + left + \" r: \" + right); if (left < 8000 && right < 8000) { ZumoBot.Motors.Move(40, 40); } else { // backup and turn ZumoBot.Motors.MoveBackward(); Thread.Sleep(500); ZumoBot.Motors.Stop(); Thread.Sleep(1000); ZumoBot.Motors.TurnLeft(); Thread.Sleep(500); ZumoBot.Motors.Stop(); Thread.Sleep(1000); } Thread.Sleep(30); } }"
  },
  "tinyclr/tutorials/display.html": {
    "href": "tinyclr/tutorials/display.html",
    "title": "Display",
    "keywords": "Display Displays works in the current release. Documentation is coming soon."
  },
  "tinyclr/tutorials/pwm.html": {
    "href": "tinyclr/tutorials/pwm.html",
    "title": "PWM",
    "keywords": "PWM Pulse Width Modulation (PWM) is a very import feature found in most microcontrollers. PWM is a pulse that is repeated and generated by the internal hardware. The ratio of the pulse width and its frequency is called duty cycle. Through software, you can control the pulse�s frequency and duty cycle. Tip we use usually use GetDefault() for most peripherals. For example, there is only one GPIO controller on most systems. This is not the case with PWM. Never use the Default controller and always> select the proper channel on the correspondent controller. Tip PWM2.3 is channel 3 on controller 2 Energy Level PWM is perfect for dimming an LED or slowing down a motor. This is done by turning power on and off, at a high speed. When power is on half the time and off half the time, only half the energy is transferred, to the LED or a motor. This demo will fade the LED in and out using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { PwmController Controller4 = PwmController.FromId(FEZ.PwmPin.Controller4.Id); PwmPin led = Controller4.OpenPin(FEZ.PwmPin.Controller4.Led1); Controller4.SetDesiredFrequency(10000); double duty = 0.5, speed = 0.01; led.Start(); while (true) { led.SetActiveDutyCyclePercentage(duty); duty += speed; if (duty <= 0 || duty >= 1) duty *= -1;//invert dirrection Thread.Sleep(10);// always give the system time to think! } } } Musical Tones Music notes have specific frequencies; C for example is about 261Hz. Plugging these numbers into an array and knowing the length of each tone is all that is needed to play some simple music. When playing notes by changing the frequency, keep thee duty cycle set to 0.5. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Pins; class Program { const int NOTE_C = 261; const int NOTE_D = 294; const int NOTE_E = 330; const int NOTE_F = 349; const int NOTE_G = 392; const int WHOLE_DURATION = 1000; const int EIGHTH = WHOLE_DURATION / 8; const int QUARTER = WHOLE_DURATION / 4; const int QUARTERDOT = WHOLE_DURATION / 3; const int HALF = WHOLE_DURATION / 2; const int WHOLE = WHOLE_DURATION; //make sure the two below arrays match in length. each duration element corresponds to //one note element. static int[] note = { NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_E, NOTE_D, NOTE_D, NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_D, NOTE_C, NOTE_C}; static int[] duration = { QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, HALF, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, WHOLE}; static void Main() { PwmController Controller1 = PwmController.FromId(FEZ.PwmPin.Controller1.Id); PwmPin tones = Controller1.OpenPin(FEZ.PwmPin.Controller1.D0); tones.SetActiveDutyCyclePercentage(0.5); tones.Start(); while (true) { for (int i = 0; i < note.Length; i++) { Controller1.SetDesiredFrequency( note[i]); Thread.Sleep(duration[i]); } Thread.Sleep(100); } } } Servo Motors Servo motors are controlled by a repeated pulse. The pulse is generated every 20ms. This pulse will have a width between 1ms and 2ms, for min and max. Positional servos will go to a psecific derction based on the pulse width. Full rotational servos can be controlled, speed and direction, through this pulse, where 1.5ms pulse will stop, 1ms is full speed and 1ms is reverse full speed. Tip most servos will have a 1.25ms min and 1.75max. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { PwmController Controller1 = PwmController.FromId(FEZ.PwmPin.Controller1.Id); PwmPin servo = Controller1.OpenPin(FEZ.PwmPin.Controller1.D0); Controller1.SetDesiredFrequency(1 / 0.020);//a pulse every 20ms double maxPulseLength = 1.75; double minPulseLength = 1.25; double position = 90; double speed = 0.5; servo.Start(); while (true) { double duty = ((position / 180.0) * (maxPulseLength / 20 - minPulseLength / 20)) + minPulseLength / 20; servo.SetActiveDutyCyclePercentage(duty); position += speed; if (position <= 0 || position >= 180) duty *= -1;//reverse dirrection Thread.Sleep(10);// always give the system time to think! } } }"
  },
  "tinyclr/tutorials/spi.html": {
    "href": "tinyclr/tutorials/spi.html",
    "title": "SPI",
    "keywords": "SPI SPI uses three, sometimes four, wires for transferring data. The bus on SPI consists of a single master and one or more slaves. The master will send clock to the salves over the SCK pin. It will also send date over MOSI pin, while reading incoming data on the MISO pin. The SCK clock is used to determine how fast the data is moved. If you know electronics, this is simply a shift register. The master selects which slave it will swap the data with using the SSEL pin, sometimes called CS. In its simplest terms, the master will swap data between itself and the slave. You cannot write data without reading at the same time. However, a lot of time you need to write data and you do not care about the incoming data. For that, there is a Write method. But keep in mind that the Write method is also reading, and discarding, whatever the slave is sending. Tip Some SPI devices (slaves) can have more than one select-pin, like the VS1053 MP3 decoder chip that uses one select pin for data and other for commands. Both share the 3 data transfer pins (SCK, >MOSI, MISO). Tip SPI needs more wires than other similar buses but it can transfer data very fast. A 50Mhz clock is possible on SPI, that is 50 million bits in one second. Tip Note that a board running TinyCLR OS is always a SPI masters, not slaves. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Spi; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var settings = new SpiConnectionSettings(0x1C)// the slave's select pin { Mode = SpiMode.Mode1, ClockFrequency = 4* 1000 * 1000,//4Mhz DataBitLength = 8, }; var device = SpiDevice.FromId(FEZ.SpiBus.Spi1, settings); device.Write(new byte[] { 1, 2 });// write something device.TransferSequential(...)// this is good for reading registers device.TransferFullDuplex(...)// this is the only one that trully represents how SPI works } }"
  },
  "brainpad/expandability.html": {
    "href": "brainpad/expandability.html",
    "title": "Expandability",
    "keywords": "Expandability Additional functionality can be added to the BrainPad through its expansion headers. This can be done though a plug-and-play click modules or by direct wiring. Plug-and-play Click Modules This is an easy option as these modules simply plug in. There are hundreds of available options https://shop.mikroe.com/click (picture) This page covers further details http://docs.ghielectronics.com/tinyclr/accessories/click...what is the link in previous email? Direct Wiring This option is only recommended for advanced users with electronics background. (picture) As a demo, we built this robot with a chassis we ordered from Amazon http://a.co/dwzywoI The continuous servo motors simply plug in. Pay attention to wires, where the orange wire should be connected to the pin labeled with ~. We then used a breadboard with an ultrasonic distance sensor. This will be used to detect objects to backup the robot. BrainPad.ServoMotors.ServoOne.ConfigureAsContinuous(false); BrainPad.ServoMotors.ServoTwo.ConfigureAsContinuous(true); BrainPad.Display.DrawSmallTextAndShowOnScreen(0, 20, \"Press Left\"); while (BrainPad.Buttons.IsLeftPressed() == false) { // Beep BrainPad.Buzzer.Beep(); BrainPad.Wait.Seconds(0.3); } BrainPad.Display.ClearScreen(); BrainPad.Display.DrawSmallTextAndShowOnScreen(40, 20, \"Go!\"); //BrainPad.ServoMotorsIsServoTwoInverted(true); bool dirrection = true; BrainPad.ServoMotors.ServoOne.Set(50); BrainPad.Display.DrawSmallTextAndShowOnScreen(40, 20, \"Reflect\"); // using reflector bool use_builtin = true; if (use_builtin) { GpioPulseReaderWriter echolen = new GpioPulseReaderWriter( GpioPulseReaderWriter.Mode.EchoDuration, true, 10, BrainPad.Expansion.GpioPin.Mosi, true, BrainPad.Expansion.GpioPin.Miso); Move(100, 60); //dance! while (true) { double l = echolen.Read(); BrainPad.Display.DrawSmallTextAndShowOnScreen(0, 0, l.ToString()); if (l < 600) { Move(-100, -100); BrainPad.Wait.Seconds(1); Move(-100, 100); BrainPad.Wait.Seconds(0.5); Move(100, 60); } BrainPad.Wait.Seconds(0.3); } }"
  },
  "hardware/legacy/gadgeteer.html": {
    "href": "hardware/legacy/gadgeteer.html",
    "title": "Gadgeteer",
    "keywords": "Gadgeteer .NET Gadgeteer that was initiated by Microsoft Research and taken to production by GHI Electronics. Gadgeteer had a great few year run, loved for its plug-and-play mainboard and modules. To use .NET Gadgeteer, install the latest NETMF software as explained in the NETMF intro page (link). Then Also install the .NET Gadgeteer core (make local). (Is it okay to install this after our SDK?) The Gadgeteer core source code is available at (make local?) All design files and driver source code for gadgeteer is available at (link) The Gadgeteer graphical designer was never made available by Microsoft."
  },
  "hardware/legacy/netmf/fez_cerberus.html": {
    "href": "hardware/legacy/netmf/fez_cerberus.html",
    "title": "FEZ Cerberus",
    "keywords": "FEZ Cerberus The Cerb family included FEZ Cerberus, FEZ Cerbuino and FEZ Cerb40. All these open source devices worked with NETMF To use any of the cerb-family boards, follow the setup instructions on the NETMF into page (link). Resources: � Schematic � Development board reference schematic G400D is compatible the GHI Electronics� Universal Compute Modules (UCM). Please consider one of these modules as a drop-in hardware replacement for G400d www.ghi.co/products/usm We recommend TinyCLR OS as a replacement for NETMF. Learn more about TinyCLR at www.tinyclr.com To help you evaluate TinyCLR OS, we are providing a preview firmware for G30. Load this firmware using our boot loader (link) and then these devices will run TinyCLR-OS FEZ Cerb firmware 0.5.0 (link) The FEZ Cerberus family of boards, FEZ Cerberus, FEZ Cerbuino and the Cerb40 were originally made to run .NET Micro Framework. To Like for the FEZ board, we are providing a bootloader to make firmware update easier. This loader needs to be loaded once and then TinyCLR OS firmware update is a lot easier. Use the ST DFU tool to load the �cerb loader 2345� onto your Cerb board. When done, your PC should detect a virtual COM port. You can now load the �cerb firmware 0.5.0� onto your board. Loadong the firmware us done using a terminal aosftware with XMODEM. More info is found on our bootloader page http://docs.ghielectronics.com/hardware/bootloader.html You are now ready to start coding http://docs.ghielectronics.com/tinyclr/tutorials/intro.html"
  },
  "tinyclr/intro.html": {
    "href": "tinyclr/intro.html",
    "title": "TinyCLR OS Introduction",
    "keywords": "TinyCLR OS Introduction TinyCLR OS is our take on the .NET Micro Framework to enable managed .NET development using Microsoft's Visual Studio on embedded devices -- including debugging! All you need to get started is Visual Studio, a TinyCLR device, and a USB cable. Keep in mind that it is still an alpha so there is still a lot more to come. TinyCLR OS is made for .NET developers. Threading, memory management, timers, event handlers, and many more exist in TinyCLR OS just like they do on full .NET. For interacting with hardware, TinyCLR OS has an API similar to the Windows 10 IoT Core Extensions API you may already be familiar with. GPIO, UART, SPI, I2C, ADC, DAC, PWM, and more are all available for you to interact with the embedded world. Better yet, all libraries are available through NuGet. Because of this, there will be no SDK to install or machines to lock to specific versions. Simply use NuGet to download any needed version of any needed library on a per-project basis. If you don't already have Visual Studio 2017, download and install the freely available Visual Studio Community 2017 . Download and install the TinyCLR OS Visual Studio extension . Connect your device to your PC using a USB cable. Don't have a TinyCLR OS device yet? Take a look at the FEZ : the board made for TinyCLR OS. Start Visual Studio and create a new TinyCLR Application under C# > TinyCLR . New to Visual Studio or C#? Take a look at the getting started guide from Microsoft . Add some code and press F5 to deploy and begin debugging your application! Since TinyCLR OS is still so new, we haven't yet uploaded any packages to NuGet, so make sure to download the available libraries , extract the archive, and place them in a local NuGet feed . If you need to update the firmware on your device, download the firmware and follow the instructions to update your device. If you're an existing user of NETMF and still want to use it in addition to TinyCLR OS, don't worry. TinyCLR OS is completely independent of NETMF and works side-by-side with no issues or changes required. TinyCLR OS is still very new and there is a lot more we have planned for it so some libraries and functionality may be missing. Take a look at the release notes to see what's new and roadmap to see what we have planned. Interested in running TinyCLR OS on your own device? Take a look at the porting guide for information on how to get started."
  },
  "tinyclr/accessories/intro.html": {
    "href": "tinyclr/accessories/intro.html",
    "title": "TinyCLR OS Accessories",
    "keywords": "TinyCLR OS Accessories There are thousands of accessories that can be used with boards ( http://docs.ghielectronics.com/tinyclr/boards/intro.html ) supported by TinyCLR OS, especially FEZ http://docs.ghielectronics.com/hardware/fez.html . However, we have hand picked a few of our favorites and then built the necessary drivers for them. Have a list of your own and want to contribute? Talk to us, directly on through the community forum."
  },
  "brainpad/intro.html": {
    "href": "brainpad/intro.html",
    "title": "BrainPad Intro",
    "keywords": "BrainPad Intro"
  },
  "tinyclr/boards/fez.html": {
    "href": "tinyclr/boards/fez.html",
    "title": "FEZ",
    "keywords": "FEZ FEZ is the official TinyCLR OS board. Its port has the latest and greatest software and should be used as a reference for starting new ports. Read more on the hardware page http://docs.ghielectronics.com/hardware/fez.html"
  },
  "tinyclr/boards/intro.html": {
    "href": "tinyclr/boards/intro.html",
    "title": "Boards Intro",
    "keywords": "Boards Intro While TinyCLR OS can be ported to other devices, we are providing a ready port for few popular boards. The FEZ board is the official TinyCLR OS board. It will always have the latest and greatest and should be used as a reference for new ports."
  },
  "tinyclr/porting/contributing.html": {
    "href": "tinyclr/porting/contributing.html",
    "title": "Contributing",
    "keywords": "Contributing We are taking contributions to the TinyCLR OS ports and documentation, but we don't have an established process just yet, so standard contributing practices apply. Create a fork of the repo, create a new branch from dev, work on your changes, then submit a PR. Make sure to follow the existing style for the project and keep your changes easily reviewable. Your changes will need to be licensed under Apache 2 and you need to sign a Contributor License Agreement with us before your PR can be accepted."
  },
  "tinyclr/porting/intro.html": {
    "href": "tinyclr/porting/intro.html",
    "title": "Porting TinyCLR",
    "keywords": "Porting TinyCLR TinyCLR OS can be ported to new devices. We provide the precompiled .NET interpreter and runtime for several architectures. Currently only Cortex M4 is supported, but more will be supported in the future. To get started we'll build the FEZ firmware. Clone the ports repo to your computer. Download and install GCC . The latest version we have tested is 6-2017-q2-update . Download and extract the contents of CMSIS into the CMSIS folder of the cloned repo. While the file extension is *.pack , it's actually a zip that you can extract once you rename it to *.zip . Download and extract the latest TinyCLR OS Core Library into the Core folder of the cloned repo. Open a command prompt, change the directory to the cloned repo, and then execute build.bat FEZ . The compiled firmware can then be found in the repo directory under build\\release\\FEZ . The build system automatically produces firmware images in hex format (.hex), a raw binary (.bin), a binary meant to be loaded by our GHI Bootloader with its U command (.glb), and, for some devices, a binary meant to be loaded by the same bootloader with the X command (.ghi). For the FEZ firmware we built, flash the FEZ.glb to your board following the instructions on the bootloader page. When you restart it, it should be running TinyCLR OS and you can deploy to it from Visual Studio. To create a new firmware for a board that a port already exists for, you just need to create a new folder under Devices to define your board. You can do this easily by copying an existing board like the FEZ and making the changes you need for your board. Make sure you update the scatterfile to place the final firmware image in memory where it needs to be. The FEZ scatterfile expects the GHI Bootloader to be present so it places the firmware where the GHI Bootloader expects to load it from. If you're not using the GHI Bootloader, you need to place the firmware image at the start of flash. To port to a new board, make sure it is one of the architectures that we have made a core library available for. Then, like above, you'll need to make a new folder for your device under the Devices folder. You'll also need to create a new folder under Targets that implements the needed APIs. The TinyCLR runtime requires you to provide a few APIs for it to function correctly: deployment, interrupt, power, and time. The runtime also makes a few APIs available to you automatically: the API provider itself; a memory allocator; a recurring task creator; and a way to interact with managed objects, arguments, and events. Beyond that, you can provide whatever APIs you need like GPIO and SPI. See the native API document for details on APIs. On top of providing several APIs, you must call all the functions under TinyCLR_Startup_* to properly initialize the system. The main.cpp provided in the repo that our existing ports use and the build system includes is a good starting point."
  },
  "tinyclr/tutorials/gpio.html": {
    "href": "tinyclr/tutorials/gpio.html",
    "title": "General Purpose Input Output (GPIO)",
    "keywords": "General Purpose Input Output (GPIO) Microcontrollers include pins that can be controlled through software. They can be inputs or outputs, hence the name general purpose input output, or GPIO for short. Tip GPIO is handled by using GHIElectronics.TinyCLR.Devices.Gpio through the Devices NuGet package. Digital Outputs A digital output pin can be set to either high or low. There are different ways of describing these two states. High can also be called \"true\" or \"one;\" low can be called \"false\" or \"zero\". If the processor is powered from 3.3V, then the state high means that there is 3.3V on the output pin. It is not going to be exactly 3.3V but very close. When the pin is set to low then it is voltage is very close to zero volts. Warning Never connect two output pins together. If they are connected and one is high and the other is low, the entire processor can be damaged. Warning Digital pins on microcontrollers are weak. They can only be used to control small LEDs or transistors. Those transistors can in turn control devices with high power needs, like a motor. This example will blink an LED on FEZ. using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; class Program { static void Main() { GpioPin led = GpioController.GetDefault().OpenPin( GHIElectronics.TinyCLR.Pins.FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); while (true) { led.Write(GpioPinValue.High); Thread.Sleep(100); led.Write(GpioPinValue.Low); Thread.Sleep(100); } } } The previous example use the FEZ pin class that includes enumerate all pins available on FEZ. To blink an LED on a different hardware that does not have pins class, you can calculate the pin number easily. This example can work on any STM32 chip. As every port has 16 pins, we can calculate the pin as shown. using System; using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; class Program { static int PinNumber(char port, byte pin) { if (port < 'A' || port > 'E') throw new ArgumentException(); return ((port - 'A')*16) + pin; } static void Main() { GpioPin led = GpioController.GetDefault().OpenPin( //PinNumber('B', 2));// Cerbuino //PinNumber('A', 10));//netduino 3 //PinNumber('D', 5));//411 red Discovery PinNumber('D', 15));//411 blue Discovery led.SetDriveMode(GpioPinDriveMode.Output); while(true) { led.Write(GpioPinValue.High); Thread.Sleep(100); led.Write(GpioPinValue.Low); Thread.Sleep(100); } } } Digital Inputs Digital inputs sense if the state of its pin is high or low based on the voltage. Every pin has a maximum & minimum supported voltage. For example, the typical minimum voltage on most pins is 0 volts; a negative voltage may damage the pin or the processor. Also, the maximum that can be supplied to most pins must be less than the processor power source voltage. Since most processors run on 3.3V, the highest voltage a pin should see is 3.3V; however, some processors that are powered by 3.3V are 5V tolerant; that is, they can accept up to 5V on their inputs. FEZ is 5V tolerant. Warning 5V-tolerant doesn't mean the processor can be powered by 5V. Only the input pins can tolerate 5V. Unconnected input pins are called \"floating\" as they are open for any surrounding noise, which can make the pin high or low. A resistor can be added to pull the pin high or low. Modern processors include internal pull-down or pull-up resistors, that are controlled by software. Note that the pull-up resistor doesn't make a pin high but it pulls it high. If nothing is connected then the pin is high by default. In this example, a button is connected between ground and the input pin. We will also enable the pull-up resistor, making that pin high when the button is not pressed, and low when the button is pressed. We will read the status of the button and pass its state to the LED. Tip Never use an infinite loop without giving the system time to think, use events or simply add a small sleep. using System; using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { GpioController GPIO = GpioController.GetDefault(); GpioPin led = GPIO.OpenPin(FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); GpioPin button = GPIO.OpenPin(FEZ.GpioPin.Btn1); button.SetDriveMode(GpioPinDriveMode.InputPullUp); while(true) { if(button.Read() == GpioPinValue.Low) { // button is pressed led.Write(GpioPinValue.High); } else { led.Write(GpioPinValue.Low); } Thread.Sleep(10);//always give the system time to think! } } } Tip if you are not using FEZ, see the Output Port example above to see how to determine the pin number. Digital Input Events In the previous example, the program just looped, and looped, and looped; each time checking the status of the pin attached to the button. The pin is checked maybe a million times before the button is pressed! Events solves this by invoking (calling) a method when an even occur. In this case the event is raised when the value on an input pin is changed. Meaning a button is pressed or released. A RisingEdge happen when the state of a pin changes from low to high, it \"rises\". This is the same button controlling LED example, but using events. using System; using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static GpioPin led; static void Main() { GpioController GPIO = GpioController.GetDefault(); led = GPIO.OpenPin(FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); GpioPin button = GPIO.OpenPin(FEZ.GpioPin.Btn1); button.SetDriveMode(GpioPinDriveMode.InputPullUp); button.ValueChanged += Button_ValueChanged; Thread.Sleep(-1);// sleep for low power, or do other tasks here! } private static void Button_ValueChanged(GpioPin sender, GpioPinValueChangedEventArgs e) { if (e.Edge == GpioPinEdge.FallingEdge) led.Write(GpioPinValue.Low); else led.Write(GpioPinValue.High); } } Warning Once you type += after the event, hit the tab key twice. Visual Studio will automatically create the event for you."
  },
  "tinyclr/tutorials/gpiochangereader.html": {
    "href": "tinyclr/tutorials/gpiochangereader.html",
    "title": "Gpio Change Reader",
    "keywords": "Gpio Change Reader Gpio Change Reader works in the current release. Documentation is coming soon."
  },
  "tinyclr/tutorials/uart.html": {
    "href": "tinyclr/tutorials/uart.html",
    "title": "UART",
    "keywords": "UART Serial data ports, called UART, transfers data between two pins TXD (transmit) and RXD (receive). There is no clock between the two sides so they both need to agree on the data slow rate, called baudrate. Tip the TXD on one end (output) goes to the RXD on the other side (input) and vice versa. The easiest way to test UART is by wiring TXD to RXD and then any data transmitted is also received. This demo will send a number every half a second and wait for it on the receive end. Tip Serial uses Storage Streams to handle the data. Add the Storage NuGet package. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Storage.Streams; using GHIElectronics.TinyCLR.Devices.SerialCommunication; using GHIElectronics.TinyCLR.Pins; class Program { static DataReader serReader; static DataWriter serWriter; static void Sender() { byte b = 0; while(true) { serWriter.WriteByte(b++); serWriter.Store(); Debug.WriteLine(\"Sent: \" + b); Thread.Sleep(500); } } static void Main() { SerialDevice ser = SerialDevice.FromId(FEZ.SerialPort.Com1); ser.BaudRate = 115200; ser.ReadTimeout = TimeSpan.Zero; serReader = new DataReader(ser.InputStream); serWriter = new DataWriter(ser.OutputStream); Thread SenderT = new Thread(Sender); SenderT.Start(); while (true) { var i = serReader.Load(1); if(i>0) { byte b = serReader.ReadByte(); Debug.WriteLine(\"Recieved: \" + b); } Thread.Sleep(10);// always give the system time to think! } } } RS232 UART uses the processor�s voltage levels for transferring data, called TTL voltage levels. Systems from back in the 80s needed a way to transfer data over long distances and so the UART levels changed to be -12V to +12V instead of TTL 0V to 3.3V on FEZ for example. This standard is called RS232. Some PCs still include serial porta till this day but those are RS232 serial ports. A level shifter chip is needed to convert the voltages properly. Warning connecting your circuit to RS232 port without proper level shifter wil damage your circuit."
  },
  "brainpad/courses/csharp/intro.html": {
    "href": "brainpad/courses/csharp/intro.html",
    "title": "Intro",
    "keywords": "Intro"
  },
  "brainpad/courses/vb/threading_and_events.html": {
    "href": "brainpad/courses/vb/threading_and_events.html",
    "title": "Threading and Events",
    "keywords": "Threading and Events"
  },
  "hardware/legacy/canxtra.html": {
    "href": "hardware/legacy/canxtra.html",
    "title": "CANxtra",
    "keywords": "CANxtra CANxtra is a hand-held highly programmable and customizable OBD-II tool, that includes CAN, LIN and other vehicle busses. Resources below are provided for reference only. Please ocntct us for any custom automotive needs. Resources: Get them from https://www.ghielectronics.com/downloads/discontinued/CANxtra/"
  },
  "hardware/legacy/mbuino.html": {
    "href": "hardware/legacy/mbuino.html",
    "title": "mBuino",
    "keywords": "mBuino mbuino, a tiny arduino-like keychain, is GHI Electronics contribution to the mbed community. Learn more at https://developer.mbed.org/platforms/mBuino/ Resources: � Eagle design files � Schematic � Mbed platform page https://developer.mbed.org/platforms/mBuino/"
  },
  "tinyclr/boards/clicker.html": {
    "href": "tinyclr/boards/clicker.html",
    "title": "Clicker",
    "keywords": "Clicker The Clicker board brings the option of using hundreds of plug-and-play sensors and control modules, thanks to Mikro�s mikroBUS and the click modules. Learn more at https://shop.mikroe.com/clicker-stm32f4 Use the ST DFU tool to load the �????? firmware 0.5.0� onto your Clicker board. When done, your PC should detect a TinyCLR device. You are now ready to start coding http://docs.ghielectronics.com/tinyclr/tutorials/intro.html"
  },
  "tinyclr/boards/quail.html": {
    "href": "tinyclr/boards/quail.html",
    "title": "Quail",
    "keywords": "Quail Originally a .NET Micro Framework product, Quail board brings the option of using hundreds of plug-and-play sensors and control modules, thanks to Mikro�s mikroBUS and the click modules. Learn more about Quail at https://www.mikrobusnet.org/ and https://shop.mikroe.com/quail Use the ST DFU tool to load the �????? firmware 0.5.0� onto your Quail board. When done, your PC should detect a TinyCLR device. You are now ready to start coding http://docs.ghielectronics.com/tinyclr/tutorials/intro.html"
  },
  "tinyclr/boards/stm32f4_discovery.html": {
    "href": "tinyclr/boards/stm32f4_discovery.html",
    "title": "STM32F4 Discovery Boards",
    "keywords": "STM32F4 Discovery Boards STM32F411 Discovery The STM32F411 Discovery board http://www.st.com/en/evaluation-tools/32f411ediscovery.html is a low-cost board with a built in native debugging support, called ST-Link. This is a good, especially for users wanting to port TinyCLR OS and in need for debugging TinyCLR OS native port. Use the ST DFU tool to load the �FEZ firmware 0.5.0� onto your discovery board. When done, your PC should detect a TinyCLR device. You are now ready to start coding http://docs.ghielectronics.com/tinyclr/tutorials/intro.html Note that we are using the same FEZ firmware. Peripherals are mapped exactly to how they are on the FEZ board http://docs.ghielectronics.com/hardware/fez.html STM32F407 Discovery The STM32F407 discovery board is very close to the STM32411. http://www.st.com/en/evaluation-tools/stm32f4discovery.html To run TinyCLR OS, follow the same instructions as the STM32F411 discovery board http://docs.ghielectronics.com/tinyclr/boards/stm32f411_discovery.html"
  },
  "brainpad/courses/intro.html": {
    "href": "brainpad/courses/intro.html",
    "title": "Courses Intro",
    "keywords": "Courses Intro Here you will find course to cover many topics, for every level or experience. Are you a teacher? We want to hear from you. Please contact us directly or through our community forum."
  },
  "brainpad/courses/vb/intro.html": {
    "href": "brainpad/courses/vb/intro.html",
    "title": "Introduction to the BrainPad",
    "keywords": "Introduction to the BrainPad Overview Students will learn how to create projects in Visual Studio along with programming basics. Applications in this lesson will be limited to the BrainPad object, If statements, a While loop and the template functions. Guidelines Prerequisites: None Ages 12 and up PC setup with Visual Studio 2017, TinyCLR OS and Nuget packages installed. Supplies: BrainPad and microUSB cable. Install Visual Studio and Download .vsix file Install Visual Studio Community 2017. Select the Community download. Skip this step if you have Visual Studio 2017 installed. Visual Studio 2017 Download Starting a New Project Connect your BrainPad to your computer using a microUSB cable. Next Open Visual Studio select File>New>Project and under Other Languages select Visual Basic>TinyCLR and choose the BrainPad Application . Change the Location to C:\\Users< YourUsername >\\Desktop\\ then name the project BrainPad_Project. From Visual Studio, select File > New > Project. Creating the BrainPad_Project BrainPad TinyCLR Application. Once created, you'll be presented with a Program.vb tab. The Program.vb file and its contents are shown. This file contains the default code when you first create a project. The lines in green that begin with ' are called comments, and they generally describe what the code does. Take a moment to review them. Let's run the code to see these comments' descriptions come to life. Connect the BrainPad and press the F5 function key or the Start button. Press the Start button to run the Program. Visual Studio will now run the code, a few things will happen and the display will now have the text \"Hello, world!\". The display shows \"Hello world\" What happened exactly? Our application began by calling the BrainPadSetup() function. This function is called one time, when the application starts, and is generally used to set things up. In this case, it executed the BrainPad.Display.DrawText line to instruct the display to show the text \"Hello, world!\" After BrainPadSetup() was finished, the application called BrainPadLoop() . Code placed inside this function is executed in an infinite loop. This is why the code that turns the LED on and then off again never stops. Exercise Change the text to make the program print your name on the display. Answer Change this line to your name instead of \"Hello World!\" BrainPad.Display.DrawText(0,0,\"YOUR NAME HERE\") The BrainPad Object The world around us is full of objects. Every person, table or circuit board is an object. If we were to ask a person to say \"hello,\" we'd be asking an object to perform a task. The same concept can be applied to code. Like in the previous application we ran, the BrainPad was asked to control the display and light bulb through the BrainPad object. The BrainPad object itself, is a piece of code that is contained in one file. This was developed by GHI Electronics to cover the internals of the BrainPad . This enables students like you, with an easy way to control the BrainPad circuit board. After typing BrainPad , press the period key to get a list of all available options for this object, like Display . Using IntelliSense we can see the options offered by the BrainPad object. Now we can use the arrow keys to go up and down in the list to find the Display , and then press the period key again to see what options are the available for the Display . Using IntelliSense we can see the options offered by the Display object. Visual Studio does a great deal of simplifying programming by automatically listing the available options for each object. Now that we know how to use the BrainPad object, let's learn about controlling the LED Light Bulb . The BrainPad LightBulb LED lights are used in many different electronic devices. Here we will test the LightBulb by turning it GREEN , then ON and OFF . Copy and paste the code from Example 1 into your project's BrainPadSetup() function. BrainPad.LightBulb.TurnOff() BrainPad.LightBulb.TurnGreen() BrainPad.LightBulb.TurnOff() BrainPad.LightBulb.TurnGreen() Put this code inside the BrainPadSetup() function. Now, press F5 to run the code and you'll see the LightBulb turn GREEN and stay on. This happens because our code is executed faster than we can see. Problem Solving Since applications execute extremely fast, we need to slow them down to figure out the problem. This way we can see what is happening or if the results are as expected. We will start by stepping in code to see what the application does at a slow speed. Stepping in Code Add a breakpoint at the first line of code inside of BrainPadSetup() by moving the cursor to that line and pressing the F9 key as shown in (Figure 7) . We've added a breakpoint on line 5. Press F5 to run the application. The project will be built and deployed but then the execution will stop at the breakpoint. The program has executed up to the breakpoint. Press the F10 key to execute the current line, which turns the green light off. Now press the F10 key again, and the LightBulb will turn GREEN . The next steps will continue through the rest of the code. When you reach the closing curly bracket, press F5 to stop. Now that we know our code works (it's just happening too fast) we can add some delays so we can see the light turn on and then off. Delays in Code In order to see what's going on we need to add some delays in the code. This is done by telling the BrainPad to wait between tasks. BrainPad.LightBulb.TurnOff() BrainPad.Wait.Seconds(0.5) BrainPad.LightBulb.TurnGreen() BrainPad.Wait.Seconds(0.5) BrainPad.LightBulb.TurnOff() BrainPad.Wait.Seconds(0.5) BrainPad.LightBulb.TurnGreen() This code waits half a second (0.5) between turning the Lightbulb GREEN and OFF. Copy and paste the code from above into your project's BrainPadSetup() function. Run the code and observe the LightBulb again. You should now see the LightBulb turning GREEN and off every half a second. Exercise Create a Traffic Light simulation using the following logic and the LightBulb : Turn the light on GREEN Wait 5 seconds. Turn the LightBulb off. Turn the light on YELLOW Wait 2 seconds. Turn the LightBulb off. Turn the light on RED Wait 5 seconds. Answer BrainPad.LightBulb.TurnGreen() BrainPad.Wait.Seconds(5) BrainPad.LightBulb.TurnOff() BrainPad.LightBulb.TurnYellow() BrainPad.Wait.Seconds(2) BrainPad.LightBulb.TurnOff() BrainPad.LightBulb.TurnRed() BrainPad.Wait.Seconds(5) While Loop The previous exercise turned the LightBulb several colors but it only did it once. We could repeat the code over and over to make the traffic light run a few more times but what if we want this to run indefinitely? This is where While loops come in handy. While BrainPad.Looping 'Your code End While Code inside a while loop will be executed indefinitely. Code inside a while loop will be executed indefinitely as long as its condition is met. In our case, we'll use a constant value from the BrainPad object called Looping . This constant always returns true, which causes the loop's condition to always be met. While BrainPad.Looping BrainPad.LightBulb.TurnGreen() BrainPad.Wait.Seconds(0.5) BrainPad.LightBulb.TurnOff() BrainPad.Wait.Seconds(0.5) End While This code will blink the LightBulb GREEN on and off for half a second indefinitely. Let's keep things simple and blink the LightBulb GREEN every half a second. Copy and paste the code from above into your project's BrainPadSetup() function. Run the code and observe the LightBulb . Tip: The BrainPadLoop() function does the same thing as our While loop behind the scenes, so you can use this function in your application to simplify things. Understanding The Loop To further understand what's going on, add a breakpoint by moving the cursor to the first line where we turn the light GREEN and press F9 . This will add a breakpoint and pause the application as soon as it reaches that line. block text Add a breakpoint while the application is running Now use F10 to step through the code and when the program reaches the end of the While loop it will go back to the beginning. Stop the program execution by pressing the STOP button. The stop button will stop the application that's running. Now, reset the BrainPad and note how the green light is still blinking but this time without the need for Visual Studio. In fact, you can connect the BrainPad to any appropriate power source (such as a phone charger) and the LightBulb will turn on GREEN and will blink without the need for a PC. Exercise Make the LightBulb cycle through 3 different colors indefinitely. Answer Public Sub BrainPadSetup() While BrainPad.Looping BrainPad.LightBulb.TurnGreen() BrainPad.Wait.Seconds(0.5) BrainPad.LightBulb.TurnRed() BrainPad.Wait.Seconds(0.5) BrainPad.LightBulb.TurnYellow() BrainPad.Wait.Seconds(0.5) End While End Sub If Statement An If statement (or conditional statement) checks to see if a statement is TRUE or FALSE and then does one of two things depending on the result. Like if the DOWN button is pressed, turn the LightBulb GREEN . Public Sub BrainPadSetup() BrainPad.LightBulb.TurnGreen() If BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnOff() End If End Sub Pressing and hold the down button when running this program will turn the LightBulb GREEN. For the code above to work, you have to be holding the button down at the time the program is deployed. This is because once the If statement is reached, the program will continue executing until the program ends. To solve this hard to reach goal, we need to repeatedly check if the button is pressed, as seen in the above code. This is where a While loop comes in handy. Let's use the BrainPadLoop() function to simplify things per the tip earlier . Public Sub BrainPadSetup() BrainPad.LightBulb.TurnOff() End Sub Public Sub BrainPadLoop() If BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnOff() End If End Sub The above code makes sure the LightBulb is OFF and then it falls into an infinite loop. However, this program still has a bug. Run the program and test it. The LightBulb will be OFF when the program runs and then once the down button is pressed the the LightBulb turn GREEN . That is all good so far, but when the button is released, the LightBulb never turns OFF . Can you guess why? Try stepping in the code to see what happens when the button is pressed and when it is not pressed . Computers are strict on following orders. In previous examples, the LightBulb never turned OFF because we actually never told the program to turn the LightBulb OFF . This means we have to tell the program to turn the LightBulb ON when the button is pressed and we also have to tell it to turn the LightBulb OFF when the button is not pressed. Public Sub BrainPadSetup() BrainPad.LightBulb.TurnOff() End Sub Public Sub BrainPadLoop() If BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnGreen() End If If Not BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnOff() End If End Sub This code loops indefinitely checking if the down button is pressed. If it is pressed, the LightBulb will turn on GREEN The above code first makes sure the LightBulb is off and then it falls into an infinite loop. However, this program still has a bug. Run the program and test it. The LightBulb will be off when the program runs and then once the down button is pressed the the LightBulb turn GREEN . That is all good so far, but when the button is released, the LightBulb never turns off. Can you guess why? Try stepping in the code to see what happens when the button is pressed and when it is not pressed . Computers are strict on following orders. In previous examples, the LightBulb never turned off because we actually never told the program to turn the GREEN LightBulb off. This means we have to tell the program to turn the light on when the button is pressed and we also have to tell it to turn the LightBulb off when the button is not pressed as shown. Public Sub BrainPadSetup() BrainPad.LightBulb.TurnOff() End Sub Public Sub BrainPadLoop() If BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnGreen() End If If Not BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnOff() End If End Sub This code will turn the LightBulb GREEN when the down button is pressed, and off when the down button **is not pressed** the **LightBulb** will turn on While the BrainPad doesn't have a method called BrainPad.Button.IsDownNotPressed() we can continue to use BrainPad.Button.IsDownPressed() but with If Not before it to represent if the button is not pressed . Now when you run it, not pressing the button will turn/keep the LightBulb off. Exercise Turn the LightBulb GREEN when the up button is pressed . Turn the LightBulb off when the down button is pressed . Turn the LightBulb RED on when the left button is pressed and BLUE when right button is pressed Answer Public Sub BrainPadSetup() BrainPad.LightBulb.TurnOff() End Sub Public Sub BrainPadLoop() If BrainPad.Buttons.IsUpPressed() Then BrainPad.LightBulb.TurnGreen() End If If BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnOff() End If If BrainPad.Buttons.IsLeftPressed() Then BrainPad.LightBulb.TurnRed() End If If BrainPad.Buttons.IsRightPressed() Then BrainPad.LightBulb.TurnRed() End If End Sub Else Statement The Else statement is always used with the If statement and has a very useful purpose that would be perfect for the last example. Previously, we needed to check if the button is pressed and if the button is not pressed. We can simplify this by catching when an If statement isn't true using Else as shown in the code below. Public Sub BrainPadSetup() BrainPad.LightBulb.TurnOff() End Sub Public Sub BrainPadLoop() If BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnGreen() Else BrainPad.LightBulb.TurnOff() End If End Sub This code uses an else statement to check if a button is pressed or not to turn the LightBulb green and off. Or & And Operators The most used logical operators are the Or and And operators. These are typically used within the If statement. In the example below, we want the buzzer to generate a 5,000 Hz sound when both the up and down buttons are pressed. This is accomplished by using an && operator between IsUpPressed() and IsDownPressed() . Public Sub BrainPadLoop() If BrainPad.Button.IsUpPressed() And BrainPad.Button.IsDownPressed() Then BrainPad.Buzzer.Start(5000) Else BrainPad.Buzzer.Stop() End If End Sub This code checks if both up and down are pressed, if so it plays a high pitch sound. Exercise Turn the LightBulb GREEN on and play the buzzer at 5,000 Hz whenever the up or down button is pressed. Pressing both or either one will have the same effect. Answer Extra Credit Tip: Use nested statements such as an If statement inside another If statement."
  },
  "hardware/fez.html": {
    "href": "hardware/fez.html",
    "title": "FEZ",
    "keywords": "FEZ Coming soon."
  },
  "hardware/g400.html": {
    "href": "hardware/g400.html",
    "title": "G400",
    "keywords": "G400 G400D and G400S are powerful NETMF System on Modules (SoM) To use G400, follow the setup instructions on the NETMF into page (link). Resources: � Datasheet � Development board reference schematic G400D is compatible the GHI Electronics� Universal Compute Modules (UCM). Please consider one of these modules as a drop-in hardware replacement for G400d www.ghi.co/products/usm We recommend TinyCLR OS as a replacement for NETMF. Learn more about TinyCLR at www.tinyclr.com To help you evaluate TinyCLR OS, we are providing a preview firmware for G400. First, load the boot loader using SAM-BA tools and then load this firmware using our GHI boot loader (link), and then G400 will run TinyCLR-OS G400 Bootloader 2.1.0 (link) G400 TinyCLR OS firmware 0.5.0 (link)"
  },
  "hardware/legacy/netmf/embedded_master.html": {
    "href": "hardware/legacy/netmf/embedded_master.html",
    "title": "Embedded Master",
    "keywords": "Embedded Master Replaced by EMX (link)"
  },
  "hardware/legacy/netmf/shields.html": {
    "href": "hardware/legacy/netmf/shields.html",
    "title": "Shields",
    "keywords": "Shields Coming soon."
  },
  "hardware/legacy/netmf/usbizi.html": {
    "href": "hardware/legacy/netmf/usbizi.html",
    "title": "USBizi",
    "keywords": "USBizi USBizi was the first single chip .NET Micro Framework (NETMF) on the market. It was available in 100pin and 144pin packages. We are no longer making the chip available but we are making all binaries available for free, including for commercial use. https://www.ghielectronics.com/downloads/NETMF/USBizi/ USBizi is supported with NETMF 4.1 (which VS do we need?) Resources: � Datsheet? � What docs do we have for USBizi? USBizi was the core of many of GHI Electronics� products, FEZ Panda, FEZ Panda II, FEZ Domino, FEZ Rhino and FEZ Mini. (get resources from https://www.ghielectronics.com/downloads/FEZ/ )"
  },
  "tinyclr/firmware_update.html": {
    "href": "tinyclr/firmware_update.html",
    "title": "Updating Firmware",
    "keywords": "Updating Firmware See your device page for information on putting your board in bootloader mode."
  },
  "tinyclr/accessories/sparkfun_ardumoto_shield_kit.html": {
    "href": "tinyclr/accessories/sparkfun_ardumoto_shield_kit.html",
    "title": "Sparkfun Ardumoto Shield Kit",
    "keywords": "Sparkfun Ardumoto Shield Kit The sparkfun Ardumoto Shield Kit is a low cost way of building a robot, somewhat quickly. https://www.sparkfun.com/products/14180 Plug the shield on top of your FEZ, or any other Arduino-pinout compatible board. You are now ready for some serious dancing! public static void Main() { var GPIO = GpioController.GetDefault(); var DIRA = GPIO.OpenPin(FEZ.GpioPin.D2); var DIRB = GPIO.OpenPin(FEZ.GpioPin.D4); DIRA.SetDriveMode(GpioPinDriveMode.Output); DIRB.SetDriveMode(GpioPinDriveMode.Output); var PWM1 = PwmController.FromId(FEZ.PwmPin.Controller1.Id); var PWM3 = PwmController.FromId(FEZ.PwmPin.Controller3.Id); PWM1.SetDesiredFrequency(5000); PWM3.SetDesiredFrequency(5000); var PWMA = PWM1.OpenPin(FEZ.PwmPin.Controller1.D3); var PWMB = PWM3.OpenPin(FEZ.PwmPin.Controller3.D11); PWMA.Start(); PWMB.Start(); // reverse direction every one second! // Do not foget the shield needs power. Thsi can come from VIN, meaning plug a power pack into your *duino board. PWMB.SetActiveDutyCyclePercentage(0.9); while (true) { DIRA.Write(GpioPinValue.High); DIRB.Write(GpioPinValue.High); System.Threading.Thread.Sleep(1000); //change speed PWMA.SetActiveDutyCyclePercentage(0.9); DIRA.Write(GpioPinValue.Low); DIRB.Write(GpioPinValue.Low); System.Threading.Thread.Sleep(1000); //change speed PWMA.SetActiveDutyCyclePercentage(0.5); } }"
  },
  "tinyclr/tutorials/adc.html": {
    "href": "tinyclr/tutorials/adc.html",
    "title": "ADC",
    "keywords": "ADC Unlike digital input pins, which can only read high or low; analog pins can read a range of voltage levels. Microcontrollers based on 3.3V can typically read voltages anywhere between zero and 3.3V. Analog inputs connect internally to a Analog to Digital Converter (ADC) that converts the analog voltage level on the pin to a digital value. The resolution of the ADC determines its accuracy. An 8bit ADC has 256 steps to work with, 3.3V/256=0.013V. This means an increase of 0.013V will increase the value by one. In other words, a voltage change of less than 0.013V has no effect. The ADC on FEZ is 12bit and should fit most needs. Tip Note that the analog channel number is not the pin number. We have these easily enumerated for FEZ but you need to determine the channel number on a specific pin using your system�s documentation. This example will read the ratio, that is 0 to 1, of an analog input. After running the program, connect a wire from the analog pin to ground and you should see a zero or something really close to zero. Connect to 3.3V and you will see 1 or something close, like 0.99. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { AdcController ADC = AdcController.GetDefault(); AdcChannel analog = ADC.OpenChannel(FEZ.AdcChannel.A0); while(true) { double d = analog.ReadRatio(); Debug.WriteLine(\"An-> \" + d.ToString(\"N2\")); Thread.Sleep(100); } } }"
  },
  "tinyclr/tutorials/i2c.html": {
    "href": "tinyclr/tutorials/i2c.html",
    "title": "I2C",
    "keywords": "I2C I2C (pronounced eye-squared-sea, or eye-two-sea) was originally developed by Phillips to allow multiple chipsets to communicate on a 2-wire bus in home consumer devices. It has a master and one or more slaves sharing the same data bus. Instead of selecting the slaves using a digital pin like SPI, which consumes an additional I/O pin, I2C uses an addressing mechanism to communicate to a selected device. Before data is transferred, the master sends out a 7-bit address of the slave device it wants to communicate with. It also sends one bit indicating whether it wants to send data to the slave or receive data from the slave. When a slave sees its address on the bus, it will acknowledge its presence. At this point, the master can send or receive data. The master will start data transfers with a \"start condition\" before it sends any address or data and then end it with \"stop condition\". The two wires used to communicate between the I2C Master and the I2C salves are called SDA and SCL lines; SDA stands for Serial Data, and SCL is Serial Clock. This is a partial demo showing the use of I2C. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.I2c; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var settings = new I2cConnectionSettings(0x1C)// the slave's address { BusSpeed = I2cBusSpeed.FastMode }; var device = I2cDevice.FromId(FEZ.I2cBus.I2c1, settings); device.Write(new byte[] { 1, 2 });// write something device.WriteRead(...)// this is good for reading registers } }"
  },
  "hardware/brainpad.html": {
    "href": "hardware/brainpad.html",
    "title": "BrainPad",
    "keywords": "BrainPad http://docs.ghielectronics.com/hardware/brainpad.html The BarinPad is an educational STEM & STEAM targeted board. This page has some advanced hardware resources. For courses and documentation on the use of the BrainPad, see http://docs.ghielectronics.com/brainpad/intro.html Learn more about the BrainPad at www.brainpad.com Resources: � Schematic � EAGLE Design Files � 3D model"
  },
  "tinyclr/tutorials/intro.html": {
    "href": "tinyclr/tutorials/intro.html",
    "title": "TinyCLR Tutorials",
    "keywords": "TinyCLR Tutorials Here you will find tutorials covering different features of the TinyCLR OS. We try to keep the documents hardware-generic as much as possible but when we can't, we use FEZ as a reference. Getting Started First you'll need to download and install Visual Studio 2017, if you already haven't Visual Studio 2017 Download Next you have to download the lastest version of TinyCLR OS here: TinyCLR OS Download Release notes: TinyCLR OS Release Notes The TinyCLR OS zip file you downloaded contains all files you'll currently need to run TinyCLR OS. Extract all the files from the downloaded zip into a folder on your desktop. Next run the VSIX installer file, found inside the folder you just extracted to you DESKTOP Adding Nuget Packages For the current preview releases you'll have to create a local NUGET folder to host the NUGET packages that are found in the TinyCLR OS Download In the near future all libraries will be downloaded through NuGet. Because of this, there will be no SDK to install or machines to lock to specific versions. Simply use NuGet to download any needed version of any needed library on a per-project basis. Create a New Project Open Visual Studio, select FILE>New Project. There should be a \"TinyCLR\" option under \"Visual C#\" Click the \"OK\" button a project and program are created. The project has only one C# file, called Program.cs. C# source files are listed in the \"Solution Explorer\" window. If the Solution Explorer is not opened, use the VIEW->Solution Explorer menu."
  }
}