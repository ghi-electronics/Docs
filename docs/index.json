{
  "hardware/gadgeteer/fez-spider-ii.html": {
    "href": "hardware/gadgeteer/fez-spider-ii.html",
    "title": "FEZ Spider II",
    "keywords": "FEZ Spider II FEZ Spider II is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Spider II is the G120E System on Module (SoM). To use with NETMF/Gadgeteer, follow these setup instructions . Resources Schematic Using TinyCLR OS Follow the instructions on the G120 page to learn how to use FEZ Spider II TinyCLR OS. The instructions are the same as G120. LDR0 and LDR1 signals are available on switches #1 and #2. The schematic above has all details."
  },
  "software/netmf/tutorials/in-field-update.html": {
    "href": "software/netmf/tutorials/in-field-update.html",
    "title": "In-Field Update",
    "keywords": "In-Field Update One of GHI Electronics's additions to NETMF includes the In-Field Update (IFU) class allowing devices to be updated in the field. Updates can be obtained over the network or via USB memory, an SD card, or even through a serial port. File encryption and integrity checking can be implemented if desired. Once the data is available, it is passed on to IFU and then stored internally in RAM. Once all of the data is received and loaded by the developer, a single call will wipe the flash and write the new files. Only the regions that are being updated are erased. Warning The final stage will erase the flash and write the new data. This can take some time depending on the board. Losing power during this process will cause the update to fail and require the device to be updated manually. Extracting an Existing Application Creating a hex file to flash to your deployed board is easy. For example, if you have a board in the field (mall kiosk, traffic signal, etc) that is difficult to access, just deploy the new version of your program to another board of the same type. Then open MFDeploy, select USB, and select Target > Application Deployment > Create Application Deployment as shown below. Tip If you would like the next version of your application to have the same update ability, be sure to include the update code in it as well. Now select the name of the file that you would like to use and where to save it. Once this is done, you can place this file on an SD card and insert it into your device, or you can send it to you device over a network. The next section will demonstrate how to load the files and perform the update. Getting Started The following example shows you how to load data into IFU and then flash the device. It requires the GHI.Hardware assembly and assumes that you have already mounted an SD card. Since firmware files can large and often cannot be held in entirely in memory we only load portions of the file at a time. using GHI.Processor; using System.IO; public class Program { public const int BLOCK_SIZE = 65536; public static void FlashFirmware() { // Reserve the memory needed to buffer the update. // A lot of RAM is needed so it is recommended to do this at the program start. InFieldUpdate.Initialize(InFieldUpdate.Types.Firmware | InFieldUpdate.Types.Configuration); // Start loading the new firmware on the RAM reserved in last step. // Nothing is written to FLASH in this stage. Power loss and failures are okay. // Simply abort this stage any way you like! // Files can come from storage, from network, from serial bus or any other way. LoadFile(\"\\\\SD\\\\Config.hex\", InFieldUpdate.Types.Configuration); LoadFile(\"\\\\SD\\\\Firmware.hex\", InFieldUpdate.Types.Firmware); LoadFile(\"\\\\SD\\\\Firmware2.hex\", InFieldUpdate.Types.Firmware); //Only if your device has two firmware files. // This method will copy The new firmware from RAM to FLASH. // This function will not return but will reset the system when done. // Power loss before this function resets the system will result in corrupted firmware. // A manual update will be needed if this method fails (due to power loss for example). InFieldUpdate.FlashAndReset(); } public static void LoadFile(string filename, InFieldUpdate.Types type) { using (var stream = new FileStream(filename, FileMode.Open)) { var data = new byte[BLOCK_SIZE]; for (int i = 0; i < stream.Length / BLOCK_SIZE; i++) { stream.Read(data, 0, BLOCK_SIZE); InFieldUpdate.Load(type, data, BLOCK_SIZE); } stream.Read(data, 0, (int)stream.Length % BLOCK_SIZE); InFieldUpdate.Load(type, data, (int)stream.Length % BLOCK_SIZE); } } }"
  },
  "software/netmf/tutorials/i2c.html": {
    "href": "software/netmf/tutorials/i2c.html",
    "title": "I2C",
    "keywords": "I2C I2C (pronounced eye-squared-sea, or eye-two-sea) was originally developed by Phillips to allow multiple chipsets to communicate on a 2-wire bus in home consumer devices. It has a master and one or more slaves sharing the same data bus. Instead of selecting the slaves using a digital pin like SPI (consuming an additional I/O pin), I2C uses an addressing mechanism to communicate to the selected device. Before data is transferred, the master sends out a 7-bit address address of the slave device it wants to communicate with. It also sends one bit indicating whether it wants to send data to the device or receive data from the device. When a slave sees its address on the bus, it will acknowledge its presence. At this point, the master can send or receive data. The master will start data transfers with a \"start\" condition before it sends any address or data and then end it with \"stop\" condition. The I2C uses two wires to communicate between the I2C Master and the I2C device. These two wires are known as the SDA and SCL lines. SDA stands for Serial Data, and SCL is Serial Clock. The I2C NETMF driver is based on transactions. If we want to read from a register on a sensor, we would first need to send it the register number we wish to read from, and then we need to read the register. Those are two transactions; a write followed by a read. Addressing One very important point about I2C is that I2C devices have a 7-bit address, but 8-bits are sent on the wire in the \"control byte\" when communicating with the I2C bus. The 8th bit tells the device whether the operation will be a read operation (the 8th bit is a 1) or a write operation (the 8th bit is a 0). When discussing I2C you should always make sure you are clear about the 7-bit address that your device uses, rather than stating your 8-bit read or write address. Software I2C When using I2C, it is highly recommended that you use the built-in hardware support for I2C. In some cases though it may be necessary to have another I2C bus or it is necessary to use specific pins that are not I2C pins. In this case, I2C can be handled completely in software, though performance will be lower. The GHI libraries include a software I2C implementation in the GHI.Hardware assembly (GHI.IO.SoftwareI2CBus). An I2C Example This example will read the value of the register on an I2C device with the 7-bit address of 0x38. As discussed above, you first have to write the register number you want to read, two in this case, and then read the value back. using Microsoft.SPOT; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { //create I2C object //note that the netmf i2cdevice configuration requires a 7-bit address! It set the 8th R/W bit automatically. I2CDevice.Configuration con = new I2CDevice.Configuration(0x38, 400); I2CDevice MyI2C = new I2CDevice(con); // Create transactions // We need 2 in this example, we are reading from the device // First transaction is writing the \"read command\" // Second transaction is reading the data I2CDevice.I2CTransaction[] xActions = new I2CDevice.I2CTransaction[2]; // create write buffer (we need one byte) byte[] RegisterNum = new byte[1] { 2 }; xActions[0] = I2CDevice.CreateWriteTransaction(RegisterNum); // create read buffer to read the register byte[] RegisterValue = new byte[1]; xActions[1] = I2CDevice.CreateReadTransaction(RegisterValue); // Now we access the I2C bus using a timeout of one second // if the execute command returns zero, the transaction failed (this // is a good check to make sure that you are communicating with the device correctly // and donï¿½t have a wiring issue or other problem with the I2C device) if (MyI2C.Execute(xActions, 1000) == 0) { Debug.Print(\"Failed to perform I2C transaction\"); } else { Debug.Print(\"Register value: \" + RegisterValue[0].ToString()); } } } Multiple Devices The I2C object on NETMF is a representation of the \"bus\" and not the \"device\" so you can't construct multiple I2C objects. To access multiple I2C devices you need to have multiple configurations and then when accessing device \"A\" we need to use configuration \"A\" and when accessing device \"B\" we need to use configuration \"B\". using Microsoft.SPOT; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { //create I2C Device object representing both devices on our bus I2CDevice.Configuration conDeviceA = new I2CDevice.Configuration(0x38, 400); I2CDevice.Configuration conDeviceB = new I2CDevice.Configuration(0x48, 400); //create I2C Bus object using one of the devices on the bus I2CDevice MyI2C = new I2CDevice(conDeviceA); // Note you could have chosen to create the bus using the conDeviceB parameter, which ever you choose it will be the \"selected\" device on the bus to start with. Here's how you would do that: // I2CDevice MyI2C = new I2CDevice(conDeviceB); //create transactions (we need 2 in this example) I2CDevice.I2CTransaction[] xActions = new I2CDevice.I2CTransaction[2]; // create write buffer (we need one byte) byte[] RegisterNum = new byte[1] { 2 }; xActions[0] = I2CDevice.CreateWriteTransaction(RegisterNum); // create read buffer to read the register byte[] RegisterValue = new byte[1]; xActions[1] = I2CDevice.CreateReadTransaction(RegisterValue); // Explicitly set the I2C bus to access device A by setting the I2C Config to the Device A's config. MyI2C.Config = conDeviceA; if (MyI2C.Execute(xActions, 1000) == 0) { Debug.Print(\"Failed to perform I2C transaction\"); } else { Debug.Print(\"Register value: \" + RegisterValue[0].ToString()); } // Explicitly set the I2C bus to access device B by setting the I2C Config to the Device B's config. MyI2C.Config = conDeviceB; if (MyI2C.Execute(xActions, 1000) == 0) { Debug.Print(\"Failed to perform I2C transaction\"); } else { Debug.Print(\"Register value: \" + RegisterValue[0].ToString()); } } }"
  },
  "software/netmf/tutorials/analog-in.html": {
    "href": "software/netmf/tutorials/analog-in.html",
    "title": "Analog Inputs",
    "keywords": "Analog Inputs Unlike digital input pins which can only read high or low, analog pins can read a range of voltage levels. Micro-controllers based on 3.3V can read voltages anywhere between zero and 3.3V. In contrast to digital input pins that are 5V tolerant; the maximum applied voltage for analog input must not exceed 3.3V (for higher voltages a voltage divider or an op-amp circuit can be used). Using a Light Sensor to Demonstrate Analog Input This example uses a light sensor. Its output voltage varies with light intensity -- the darker the light the higher the voltage output. The following code requires the Microsoft.SPOT.Hardware assembly. Consult the Developers' Guide or the product manual for specific channels. using System.Threading; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { AnalogInput lightSensor = new AnalogInput((Cpu.AnalogChannel)Cpu.AnalogChannel.ANALOG_7); double lightSensorReading = 0; while (true) { lightSensorReading = lightSensor.Read(); Debug.Print(lightSensorReading.ToString()); Thread.Sleep(500); } } }"
  },
  "hardware/ucm/development-options.html": {
    "href": "hardware/ucm/development-options.html",
    "title": "UCM Development Options",
    "keywords": "UCM Development Options These options are provided to speed the development of your product and make it possible to start programming your application within minutes without designing or building new hardware. You may also use these products as quick drop-in options into your design as well. Code Samples For some examples of using the development options in TinyCLR, take a look at the TinyCLR Samples repo . You may also find the TinyCLR tutorials useful. UCM Dev Board Ordering Part Number: UCD-DEV-E Schematic The UCM Dev Board is the fastest and easiest way to start using our Universal Compute Modules. This board provides a socket for the UCM, standard connectors for input/output, and three 40 pin socket headers for connecting peripherals and a display. Peripheral connectors include external power, Ethernet, CAN, USB host and client, RTC backup battery, DCMI interface and an SD card slot. It also has a buzzer, LEDs, a reset button, and user programmable boot buttons. To start development using the UCM Dev Board, just plug a UCM into the socket on the board and connect the board's USB Client port to a host computer using a micro USB. Go to the documentation page for the particular UCM you are using for instructions. For power, the board can be powered through either USB connectors or the barrel jack. Always use the barrel jack for power when using displays, especially the larger ones. USB does not provide sufficient power needed for displays. Tip The barrel jack is pin positive, sleeve negative, 2.1mm. It is capable of anywhere 7V to 30V. 1A of power should be enough for most needs. UCM Breakout Board Ordering Part Number: UCD-BKT-C Schematic The UCM Breakout Board provides a socket for UCMs, and both through hole and surface mount edge connections for soldering the Breakout Board to your own circuit board. You can solder pin headers to the Breakout Board and use traditional breadboarding techniques to build your prototype as well. This board makes it easier to use UCMs in prototypes or products without the need to solder the fine pitch 200 pin SO-DIMM socket. For added convenience, it also includes USB Client connector, a reset button, four user programmable boot buttons, and a micro SD card slot. Please note that this is a Breakout Board and it does not have any power supplies. You will need to add 3.3V or 5V as needed to power up your modules. However, the power from USB is available on one of the pins (5V USB) so it is possible to wire a 3.3V regulator. Tip There are 2 LEDs by the USB connector, for 3.3V and 5V. They are useful to check that you have supplied the necessary power. A simple board can be designed and hand soldered to host the Breakout Board. You can turn an idea into a product prototype in days! This example board example (in green) is made to be the exact same size as the 4.3\" universal display board. It can be designed with the display connector conveniently located in the right place. To start using the breakout board, plug one of the UCMs into the socket on the board and wire in 3.3V (you may also need 5V) and plug in USB into your PC. Go to the documentation page for the particular UCM you are using for instructions. Universal Displays Available displays work directly with the options above, just make sure you are using a SoM supporting the needed peripherals. The Universal Displays can be connected directly or wired though a 40-pin IDE extension ribbon cable, similar to the old-style IDE hard drive cable extender, with a Male connector on one end and a Female connector on the other. To connect a display with the Dev Board, simply plug it on top. The display can be larger than the board but it will still use the same connector (HDR C). When using the Breakout Board you need to add a female header. Make sure the header is placed on the back of the Breakout Board. Note how the Breakout Board, and potentially your host board, hide behind the display. This is a good advantage when mounting the display inside a product. Adding a ribbon cable allows for further flexibility on where and how far the display is mounted. The length of the cable is determined by clock frequency used with the display. If the image on the display is not stable, lower the clock or shorten the cable. In our testing, our display have worked perfectly with 10\" cable. UCD-D43-A Ordering Part Number: UCD-D43-A Display Module: ER-TFT043-3 Touch Panel: ER-TPC043-2 Schematic This display module has a 4.3\" 480x272 TFT display with capacitive touch screen. The display needs a UCM with TFT display support and needs I2C for the capacitive touch. The backlight is controllable through GPIO A. The capacitive touch controller is connected I2C A with the interrupt pin on GPIO B. The TinyCLR Samples repo has usage examples. Learn more about the graphics support. See below for the display configuration values: Property Value Width 480 Height 272 DataFormat RGB565 Pixel Clock Rate 5 MHz <= x <= 12MHz Pixel Polarity low DataEnable Is Fixed false DataEnable Polarity low Horizontal Back Porch 46 Horizontal Front Porch 16 Horizontal Sync Polarity low Horizontal Sync Pulse Width 1 Vertical Back Porch 23 Vertical Front Porch 7 Vertical Sync Polarity low Vertical Sync Pulse Width 1 UCD-D70-A Ordering Part Number: UCD-D70-A Display Module: ER-TFT070-4 Touch Panel: ER-TPC070-6 Schematic This display module has a 7\" 800x480 TFT display with capacitive touch screen. The display needs a UCM with TFT display support and needs I2C for the capacitive touch. The backlight is controllable through GPIO A. The capacitive touch controller is connected I2C A with the interrupt pin on GPIO B. The display is exactly the same size as the Dev Board. They can be nicely mounted back to back with stand offs. A ribbon cable will be needed for the display signals. The TinyCLR Samples repo has usage examples. Learn more about the graphics support. See below for the display configuration values: Property Value Width 800 Height 480 DataFormat RGB565 Pixel Clock Rate <= 50 MHz Pixel Polarity low Data Enable Is Fixed false Data Enable Polarity low Horizontal Back Porch 46 Horizontal Front Porch 16 Horizontal Sync Polarity low Horizontal Sync Pulse Width 1 Vertical Back Porch 23 Vertical Front Porch 7 Vertical Sync Polarity low Vertical Sync Pulse Width 1 Custom Boards The \"Display Interface\" utilized on development options include TFT parallel 16bit/24bit bus, I2C bus, SPI, bus and 2 GPIOs. It is possible to design a custom display to utilize the UCM mainboards, or design a mainboard to utilize the available displays. Additionally, the designs of the development options can be used as a reference to start a UCMbased design. GHI Electronics' engineering/manufacturing is available for such designs. Legal License This product with its accompanying firmware are licensed royalty-free for commercial and noncommercial use. Using the provided firmware on non-official product requires additional licensing. The provided documentation/schematics/libraries/sources are not to be used in any manner outside for the benefit of implementing and using this GHI Electronics product into your design. Disclaimer IN NO EVENT SHALL GHI ELECTRONICS, LLC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS PRODUCT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. GHI ELECTRONICS LINE OF PRODUCTS ARE NOT DESIGNED FOR LIFE SUPPORT APPLICATIONS. SPECIFICATIONS, PRICE AND AVAILABILITY ARE SUBJECT TO CHANGE WITHOUT ANY NOTICE. You can visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/ucm/chipworkx.html": {
    "href": "hardware/ucm/chipworkx.html",
    "title": "ChipworkX",
    "keywords": "ChipworkX ChipworkX is a NETMF (.NET Micro Framework) System on Module. To use with NETMF, follow these setup instructions . Requires the NETMF 4.1 SDK. Resources User Manual"
  },
  "hardware/loaders/sam-ba-bootloader.html": {
    "href": "hardware/loaders/sam-ba-bootloader.html",
    "title": "SAM-BA Bootloader",
    "keywords": "SAM-BA Bootloader The SAM-BA Bootloader lives on many Atmel chips. It is necessary to load files (loaders and/or firmware) onto the chip. Several TinyCLR OS supported boards will use this loader to load the software. Uploading bin Files To set the chip in SAM-BA mode, hold down the dedicated button on your board (SYS A on UCM Dev and Breakout boards) while the system powers up (or during reset). If there is no such button, follow the instructions from the specific product on how set the device in SAM-BA mode. For example, connect G400 pin SPI1_MISO to ground. Keep the button pressed (pin grounded) for three seconds after power up or reset, then release the pin. The device manager will show a COM port similar to \"Bossa Program Port\" or \"GPS Detect\". If it is not already installed, download and install the SAM-BA tool from Microchip. The latest version we have tested is 2.18 for Windows. (The tool may not show correctly. Try to make the window larger to see all hidden buttons!) Open the SAM-BA program then select the COM port for your device in the connection box and your board type below it (at91sam9x35-ek for G400), then click connect. Near the middle of the window, go to the DataFlash AT45DB/DCB tab. Under Scripts , select Enable Dataflash (SPI0 CS0) then click the Execute button. Under Scripts , select Erase All then click Execute . This will take some time to complete. It seems that if SAM-BA loses focus during the erase procedure it can seem to lock up. We recommend that once you click the Execute button you leave the computer alone until the erase procedure is completed. Under Scripts , select Send Boot File , click execute, then browse to and select the bootloader for the device. Once the transfer finishes, go to File > Quit and then reset the board. Make sure to properly quit the program or connection errors may result on subsequent uses. Now reset the board. Congratulations, your board is now running the loaded program!"
  },
  "hardware/duino/fez-panda.html": {
    "href": "hardware/duino/fez-panda.html",
    "title": "FEZ Panda",
    "keywords": "FEZ Panda An Arduino-pinout compatible board. Resources Schematic Software For information on programming the FEZ Panda, please go to the USBizi page."
  },
  "hardware/duino/fez-mini.html": {
    "href": "hardware/duino/fez-mini.html",
    "title": "FEZ Mini",
    "keywords": "FEZ Mini Resources Schematic Software For information on programming the FEZ Mini, please go to the USBizi page."
  },
  "hardware/duino/fez-cerbuino-bee.html": {
    "href": "hardware/duino/fez-cerbuino-bee.html",
    "title": "FEZ Cerbuino Bee",
    "keywords": "FEZ Cerbuino Bee An Arduino-pinout compatible single board computer with Gadgeteer sockets. Resources Schematic Software For information on programming the FEZ Cerbuino Bee, please go to the FEZ Cerberus page."
  },
  "hardware/breakout/g120-hdr.html": {
    "href": "hardware/breakout/g120-hdr.html",
    "title": "G120HDR Modules",
    "keywords": "G120HDR Modules The G120HDR Module is a through-hole version of the G120 Module G120HDR G120HDR Rev2 Resources Schematic"
  },
  "hardware/imaging.html": {
    "href": "hardware/imaging.html",
    "title": "Imaging",
    "keywords": "Imaging ALCAM-OEM is a small yet powerful imaging hardware. It could capture stills and videos to SD card and able to fetch images using serial commands. It started in a successful Kickstarter campaign Resources Examples ALCAM Explorer User Manual We have worked on similar custom commercial designs with imaging needs but decided to proceed with a one-size-fits-all. Please contact us to discuss your imaging needs. Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/tinyclr/tutorials/uart.html": {
    "href": "software/tinyclr/tutorials/uart.html",
    "title": "UART",
    "keywords": "UART Serial data ports, called UARTs, transfer data between devices using two pins: TXD (transmit data) and RXD (receive data). UART stands for Universal Asynchronous Receiver Transmitter. Asynchronous means there is no clock signal to synchronize the two devices. The devices agree on a data rate, called the baud rate, and send a start bit the beginning of each transmitted character to keep the devices synchronized. Tip the TXD on one end (output) goes to the RXD on the other side (input) and vice versa. The easiest way to test a UART is by wiring a device's TXD to its RXD so any transmitted data is received by the same device. This is called a \"loopback\" test. The following code performs a simple loopback test on the FEZ. If you connect the TX pin directly to the RX pin, you will see \"ABCDEF\" in the output window when running this code. Tip Don't forget to add the GHIElectronics.TinyCLR.Devices.Uart NuGet package! using System.Diagnostics; using System.Text; using System.Threading; using GHIElectronics.TinyCLR.Devices.Uart; using GHIElectronics.TinyCLR.Pins; class Program { private static void Main() { var txBuffer = new byte[] { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 }; //A, B, C, D, E, F var rxBuffer = new byte[txBuffer.Length]; var myUart = UartController.FromName(FEZ.UartPort.Usart1); myUart.SetActiveSettings(9600, 8, UartParity.None, UartStopBitCount.One, UartHandshake.None); myUart.Enable(); myUart.Write(txBuffer, 0, txBuffer.Length); while (true) { if (myUart.BytesToRead > 0) { var bytesReceived = myUart.Read(rxBuffer, 0, myUart.BytesToRead); Debug.WriteLine(Encoding.UTF8.GetString(rxBuffer, 0, bytesReceived)); } Thread.Sleep(20); } } } Event Handlers TinyCLR's UART API included the following event watchers: ClearToSendChanged DataReceived ErrorReceived The following example demonstrates the DateReceived event. using System.Diagnostics; using System.Text; using System.Threading; using GHIElectronics.TinyCLR.Devices.Uart; using GHIElectronics.TinyCLR.Pins; class Program { private static byte[] txBuffer; private static byte[] rxBuffer; private static UartController myUart; private static void Main() { txBuffer = new byte[] { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 }; //A, B, C, D, E, F rxBuffer = new byte[txBuffer.Length]; myUart = UartController.FromName(FEZ.UartPort.Usart1); myUart.SetActiveSettings(9600, 8, UartParity.None, UartStopBitCount.One, UartHandshake.None); myUart.Enable(); myUart.DataReceived += MyUart_DataReceived; myUart.Write(txBuffer, 0, txBuffer.Length); while (true) { Thread.Sleep(20); } } private static void MyUart_DataReceived(UartController sender, DataReceivedEventArgs e) { var bytesReceived = myUart.Read(rxBuffer, 0, e.Count); Debug.WriteLine(Encoding.UTF8.GetString(rxBuffer, 0, bytesReceived)); } } Tip Once you type += after the event, hit the tab key and Visual Studio will automatically create the event for you. RS232 UART uses the processor's voltage levels (logic levels) for transferring data. On the FEZ this is 0 to 3.3 volts. In the early days of computers UARTs used -12 to 12 volts to communicate reliably over longer distances. This is known as the RS232 standard. Some PCs still include serial ports, but those are RS232 serial ports. A voltage level shifter is needed to properly connect a logic level UART to an RS232 device. Warning Connecting your device to an RS232 port without a proper voltage level shifter can damage your device."
  },
  "software/tinyclr/tutorials/timer.html": {
    "href": "software/tinyclr/tutorials/timer.html",
    "title": "Timers",
    "keywords": "Timers A timer is used to call a method at a specific time. This example will call (invoke) Ticker initially after 3 seconds and then it will repeat once a second indefinitely. static void Ticker(object o) { Debug.WriteLine(\"Hello!\"); } static void Main() { Timer timer = new Timer(Ticker, null, 3000, 1000); Thread.Sleep(Timeout.Infinite); } A thread can also be created that loops once a second. The difference is that a thread with a 1 second sleep will always sleep for one second after whatever time was needed by the thread. So if a thread needed 0.5 second to complete what it is doing, sleeping for one second will cause the thread to execute every 1.5 seconds. This also gets more complex as a thread can be interrupted by the system. There is no guaranteed time on threads. A timer set to invoke a method every second will do so every second regardless of how long that method needs to complete its task. However, care must be taken as if a timer calls a method every 10 milliseconds but then the method needs more than 10 milliseconds to execute you will end up flooding the system. The best practice is for timers to invoke methods that execute in a short time."
  },
  "software/tinyclr/tutorials/time.html": {
    "href": "software/tinyclr/tutorials/time.html",
    "title": "Time Keeping",
    "keywords": "Time Keeping Built-in Time Service You can simply get the current time using DateTime.Now . The system starts counting at a fixed time on every power up, meaning the time ticks every second correctly but the time will be off. If the correct time is needed, the time needs to be set to the current true time (and date). This is accomplished using GHIElectronics.TinyCLR.Native.SystemTime.SetTime(DateTime utcTime) using System; using System.Diagnostics; using System.Threading; class Program { static void Main() { Debug.WriteLine(\"Time at power up: \" + DateTime.Now); // January 1st 2019 at 11:11:11 DateTime MyTime = new DateTime(2019, 1, 1, 11, 11, 11); GHIElectronics.TinyCLR.Native.SystemTime.SetTime(MyTime); while (true) { Debug.WriteLine(\"Current Time: \" + DateTime.Now); Thread.Sleep(1000); } } } The output looks like Time at power up: 01/01/2017 00:00:01 Current Time: 01/01/2019 11:11:11 Current Time: 01/01/2019 11:11:12 Current Time: 01/01/2019 11:11:13 Current Time: 01/01/2019 11:11:14 ... Real Time Clock The Real Time Clock (RTC) is a circuit that runs off a small battery or a super capacitor. It has its own crystal and keeps runnning even when the system is powered off. Not every hardware has a built in RTC, so check your hardware's manual for more details. In the even the RTC battery was drained or the RTC was never initialized, the RTC will not have a correct value. Use the rtc.IsValid to dermine of time is was set correctly. using GHIElectronics.TinyCLR.Devices.Rtc; using GHIElectronics.TinyCLR.Native; using System; using System.Diagnostics; using System.Threading; class Program { static void Main() { var rtc = RtcController.GetDefault(); if (rtc.IsValid) { Debug.WriteLine(\"RTC is Valid\"); // RTC is good so let's use it SystemTime.SetTime(rtc.Now); } else { Debug.WriteLine(\"RTC is Invalid\"); // RTC is not valid. Get user input to set it // This example will simply set it to January 1st 2019 at 11:11:11 var MyTime = new DateTime(2019, 1, 1, 11, 11, 11); rtc.Now = MyTime; SystemTime.SetTime(MyTime); } while (true) { Debug.WriteLine(\"Current Time : \" + DateTime.Now); Debug.WriteLine(\"Current RTC Time: \" + rtc.Now); Thread.Sleep(1000); } } } The output will show both times and they should match. The first time maybe invalid and the time is set but the second power up will show the correct time. RTC is Valid Current Time : 01/01/2019 11:15:35 Current RTC Time: 01/01/2019 11:15:35 Current Time : 01/01/2019 11:15:36 Current RTC Time: 01/01/2019 11:15:36"
  },
  "software/tinyclr/tutorials/networking/spwf04sx.html": {
    "href": "software/tinyclr/tutorials/networking/spwf04sx.html",
    "title": "SPWF04Sx WiFi Module",
    "keywords": "SPWF04Sx WiFi Module First introduced over twenty years ago, WiFi has become the most popular wireless networking technology. The SPWF04Sx family of modules from STMicroelectronics have an easy-to-use AT command based socket API that allow applications to quickly connect to the Internet. They also support Transport Layer Security, which is vital in an IoT environment. Take a look at the FEZ WiFi sample for a working example to get going quickly. The TinyCLR Driver repo includes the complete source code. Constructors SPWF04SxInterface() SPWF04SxInterface(SpiDevice spi, GpioPin irq, GpioPin reset) . Used to create a new instance of the WiFi driver. Takes the SPI device and the IRQ and RESET GPIO pins as arguments. Has no return value. Methods ClearTlsServerRootCertificate() ClearTlsServerRootCertificate() . Erases the currently loaded root certificates from the WiFi module's flash memory. Takes no arguments and has no return value. CloseSocket() CloseSocket(int id) . Closes the socket specified by the id parameter. The socket id is assigned by the OpenSocket() method when the socket is created. Has no return value. DisableRadio() DisableRadio() . Disables the WiFi radio. Takes no arguments and has no return value. Dispose() Dispose() . Disposes of the WiFi instance. Takes no arguments and has no return value. EnableRadio() EnableRadio() . Enables the WiFi radio. Takes no arguments and has no return value. GetConnectionSettings() GetConnectionSettings(SpiChipSelectType chipSelectType, int chipSelectLine) . Returns the SPI connection settings used to open an SPI port for communication with the WiFi module. The first parameter taken by this function specifies the type of chip select used -- only SpiChipSelectType.Gpio is supported at this time. The second parameter specifies the GPIO pin that controls the WiFi module's chip select pin. JoinNetwork() JoinNetwork(string ssid, string password) . Attempts to join the WiFi network specified by the ssid and password values. Has no return value. ListSocket() ListSocket() . Returns a string that lists all open socket clients in the format AT-S.List::<id>:<connected>:<kind>:<len>:<IP>:<port> . Takes no arguments. OpenSocket() OpenSocket(string host, int port, SPWF04SxConnectionType connectionType, SPWF04SxConnectionSecurityType connectionSecurity, string commonName) . Opens a socket client. Arguments are a string host name, an integer port number, an SPWF04SxConnectionType connection type, and a connection security type of none or Tls . Returns an integer ID number for the socket. QuerySocket() QuerySocket(int socket) . Queries a socket client for pending data. Returns an integer number of bytes that are waiting on the socket. Takes the socket id as its only argument. The socket id is returned by the OpenSocket() method when the socket is created. ReadHttpResponse() ReadHttpResponse(byte[] buffer, int offset, int count) . Reads the response to the currently active HTTP command. Arguments are a byte array buffer to store the incoming data, an integer offset into the array, and an integer count of the size in bytes of available buffer. Returns an integer value of the number of bytes read. ReadSocket() ReadSocket(int socket, byte[] buffer, int offset, int count) . Reads data from a socket client. Arguments are an integer socket ID, an input buffer byte array, an integer offset into the array, and an integer count of how many bytes can be read into the buffer array. The socket id is returned by the OpenSocket() method when the socket is created. Returns an integer number of bytes received. ResetConfiguration() ResetConfiguration() . Restores the factory configuration variables to the flash of the WiFi module. It is necessary to perform a hardware or software reset of the WiFi module after a factory restore. Takes no arguments and has no return value. SendHttpGet() SendHttpGet(string host, string path, int port, SPWF04SxConnectionSecurityType connectionSecurity) . Sends a single http get request to the given host and path to retrieve information from a server. Arguments are a string host name, a string host path, an integer port number, and a connection security type of none or Tls . Returns an integer HTTP server status code. SendHttpPost() SendHttpPost(string host, string path, int port, SPWF04SxConnectionSecurityType connectionSecurity) . Sends an HTTP post request to a remote host. Arguments are a string host name, a string host path, an integer port number, and a connection security type of none or Tls . Returns an integer HTTP server status code. SetTlsServerRootCertificate() SetTlsServerRootCertificate(byte[] certificate) . Loads a TLS certificate into the flash memory of the WiFi module. Accepts a byte array containing the certificate as its only argument. Returns a string containing the Subject Key Identifier (SKI) of the certificate. The certificate must be loaded into your application as part of a resources file, be DER encoded, and have the extension .cer. You can use your web browser to obtain a website's root certificate. In Chrome, click on the lock icon to the left of the web address. Then click on Certificate and select the Details tab. In Details click on the Copy to File... button. The Certificate Export Wizard will appear. Export the certificate as DER encoded binary X.509 (.CER) . In Micorosoft Edge click on the lock icon to the left of the web address and then select View certificate. Click on the Export to file button and save the file with a .cer extension. TurnOff() TurnOff() . Turns off the WiFi module. Takes no arguments and has no return value. TurnOn() TurnOn() . Turns on the WiFi module. Takes no arguments and has no return value. WriteSocket() WriteSocket(int socket, byte[] data) . Writes data to a socket client. Arguments are an integer ID number for the socket and a byte array of data. The socket id is returned by the OpenSocket() method when the socket is created. WriteSocket(int socket, byte[] data, int offset, int count) . Same as above but also takes integer arguments for the offset into the data array and a count for the number bytes to send. Events IndicationReceived Fires an event when a WiFi indication (WIND) message is received. ErrorReceived Fires an event when a WiFi error message is received. Properties ForceSocketsTls Boolean property that can be used to ensure a socket is opened as a secure TLS socket. For example, executing wifi.ForceSocketsTls = true; before OpenSocket() will cause the socket to be opened as a TLS Socket. ForceSocketsTlsCommonName String property used to specify the common name as found in the websites certificate. The common name is listed in the Subject Alternative Name field of the certificate. State Read only property of type SPWF04SxWiFiState that reflects the current state of the WiFi module. For example: if (wifi.State == SPWF04SxWiFiState.HardwareFailure) Debug.WriteLine(\"Hardware Failure\"); The possible states are: HardwarePowerUp , HardwareFailure , RadioTerminatedByUser , RadioIdle , ScanInProgress , ScanComplete , JoinInProgress , Joined , AccessPointStarted , HandshakeComplete , and ReadyToTransmit ."
  },
  "software/netmf/tutorials/signal-capture.html": {
    "href": "software/netmf/tutorials/signal-capture.html",
    "title": "Signal Capture",
    "keywords": "Signal Capture Introduction The SignalCapture class monitors a pin and records any changes (high-low or low-high transitions) of the pin into an array. It is a digital waveform recorder. Each array element is the number of microseconds between each signal change. SignalCapture is a GHI Electronics' extension to NETMF. It requires the GHI.Hardware assembly. using System.Threading; using Microsoft.SPOT.Hardware; using GHI.IO; public class Program { public static void Main() { uint[] signal = new uint[100]; SignalCapture pin = new SignalCapture(Cpu.Pin.GPIO_Pin1, Port.ResistorMode.Disabled); pin.Read(false, signal); // ... // process the \"signal\" } } Timeouts When calling read, it blocks until it has read as much data as the buffer can hold or you specify using the count parameter. If your signal is shorter than that, the call will never return. Make sure to request only what you plan to capture. Alternatively, you can use the ReadTimeout property to signal to the call to return after the number of milliseconds specified by the property regardless of how much data you captured."
  },
  "software/netmf/tutorials/rtc.html": {
    "href": "software/netmf/tutorials/rtc.html",
    "title": "Real Time Clock",
    "keywords": "Real Time Clock Introduction Systems typically have a Real Time Clock (RTC) that uses a backup battery (VBAT) and a separate crystal to keep time running even if the system is not powered. Typical crystal value is 32.768Khz. Consult your product's documentation to see if it has a built in RTC. Note: NETMF has time services that you can use to get/set the system time such as DateTime.Now. When power is lost or the system is reset, the time is also reset. Those services do not need RTC. An application can set proper time by reading from the RTC (running from a separate always-on power) or from the internet through a time server. Not having RTC will not limit NETMF's time services beyond resetting the date and time to a preset value. Time measurement is still available. Time via NETMF This example sets the current time to a predefined value that is lost when power is lost. using System; using System.Threading; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { //Set the time to 07/25/2012 at 11:46:11 DateTime time = new DateTime(2012, 07, 25, 11, 46, 11); // lost after power cycle or reset: Utility.SetLocalTime(time); while (true) { Debug.Print(DateTime.Now.ToString()); Thread.Sleep(100); } } } Using GHI's extension for Real Time Clock To use the RTC hardware, we first need to check if the RTC hardware has the valid time or not. If RTC has a valid time then we can read from the RTC and use that to set the NETMF system time. If time is not valid, then you will need to set the RTC to the correct time. You can verify the validilty of the RTS several ways. One way is to use the built in battery ram (if available) to store some \"magic numbers\" that we check later to determine if the battery ram data is still valid. If they are then most likely the RTC is valid. You can also check the RTC against some known time. For example, if your program was written on 1/1/2014, you can check to see if the current RTC date is before that known date. If it is, then the time is incorrect. using System; using GHI.Processor; using Microsoft.SPOT; public class Program { public static void Main() { DateTime DT; try { DT = RealTimeClock.GetDateTime(); Debug.Print(\"Current Real-time Clock \" + DT.ToString()); } catch // If the time is not good due to powerloss or being a new system an exception will be thrown and a new time will need to be set { Debug.Print(\"The date was bad and caused a bad time\"); DT = new DateTime(2014, 1, 1, 1, 1, 1); // This will set a time for the Real-time Clock clock to 1:01:01 on 1/1/2014 RealTimeClock.SetDateTime(DT); //This will set the hardware Real-time Clock to what is in DT } if (DT.Year < 2011) { Debug.Print(\"Time is not resonable\"); } Debug.Print(\"Current Real-time Clock \" + RealTimeClock.GetDateTime().ToString()); DT = new DateTime(2014, 9, 15, 7, 30, 0); // This will set the clock to 9:30:00 on 9/15/2014 RealTimeClock.SetDateTime(DT); //This will set the hardware Real-time Clock to what is in DT Debug.Print(\"New Real-time Clock \" + RealTimeClock.GetDateTime().ToString()); } }"
  },
  "hardware/loaders/intro.html": {
    "href": "hardware/loaders/intro.html",
    "title": "Bootloaders Introduction",
    "keywords": "Bootloaders Introduction A bootloader is a small software that boots up the system and runs the firmware. It is also used to update the firmware. Our products ship with the GHI Bootloader preloaded. This simplifies the firmware update process, especially when using the TinyCLR Config tool. GHI Bootloader The GHI Bootloader page describes the bootloader commands and how to use the bootloader to load firmware onto a device. STM32 Bootloader The STM32 Bootloader page covers loading .hex, .bin, and .dfu files onto our STM32 based devices. This includes loading the GHI Bootloader onto ST based products. SAM-BA Bootloader The SAM-BA Bootloader lives on many Atmel chips. It is necessary to load files (loaders and/or firmware) onto the chip. Several TinyCLR OS supported boards will use this loader to load the GHI Bootloader."
  },
  "hardware/gadgeteer/modules.html": {
    "href": "hardware/gadgeteer/modules.html",
    "title": ".NET Gadgeteer Modules",
    "keywords": ".NET Gadgeteer Modules This page lists all .NET Gadgeteer modules. All sources are found on the NETMF and Gadgeteer repo Accel G248 The Accel G248 measures acceleration though I2C bus. Schematic Barometer Measures pressure. Schematic Bluetooth Schematic Breadboard X1 An easy breadboard option. Simply access the socket directly to wire whatever your heart desires! Schematic Breakout Simply a breakout of all signals. Schematic Breakout TB10 Simply a breakout of all signals, on a terminal block. Schematic Button The Button module is very simple, with a button connected to pin 3 and an LED connected to pin4. Schematic Button S7 7 buttons on a single module, with LEDs that light up with button presses! Use the same code example provided for the Button Module. Buttons map: Left: Pin Right: Pin 8 Up: Pin 6 Down: Pin 7 Enter: Pin 3 Back: Pin 4 Forward: Pin 9 Schematic CAN DW Schematic Camera Schematic Cellular Radio Gadgteer driver Schematic Character Display This is a standard and very common HD44780 display. Schematic ColorSense A color sensor that uses software I2C, not yet supported in TinyCLR OS. Schematic Compass Schematic Current ACS712 This is a current sensor that uses ACS712, which simply outputs an analog voltage. Schematic Display CP7 The configurations for the display: // these are the wrong values! Width = 800, Height = 480, PixelClockRate = 24 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 16, HorizontalBackPorch = 46, HorizontalSyncPulseWidth = 1, HorizontalSyncPolarity = true, VerticalFrontPorch = 7, VerticalBackPorch = 23, VerticalSyncPulseWidth = 1, VerticalSyncPolarity = true, Schematic Display N18 This is an SPI display that can work on any system with SPI bus, even small ones without TFT display support. Schematic Display N7 The configurations for the display: Width = 800, Height = 480, PixelClockRate = 24 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 16, HorizontalBackPorch = 46, HorizontalSyncPulseWidth = 1, HorizontalSyncPolarity = true, VerticalFrontPorch = 7, VerticalBackPorch = 23, VerticalSyncPulseWidth = 1, VerticalSyncPolarity = true, Schematic Display NHVN This allows the use of several displays offered by http://newhavendisplay.com/ Supported displays: NHD-4.3-480272EF-ATXL# NHD-4.3-480272EF-ATXL#-CTP NHD-4.3-480272EF-ATXL#-T NHD-7.0-800480EF-ATXL# NHD-7.0-800480EF-ATXL#-CTP NHD-7.0-800480EF-ATXV# NHD-7.0-800480EF-ATXV#-CTP The configurations for all 4.3\" display: Width = 480, Height = 272, PixelClockRate = 20 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, The configurations for all 7\" display: Width = 800, Height = 480, PixelClockRate = 20 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 88, HorizontalBackPorch = 40, HorizontalSyncPulseWidth = 48, HorizontalSyncPolarity = false, VerticalFrontPorch = 13, VerticalBackPorch = 32, VerticalSyncPulseWidth = 3, VerticalSyncPolarity = false, As for the capacitive touch controller, use this old NETMF driver code as a reference: public class FT5306Controller { private InterruptPort touchInterrupt; private I2CDevice i2cBus; private I2CDevice.I2CTransaction[] transactions; private byte[] addressBuffer; private byte[] touchDataBuffer; private byte[] touchCountBuffer; public delegate void TouchEventHandler(FT5306Controller sender, TouchEventArgs e); public event TouchEventHandler TouchDown; public event TouchEventHandler TouchUp; public event TouchEventHandler TouchMove; public FT5306Controller(Cpu.Pin interruptPin) { this.transactions = new I2CDevice.I2CTransaction[2]; this.addressBuffer = new byte[1]; this.touchDataBuffer = new byte[4]; this.touchCountBuffer = new byte[1]; this.i2cBus = new I2CDevice(new I2CDevice.Configuration(0x38, 400)); this.touchInterrupt = new InterruptPort(interruptPin, false, Port.ResistorMode.Disabled, Port.InterruptMode.InterruptEdgeBoth); this.touchInterrupt.OnInterrupt += (a, b, c) => this.OnTouchEvent(); } private void OnTouchEvent() { var points = this.ReadData(2, this.touchCountBuffer)[0]; for (var i = 0; i < points; i++) { var data = this.ReadData(i * 6 + 3, this.touchDataBuffer); var flag = (data[0] & 0xC0) >> 6; var x = ((data[0] & 0x0F) << 8) | data[1]; var y = ((data[2] & 0x0F) << 8) | data[3]; var handler = flag == 0 ? this.TouchDown : flag == 1 ? this.TouchUp : flag == 2 ? this.TouchMove : null; if (handler != null) handler(this, new TouchEventArgs { X = x, Y = y }); } } private byte[] ReadData(int address, byte[] resultBuffer) { this.addressBuffer[0] = (byte)address; this.transactions[0] = I2CDevice.CreateWriteTransaction(this.addressBuffer); this.transactions[1] = I2CDevice.CreateReadTransaction(resultBuffer); this.i2cBus.Execute(this.transactions, 500); return resultBuffer; } public class TouchEventArgs : EventArgs { public int X { get; internal set; } public int Y { get; internal set; } } } Schematic Display T35 The configurations for the display: Width = 320, Height = 240, PixelClockRate = 15 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 51, HorizontalBackPorch = 27, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 16, VerticalBackPorch = 8, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Schematic Display T43 The configurations for the display: Width = 480, Height = 272, PixelClockRate = 20 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Schematic Display TE35 The configurations for the display: Width = 320, Height = 240, PixelClockRate = 15 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 51, HorizontalBackPorch = 29, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 16, VerticalBackPorch = 3, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Schematic Distance US3 A very common ultrasonic sensor that works by sending a pulse on the trig Pin4 and measuring the response time on echo Pin3. Schematic Ethernet ENC28 Schematic Ethernet J11D Schematic Extender Schematic FEZtive Schematic Flash Schematic GPS Schematic GasSense This module can host several different air sensors, like Alcohol and CO2. The sensor has an internal heater on pin 4 that needs to be enabled and then it is a simple analog read on pin 3. Schematic Gyro Schematic HD44780 See the Character Display Module Schematic HubAP5 No hub support is currently planned. Schematic IO60P16 Schematic IR Receiver Schematic Joystick The Joystick module has two analog inputs for X (pin 4) and Y (pin 5) position. Pressing the knob also works like a button (pin 3). Schematic Keypad KP16 Schematic LED 7C An LED that can be set to one of 7 colors, 8 if you count off! Schematic LED 7R This is a ring of 6 LEDs and a 7th center LED. Reference the LED 7C module for using pins. Center LED: pin 9 LEDs going clockwise starting from LEDs D1 to D6 on the board D1, D2, D3, D4, D5, D6 are pins 3 to 8 respectively. Schematic LED Strip A strip of 7 LEDs, connected to pins 3 through 9. Reference the LED 7C module for using pins. Schematic Light Sense Simply using analog on pin 3. Use the same code as the potentiometer. Schematic Load Each one of the 7 GPIO pins are connected to a transistor to handle a load, like a motor. Schematic MaxO Shift registers used to take serial SPI data and put on parallel pins, perfect for driving tons of LEDs! Schematic MicroSD Card Schematic Moisture This is a simple analog input measuring the direct resistance (moisture) on pin 3. An enable pin needs to be activated on pin 6. Schematic Motor Driver The Motor Driver Module uses L298 H-bridge that can drive two motors up to 4A. Pin 6: Motor A Direction (GPIO) Pin 7: Motor A Speed (PWM) Pin 8: Motor B Direction (GPIO) Pin 9: Motor B Speed (PWM) Schematic Multicolor LED Schematic Music The Music Module uses the popular VS1053 decoder chip that decodes MP3, WMA, OGG, MIDI and WAV files. Schematic Null Modem No driver is needed. OBD II OneWire X1 A breakout with a terminal block for easily connecting OneWire devices, specifically the common temperature probes. Schematic PIR Motion detection. Simply pin 3 changes its state when it detects motion. Schematic Parallel CNC Schematic Potentiometer The Potentiometer module is simply a variable resistor connected to pin3. Rotating its knob will result in an analog value changing from min to max. Schematic Pulse Count Schematic Pulse InOut Schematic Pulse Oximeter Schematic RFID Reader Schematic RS232 Simply a serial port. Schematic RS485 Simply a serial port. Schematic Radio FM1 Schematic Reflector R3 Schematic Relay ISOx16 An array of 16 relays. Operate similar to the MaxO module. Schematic Relay X1 Simply set pin 3 high to activate the relay. Schematic Rotary H1 Schematic SD Card Schematic S-Plus Schematic Serial Camera Stepper L6470 Schematic TempHumidity Schematic Thermocouple Schematic Touch C8 Schematic Touch L12 Schematic Tunes The Tunes Module is a tiny speaker that is connected to pin 9. Use PWM to generate sounds Schematic UC Battery 4xAA No driver is needed. Schematic USB Client DP No driver is needed. Schematic USB Client SP No driver is needed. Schematic USB Host Schematic USB Serial Simply, a serial port. Schematic USB Serial SP Simply, a serial port. Schematic VideoOut Schematic WiFi RN171 Schematic WiFi RS21 Schematic XBee Adapter Simply, a serial port. From there a driver like https://xbee.codeplex.com/ will help. Schematic"
  },
  "hardware/gadgeteer/fez-hydra.html": {
    "href": "hardware/gadgeteer/fez-hydra.html",
    "title": "FEZ Hydra",
    "keywords": "FEZ Hydra FEZ Hydra is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). To use with NETMF/Gadgeteer, follow these setup instructions . Resources Schematic"
  },
  "hardware/gadgeteer/fez-cerberus.html": {
    "href": "hardware/gadgeteer/fez-cerberus.html",
    "title": "FEZ Cerberus",
    "keywords": "FEZ Cerberus FEZ Cerberus is a .NET Gadgeteer product that utilizes .NET Micro Framework (NETMF). The core of the FEZ Cerberus is the G30 System on Chip (SoC). FEZ Cerberus is the mother of the Cerb Family! To use with NETMF/Gadgeteer, follow these setup instructions . Resources Schematic FEZ Game-O A programmable game console based on the FEZ Cerberus that was funded with a successful kickstarter campaign. The FEZ Game-O combine a 320 x 240 color display, 3D accelerometer and audio circuitry within an attractive, ergonomic enclosure. Schematic"
  },
  "hardware/gadgeteer/fez-raptor.html": {
    "href": "hardware/gadgeteer/fez-raptor.html",
    "title": "FEZ Raptor",
    "keywords": "FEZ Raptor FEZ Raptor is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Raptor is the G400S System on Module (SoM). Follow the instructions on the G400S page to learn how to use FEZ Raptor with NETMF and TinyCLR OS. Resources Schematic Tip To activate bootloader v2, press and hold the LDR0 button while resetting the board."
  },
  "hardware/gadgeteer/fez-cerbot.html": {
    "href": "hardware/gadgeteer/fez-cerbot.html",
    "title": "FEZ Cerbot",
    "keywords": "FEZ Cerbot A robot with reflective sensors and tons of LEDs. Gadgeteer sockets are used as an easy way to add features. Resources Schematic Software For information on programming the FEZ Cerbot, please go to the FEZ Cerberus page."
  },
  "hardware/raspberrypi-hats.html": {
    "href": "hardware/raspberrypi-hats.html",
    "title": "Raspberry Pi Hats",
    "keywords": "Raspberry Pi Hats Several HATs were made for the RPI. The software was focused on the use of Win10. This GitHub repo includes the software for all HATs. FEZ HAT Schematic FEZ ProtoPi Schematic FEZ Utility Schematic FEZ Cream This HAT was part of the Gadgeteering efforts. Schematic Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/breakout/fez-rhino.html": {
    "href": "hardware/breakout/fez-rhino.html",
    "title": "FEZ Rhino",
    "keywords": "FEZ Rhino Resources Schematic Software For information about programming the FEZ Rhino, please visit our USBizi page."
  },
  "README.html": {
    "href": "README.html",
    "title": "Docs",
    "keywords": "Docs This is the repository for all of our docs. To generate the docs locally: Clone/Fork the repo Open the command prompt in the documents' root folder (\"Run as Administrator\" may be necessary) Execute docfx --serve After executing the above command, a temporary webpage will appear to allow you to view the files in your browser fully rendered in HTML, for example http://localhost:8080 . To install DocFX, please review and download from the following site: https://dotnet.github.io/docfx/ . From there, you can go to the Getting Started page for instructions on how to install and you can go to Download Latest to download the most up to date DocFX files. Please note, you will not need to use the docfx init command as the initial JSON file is already present in our repository. WK<html>TOpdf is required as part of the build process. You will find the needed files at the following address: https://wkhtmltopdf.org/downloads.html . Once downloaded, execute the command to install. Once installed, add the path to the installed binary to the environment variable PATH, for example \"C:\\Program Files\\wkhtmltopdf\\bin\"."
  },
  "hardware/components/spwf04sa.html": {
    "href": "hardware/components/spwf04sa.html",
    "title": "Updating the SPWF04SA Wi-Fi Module Firmware",
    "keywords": "Updating the SPWF04SA Wi-Fi Module Firmware Warning Before updating the Wi-Fi firmware, erase all applications on the host board to prevent them from interfering with the upgrade process and to prevent possible damage to the host processor. When the WiFi module starts, it sends a PowerOn message which tells you what firmware version is installed. For example, PowerOn 171117-0328fe3-SPWF04S . In this case the firmware is dated 17 November 2017. Requirements To upgrade the WiFi module's firmware, you must first download and install the following: Flash Loader Demonstrator from STMicroelectronics . Firmware files from STMicroelectronics . You will also need: A USB to serial adapter. We were successful using the FTDI TTL-232R-3V3 Cable. Some older USB to serial adapters will not work. Some jumper wires. Tip For the USB to serial adapter you can use the Gadgeteer USB-Serial Module with a Gadgeteer Breadboard. Connect the module socket to the breadboard socket using a ribbon cable. You must also power the breadboard by connecting GND and 3.3V from the FEZ to the corresponding breadboard connectors. Erase the Host Firmware Before updating the Wi-Fi module firmware, you must erase the firmware on the host board or SoM. This is accomplished using terminal software while the board is in bootloader mode. The instructions are very similar to the instructions for manually loading firmware . Connect the board to your computer's USB port. Put your board in bootloader mode. Each product has a specific way to enter the boot loader. Open any terminal software, for example Tera Term . Select serial and pick the COM port associated with your board (if unsure, check Device Manager). Press E and then enter to start the erasing procedure. Press Y to confirm, then enter. Connect the WiFi Module Before updating the WiFi firmware, you must first connect the following pins (Pictures show FEZ board. See table below for other devices): Connect BOOT0 of the WiFi module to a 3.3 volt source. Connect the GND pin of the USB to serial adapter to a GND pin on the host board. Note: You don't need this connection if you will be powering the device from your computer's USB port. Connect the RX pin of the USB to serial adapter to TXD of the WiFi module. Connect the TX pin of USB to serial adapter to RXD of WiFi module. Power up the board and connect the USB to serial adapter to your PC. You are now ready to flash the WiFi module. WiFi Pin Name FEZ UC2550/UC5550 UCM Dev Board UCM Breakout Board BOOT0 Header H1 pin 1 SO-DIMM pin 108 HDR B MS2 MS2 TXD Header H1 pin 2 SO-DIMM pin 93 HDR A SPI B MISO SPI B MISO RXD Header H1 pin 3 SO-DIMM pin 94 HDR A SPI B MOSI SPI B MOSI GPIO 0 WGPIO pin 0 SO-DIMM pin 36 HDR B MS5 N/A Flash the WiFi Module Launch Flash Loader Demonstrator by selecting Demonstrator GUI in the Windows Start Menu. Make sure to select the port name for the USB to serial adapter you are using. Set the baud rate to 115200, parity to even, disable echo, and set timeout to 20. Then click the Next button. If you can't find the serial port for your USB to serial adapter, you might have to install its device driver. If its device driver is installed you should see it in Device Manager under Ports (COM & LPT) . Click the Next button. If all steps were done correctly you should see: Click the Next button and then choose your device in the dropdown menu. After selecting your device click on the Next button. Click the Download to device radio button and then select the WiFi firmware file you downloaded earlier. This file is a .hex file called SPWF04S-xxxxxx-xxxxxxx-Full.hex . If you are searching for the file, make sure to search for a .hex file. Click the Next button to copy this file to the WiFi module. It will take a few minutes to erase the old firmware and copy the new firmware to the WiFi module. When update is done, remove all wires and load the firmware on the board. Reset the board. Next you need to reset the WiFi module to its factory settings. Reset Factory WiFi Settings After each update you must reset the WiFi module to its factory settings: Unplug the board or SoM. Connect a jumper wire from GPIO 0 of the WiFi module to a 3.3 volt source. Power up the board. Remove the jumper wire and reset the device."
  },
  "hardware/fez/intro.html": {
    "href": "hardware/fez/intro.html",
    "title": "Introduction",
    "keywords": "Introduction The Maker Board to Rule Them All! FEZ (fast and easy) is our magnificent maker board. This low cost board offers Arduino pinout compatibility, optional WiFi for IoT applications, and can be programmed using multiple programming languages and development environments. However, we are focused on TinyCLR OS support to program the board in .NET C# and Visual Basic. Pricing, purchasing and other information can be found on the FEZ page on our main website. Spec Value Processor STMicroelectronics ST32F401RET6 Speed 84 MHz Internal RAM 96 KByte Internal Flash 512 KByte Dimensions 70.6 x 56.0 x 14.5 mm Peripheral Quantity GPIO (5V tolerant) 22 IRQ 22 UART 1 I2C 1 SPI 1 PWM 8 12 Bit ADC 8 CAN 0 USB Client 1 WiFi Optional * Note: Many peripherals share I/O pins. Not all peripherals will be available to your application. Resources Schematic TinyCLR Tutorials Instructions for updating the WiFi module firmware. FEZ can be powered through the USB connector and/or the power connector. The barrel jack is pin positive, sleeve negative, 2.1mm. It is capable of anywhere 6V to 9V. 500mA of power should be enough for most needs. TinyCLR OS TinyCLR OS provides a way to program FEZ in C# or Visual Basic from the Microsoft Visual Studio integrated development environment. To get started you must first install the bootloader and firmware (instructions below) and then go to the TinyCLR Getting Started page for instructions. Loading Bootloader Download the FEZ bootloader here . Connect your device to the USB client port. Put the board in DFU mode: Hold BOOT0 button low and press/release the reset button. Wait for a second then release BOOT0. Windows Device Manager will now show \"STM Device in DFU Mode\" under the 'Universal Serial Bus controller' TAB. Go to the STM32 Bootloader to learn how to upload DFU files. Loading the Firmware Activate the bootloader, hold the BTN1 button low while resetting the board. Open TinyCLR Config tool. Click the loader tab. Select the correct COM port. If you are not seeing it then the device is not in the loader mode. Click the Update to Latest button. You can also update the firmware manually. Download the firmware and learn how to use the GHI Bootloader manually. Start Coding Now that you have installed the bootloader and firmware on the FEZ, you can setup your host computer and start programming. Go to the TinyCLR Getting Started page for instructions. Code Samples For some examples of using TinyCLR, take a look at the TinyCLR Samples repo . You may also find the TinyCLR tutorials useful. Native Code TinyCLR OS also lets you use native code that works alongside your managed application. Native code can be used to provide improved performance or access to advanced features not exposed through TinyCLR. For more information check out Native Code on TinyCLR . The memory area reserved for native code in TinyCLR OS on FEZ starts at 0x20016000 and its length is 0x3F8. Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/duino/fez-cobra-iii.html": {
    "href": "hardware/duino/fez-cobra-iii.html",
    "title": "FEZ Cobra III",
    "keywords": "FEZ Cobra III An Arduino-pinout compatible single board computer. Resources Schematic Software For information on programming the FEZ Cerbuino Bee, please go to the G120 page."
  },
  "hardware/breakout/g400-th.html": {
    "href": "hardware/breakout/g400-th.html",
    "title": "G400 TH Module",
    "keywords": "G400 TH Module A through-hole version of G400. Resources Schematic Software For information on programming the G400 TH Module please refer to the G400D page."
  },
  "software/tinyclr/downloads.html": {
    "href": "software/tinyclr/downloads.html",
    "title": "Downloads",
    "keywords": "Downloads This page includes different download types for individual boards. See individual product pages for details on what to download. See Release notes here . Software status legend: Status Meaning Production Ready to be used commercially. Preview Preview of the next release, not quite ready for production use. Alpha Bleeding edge development that will frequently change. Major changes to come. Visual Studio Project System The extension is what gets loaded on Visual Studio to allow it to communicate with a TinyCLR OS device. It also includes project templates. You can find it on Visual Studio Marketplace instead of downloading it here. File Date Status MD5 v1.0.0 2018-12-27 Production 2CDD88E2203716781CA0735FEAE2BBE3 v1.0.0-preview3 2018-11-30 Preview 2A8507F721886572CD82F7A13E627F1D v1.0.0-preview2 2018-09-28 Preview 9854917F72723AE94B005420A8F6512D v1.0.0-preview1 2018-08-15 Preview 049923C25A981EF84E2CFB25CFB87855 Libraries Libraries provide prebuilt ways of performing many common tasks. You can find them on NuGet instead of downloading them here. File Date Status MD5 v1.0.0 2018-12-27 Production 4EB8D0C9DBD8AABA8C48716256099924 v1.0.0-preview3 2018-11-30 Preview B93555882C59A679A8D17EA2E22F0858 v1.0.0-preview2 2018-09-28 Preview 6D5BA0E125FC42CDA7D2C893CEDB5F7C v1.0.0-preview1 2018-08-15 Preview DF7DAB3754DE092D787D48ECBE42B82B TinyCLR Config TinyCLR Config is a tool used to update and configure your TinyCLR device. File Date Status MD5 v1.0.0 2018-12-27 Production FFA158A503EBEA0D9F812007608A1974 v1.0.0-preview3 2018-11-30 Preview 45A6CFEC728C5EF53F0C584A46238CAE v1.0.0-preview2 2018-09-28 Preview C5B237C27470DC9BF3D16050865E0610 v1.0.0-preview1 2018-08-15 Preview 1FD781BADFFB37E7593FFF98673D95AA TinyCLR Font Converter The font converter is a tool used to convert desktop TrueType fonts to the format used by TinyCLR OS. File Date Status MD5 v1.0.0 2018-12-27 Production 9FBDD44955F51BDBE83BBAB4CAD25616 v1.0.0-preview3 2018-11-30 Preview 804A90F030F3CEF3259D3A03A42E3B2F v1.0.0-preview2 2018-09-28 Preview A74BC85A573BD99DFA4302750F8D9E4C Firmwares The Firmware is the TinyCLR OS that lives on your hardware. The firmware version loaded on the hardware must match the version number of the extension and the libraries. This will be easier managed once the libraries are hosted on http://www.nuget.org/ FEZCLR (works on FEZ and BrainPad) This is the reference firmware for TinyCLR OS. File Date Status MD5 v1.0.0 2018-12-27 Production C089598B40CC7398DD7BBC3723D25D0E v1.0.0-preview3 2018-11-30 Preview B1C3DFB4B6DB4852D67A855158CDCAE4 v1.0.0-preview2 2018-09-28 Preview 03220638702C54F20FE05DDF0910BB1D v1.0.0-preview1 2018-08-15 Preview A98A9C45C368C5C3211829DD1BC7DF53 UC2550 File Date Status MD5 v1.0.0 2018-12-27 Production 97F2BA54A92107CBFB5DDA029E58DA42 v1.0.0-preview3 2018-11-30 Preview B958DAAF4B377CC47B4FE6C30A52B016 v1.0.0-preview2 2018-09-28 Preview BCE56802BCD475CF93673019ED18B134 v1.0.0-preview1 2018-08-15 Preview 99D87C4B379A51313191494CD8A606CF UC5550 File Date Status MD5 v1.0.0 2018-12-27 Production BE4D80D4F88AA0902F25E8353148D2F8 v1.0.0-preview3 2018-11-30 Preview 450F3071EE30FE35FE2502B68136A684 v1.0.0-preview2 2018-09-28 Preview D8ADA0EAC6396E38F0DB4115B2DD1EB4 v1.0.0-preview1 2018-08-15 Preview AFD0FF5599985FA96D6150D3A3F3CE76 G30 File Date Status MD5 v1.0.0 2018-12-27 Production B3A3BC288A4776506D40198847AFAB85 v1.0.0-preview3 2018-11-30 Preview 9F337D2FF1A09D3C131CBB45ED0EFC36 v1.0.0-preview2 2018-09-28 Preview AA60EABD7624E3185F3EBC2EFEDD2D88 v1.0.0-preview1 2018-08-15 Preview B7BBB3D880BFB1DF3F37F41E83F5C04D G80 File Date Status MD5 v1.0.0 2018-12-27 Production CE90C3F05C6193A68C42E7D4C3A5AB80 v1.0.0-preview3 2018-11-30 Preview B71EF151548AB758ADC5B23D0E72667E v1.0.0-preview2 2018-09-28 Preview EBA094B56E2A904B8EC7C4AEDA8FE0D8 v1.0.0-preview1 2018-08-15 Preview D438734607EA7AA1D155B1572BE224B8 G120 File Date Status MD5 v1.0.0 2018-12-27 Production 482C2ADE1B27675A5457D8894D43BB6F v1.0.0-preview3 2018-11-30 Preview 6E448DA35B0B00F3FE765BB111FE6F99 v1.0.0-preview2 2018-09-28 Preview AADC660AE9A307F434C436D2CF8127B9 v1.0.0-preview1 2018-08-15 Preview 21D96730FDECB36462CD86BA1836B475 G400 File Date Status MD5 v1.0.0 2018-12-27 Production DF863A79DE30F5C4C204B2F6EE0ED4FE v1.0.0-preview3 2018-11-30 Preview C12433036607BA792456C2A2F40C1995 v1.0.0-preview2 2018-09-28 Preview 4DD79332EC91138B0D60D7BF443684E3 v1.0.0-preview1 2018-08-15 Preview 35F33ECA41C54281497691EFC79F8CB0"
  },
  "software/netmf/tutorials/xtea.html": {
    "href": "software/netmf/tutorials/xtea.html",
    "title": "XTEA",
    "keywords": "XTEA Introduction XTEA is a secure encryption algorithm, though not as secure as RSA or others, that uses a 128bit key and requires very little processing power. Make sure you only attempt to encrypt arrays with a size divisible by eight. Getting Started The following example shows the basic encryption and decryption of a string. When you use the parameterless constructor of the Xtea object, a key is generated for you that you can find in the Key property. If you pass a key to the constructor, it will be used instead. using GHI.Utilities; using Microsoft.SPOT; using System.Text; public class Program { public static void Main() { var xtea = new Xtea(); var encrypted = xtea.Encrypt(Encoding.UTF8.GetBytes(\"0123456776543210\")); var decrypted = xtea.Decrypt(encrypted); Debug.Print(new string(Encoding.UTF8.GetChars(decrypted))); //should be \"0123456776543210\" var keyStr = \"0x\"; for (int i = 0; i < Xtea.KeyLength; i++) keyStr += xtea.Key[i].ToString(\"x2\"); Debug.Print(\"The key used was \" + keyStr); } }"
  },
  "software/netmf/tutorials/uart.html": {
    "href": "software/netmf/tutorials/uart.html",
    "title": "UART",
    "keywords": "UART UART transfers data between two pins TXD (transmit) and RXD (receive). Normally, the pins are on different processors. Data is sent from TXD, in a sequence, at a predefined speed. The receiver checks data on RXD. Usually systems want to send and recieve as well, so there will be a TXD and RXD on one end with another set on the other end. The connection in between is rossed so TXD on one end goes to RXD on the other end and vice versa. UART Technical Details The \" baud rate\" is number of bits are transmitted per second; standard baud rates are 9600, 119200, 115200 and others. Direct connection between TXD/RXD pins use their high/low voltages for bits (\"TTL level,\" 0V to 3.3V). NETMF supports serial ports (UART) in the same way as the full .NET framework. Serial ports on PC's and on NETMF are called \"COM ports.\" Their names start with COM1 and go up (there is no COM0). Processors usually start with UART0 not UART1 (so, COM1 is UART0... etc.) Software UART Through GHI's SignalGenerator, a system can simulate a UART data. This is beneficial as any GPIO pin can be used to send the UART data. A good example is a serial character display. These typically do not require speed and not updated frequently. If all UARTs are being used, any GPIO can be used to simulate a UART transmission. RS232 Processor pins can be set at 0 for low or at the power level for high, 3.3V for example. This means connecting outputs on a micro to inputs on another is safe. These levels are called TTL. In our case here a TTL UART levels. To overcome distances, the very old standard RS232 defined the low state to be +12V. Sounds like it is backwards but this is how it is! This port is found on many systems and found on many PCs. It has been disappearing from PCs lately but this can be easily added using a USB to serial cable. We can't connect the RS232 levels to TTL levels directly. This is easily solved by adding a small circuitry that converts the RS232 levels to TTL, like the MAX232 chip. In other words, do not connect a PC's serial port to a micro directly. Use a level converter in between. Example using UART The following program sends a counter value 10 times per second. The data is sent at 115200 baud so make sure that the receiving end is setup the same way. This program sends the data on COM1 of your NETMF device. This COM number has nothing to do with COM number on your PC. For example, you may have a USB serial port on your PC that maps to COM8 and so you need to open COM8 on your PC, not COM1. The NETMF program will still use COM1 because it uses UART0 (COM1). The data sent can be shown on a terminal program, like teraterm. Note how we ended the string with \"\\r\\n\". The \"\\r\" is code to tell the terminal to \"return\" back to the beginning of the line and \"\\n\" is to add \"new\" line. When data is received on UART, it is automatically queued a side so you wouldn't lose any data. Tip Using serial ports require the Microsoft.SPOT.Hardware.SerialPort. If your program uses the enums Parity or StopBits, the Microsoft.SPOT.Hardware assembly is needed. using System.IO.Ports; using System.Text; using System.Threading; public class Program { public static void Main() { SerialPort UART = new SerialPort(\"COM1\", 115200); int counter = 0; UART.Open(); while (true) { // create a string string counter_string = \"Count: \" + counter.ToString() + \"\\r\\n\"; // convert the string to bytes byte[] buffer = Encoding.UTF8.GetBytes(counter_string); // send the bytes on the serial port UART.Write(buffer, 0, buffer.Length); // increment the counter; counter++; //wait... Thread.Sleep(100); } } } Receiving Data This example will wait until a byte is received on the port and then print it telling you what was sent from the other end. using System.Threading; using System.IO.Ports; using System.Text; public class Program { public static void Main() { SerialPort UART = new SerialPort(\"COM1\", 115200); int read_count = 0; byte[] rx_byte = new byte[1]; UART.Open(); while (true) { // read one byte read_count = UART.Read(rx_byte, 0, 1); if (read_count > 0)// do we have data? { // create a string string counter_string = \"You typed: \" + rx_byte[0].ToString() + \"\\r\\n\"; // convert the string to bytes byte[] buffer = Encoding.UTF8.GetBytes(counter_string); // send the bytes on the serial port UART.Write(buffer, 0, buffer.Length); //wait... Thread.Sleep(10); } } } } Sending and Receiving This example is a loop-back. Connect a wire from TX to RX on your board and it will send data and make sure it is receiving it correctly. using System.IO.Ports; using System.Text; using System.Threading; using Microsoft.SPOT; public class Program { public static void Main() { SerialPort UART = new SerialPort(\"COM1\", 115200); int read_count = 0; byte[] tx_data; byte[] rx_data = new byte[10]; tx_data = Encoding.UTF8.GetBytes(\"FEZ\"); UART.ReadTimeout = 0; UART.Open(); while (true) { // flush all data UART.Flush(); // send some data UART.Write(tx_data, 0, tx_data.Length); // wait to make sure data is transmitted Thread.Sleep(100); // read the data read_count = UART.Read(rx_data, 0, rx_data.Length); if (read_count != 3) { // we sent 3 so we should have 3 back Debug.Print(\"Wrong size: \" + read_count.ToString()); } else { // the count is correct so check the values // I am doing this the easy way so the code is more clear if (tx_data[0] == rx_data[0]) { if (tx_data[1] == rx_data[1]) { if (tx_data[2] == rx_data[2]) { Debug.Print(\"Perfect data!\"); } } } } Thread.Sleep(100); } } } Tip For .NET Gadgeteer examples, see the Device to PC communications document."
  },
  "software/netmf/tutorials/touch.html": {
    "href": "software/netmf/tutorials/touch.html",
    "title": "Touch",
    "keywords": "Touch Introduction NETMF devices have the ability to receive touch input from a touch screen. Getting Started The below code draws a blue circle wherever you touch on the display. Make sure that you have configured your display properly before running this example. It requires the Microsoft.SPOT.Graphics, Microsoft.SPOT.TinyCore, and Microsoft.SPOT.Touch assemblies. using Microsoft.SPOT; using Microsoft.SPOT.Input; using Microsoft.SPOT.Presentation; using Microsoft.SPOT.Presentation.Media; using Microsoft.SPOT.Touch; public class Program : Application { private Bitmap lcd; public static void Main() { Program app = new Program(); app.Run(); } public Program() { this.lcd = new Bitmap(SystemMetrics.ScreenWidth, SystemMetrics.ScreenHeight); Touch.Initialize(this); this.MainWindow = new Window(); this.MainWindow.TouchDown += MainWindow_TouchDown; this.MainWindow.TouchUp += MainWindow_TouchUp; this.MainWindow.TouchMove += MainWindow_TouchMove; } private void MainWindow_TouchMove(object sender, TouchEventArgs e) { Debug.Print(\"Touch move at (\" + e.Touches[0].X.ToString() + \", \" + e.Touches[0].Y.ToString() + \")\"); this.lcd.DrawEllipse(Colors.Blue, e.Touches[0].X, e.Touches[0].Y, 5, 5); this.lcd.Flush(); } private void MainWindow_TouchUp(object sender, TouchEventArgs e) { Debug.Print(\"Touch up at (\" + e.Touches[0].X.ToString() + \", \" + e.Touches[0].Y.ToString() + \")\"); } private void MainWindow_TouchDown(object sender, TouchEventArgs e) { Debug.Print(\"Touch down at (\" + e.Touches[0].X.ToString() + \", \" + e.Touches[0].Y.ToString() + \")\"); } } Touch In Gadgeteer Since Gadgeteer already creates an application instance, you cannot use the above example in a Gadgeteer program. You must instead use the pre-created application instance available under Application.Current. The below example shows you how to use touch in a Gadgeteer program. Tip In the below example we still use a Bitmap object to draw to the display. Usually in Gadgeteer programs you will want to use the SimpleGraphics interface on a display module. using Microsoft.SPOT; using Microsoft.SPOT.Input; using Microsoft.SPOT.Presentation; using Microsoft.SPOT.Presentation.Media; using Microsoft.SPOT.Touch; public partial class Program { private Bitmap lcd; void ProgramStarted() { this.lcd = new Bitmap(SystemMetrics.ScreenWidth, SystemMetrics.ScreenHeight); Touch.Initialize(Application.Current); this.display.WPFWindow.TouchDown += this.MainWindow_TouchDown; this.display.WPFWindow.TouchUp += this.MainWindow_TouchUp; this.display.WPFWindow.TouchMove += this.MainWindow_TouchMove; } private void MainWindow_TouchMove(object sender, TouchEventArgs e) { Debug.Print(\"Touch move at (\" + e.Touches[0].X.ToString() + \", \" + e.Touches[0].Y.ToString() + \")\"); this.lcd.DrawEllipse(Colors.Blue, e.Touches[0].X, e.Touches[0].Y, 5, 5); this.lcd.Flush(); } private void MainWindow_TouchUp(object sender, TouchEventArgs e) { Debug.Print(\"Touch up at (\" + e.Touches[0].X.ToString() + \", \" + e.Touches[0].Y.ToString() + \")\"); } private void MainWindow_TouchDown(object sender, TouchEventArgs e) { Debug.Print(\"Touch down at (\" + e.Touches[0].X.ToString() + \", \" + e.Touches[0].Y.ToString() + \")\"); } } Calibration If your screen does not report touches close to where they actually were, your screen may need to be calibrated. NETMF provides functionality that can do this for you. It will give you a list of coordinates to touch at based on the configured screen size and then you give it the coordinates returned when you touch that spot on the display. It usually asks for five points: the four corners and the center. The below example takes care of all of this calibration for you. It requires the Microsoft.SPOT.Native, Microsoft.SPOT.Graphics, Microsoft.SPOT.TinyCore, and Microsoft.SPOT.Touch assemblies. You begin calibration by touching the screen once. After that, touch where each of the five circles is displayed in turn. After you do that, it will show you the calibration data and show a circle wherever you touch. using Microsoft.SPOT; using Microsoft.SPOT.Input; using Microsoft.SPOT.Presentation; using Microsoft.SPOT.Presentation.Media; using Microsoft.SPOT.Touch; public class Program : Application { private Bitmap lcd; private bool started; private bool finished; private int currentCalibrationPoint; private int calibrationPoints; private short[] screenX; private short[] screenY; private short[] uncalibratedX; private short[] uncalibratedY; public static void Main() { new Program().Run(); } public Program() { this.lcd = new Bitmap(SystemMetrics.ScreenWidth, SystemMetrics.ScreenHeight); Touch.Initialize(this); this.MainWindow = new Window(); this.MainWindow.TouchUp += this.OnTouchUp; this.currentCalibrationPoint = 0; this.calibrationPoints = 0; this.started = false; this.finished = false; Touch.ActiveTouchPanel.GetCalibrationPointCount(ref this.calibrationPoints); this.screenX = new short[this.calibrationPoints]; this.screenY = new short[this.calibrationPoints]; this.uncalibratedX = new short[this.calibrationPoints]; this.uncalibratedY = new short[this.calibrationPoints]; for (int i = 0, x = 0, y = 0; i < this.calibrationPoints; i++) { Touch.ActiveTouchPanel.GetCalibrationPoint(i, ref x, ref y); this.screenX[i] = (short)x; this.screenY[i] = (short)y; } Touch.ActiveTouchPanel.StartCalibration(); } private void OnTouchUp(object sender, TouchEventArgs e) { if (this.started && !this.finished) { this.uncalibratedX[this.currentCalibrationPoint] = (short)e.Touches[0].X; this.uncalibratedY[this.currentCalibrationPoint] = (short)e.Touches[0].Y; if (++this.currentCalibrationPoint == this.calibrationPoints) { Touch.ActiveTouchPanel.SetCalibration(this.calibrationPoints, this.screenX, this.screenY, this.uncalibratedX, this.uncalibratedY); this.lcd.Clear(); var str = \"Screen X: [\"; for (int i = 0; i < this.calibrationPoints; i++) str += this.screenX[i].ToString() + (i + 1 != this.calibrationPoints ? \", \" : string.Empty); str += \"]\"; this.lcd.DrawText(str, Resources.GetFont(Resources.FontResources.NinaB), Colors.White, 0, 0); str = \"Screen Y: [\"; for (int i = 0; i < this.calibrationPoints; i++) str += this.screenY[i].ToString() + (i + 1 != this.calibrationPoints ? \", \" : string.Empty); str += \"]\"; this.lcd.DrawText(str, Resources.GetFont(Resources.FontResources.NinaB), Colors.White, 0, 15); str = \"Uncalibrated X: [\"; for (int i = 0; i < this.calibrationPoints; i++) str += this.uncalibratedX[i].ToString() + (i + 1 != this.calibrationPoints ? \", \" : string.Empty); str += \"]\"; this.lcd.DrawText(str, Resources.GetFont(Resources.FontResources.NinaB), Colors.White, 0, 30); str = \"Uncalibrated Y: [\"; for (int i = 0; i < this.calibrationPoints; i++) str += this.uncalibratedY[i].ToString() + (i + 1 != this.calibrationPoints ? \", \" : string.Empty); str += \"]\"; this.lcd.DrawText(str, Resources.GetFont(Resources.FontResources.NinaB), Colors.White, 0, 45); this.lcd.Flush(); this.finished = true; } else { this.DrawPoint(this.screenX[this.currentCalibrationPoint], this.screenY[this.currentCalibrationPoint]); } } else if (!this.started) { this.started = true; this.DrawPoint(this.screenX[0], this.screenY[0]); } else if (this.finished) { this.DrawPoint(e.Touches[0].X, e.Touches[0].Y); } } private void DrawPoint(int x, int y) { this.lcd.Clear(); this.lcd.DrawEllipse(Colors.Red, x, y, 6, 6); this.lcd.Flush(); } } After you calibrate your display, you can save the values in the four short arrays in the above program along with the number of calibration points. You can then pass these values at a later point, without running calibration again, to the below function. Touch.ActiveTouchPanel.SetCalibration(calibrationPoints, screenX, screenY, uncalibratedX, uncalibratedY);"
  },
  "software/netmf/tutorials/rlp.html": {
    "href": "software/netmf/tutorials/rlp.html",
    "title": "Runtime Loadable Procedures",
    "keywords": "Runtime Loadable Procedures Introduction In .NET Micro Framework, C# is complied to an intermediate languages that is interpreted by the Common Language Runtime (CLR). The C# you write is not executed directly by processor. In a typical application, you will not see much difference in speed as many objects used in your application are implemented as native code internally and are not interpreted. When running processor intensive tasks, like cryptography algorithms or even as simple as calculating CRC, however, you will likely notice the interpreter overhead. GHI's Runtime Loadable Procedures (RLP) allow you to write and compile native code that you load onto the device and execute from the interpreted C#. Installing the compiler Since you are writing native code for an ARM device, you cannot easily use Visual Studio. Yagarto provides a helpful toolchain for compiling native code for ARM. Download and then install the following programs in order. Make sure the install paths do not have any spaces in them. Compiling will not function if they do. yagarto-bu-2.23.1_gcc-4.7.2-c-c++_nl-1.20.0_gdb-7.5.1_eabi_20121222.exe yagarto-tools-20121018-setup.exe You can verify the correct installation by running make --version and arm-none-eabi-gcc --version from a command prompt. Getting Started Download and extract the samples found here . The RLP.h file found in the Native directory is a header that defines our extensions and helpers that make it easier to write your native code. You will also see a folder for each supported platform. Within each platform, there are four files. makefile and LinkerScript.lds are basic scripts that we provide to get started with compiling your program. You will not normally need to edit them. Build.bat will actually compile your code for you and produce an elf and map file as output. NativeCode.c is an example file that shows you some basic functions. You can modify it and add your own functions. Every function you write that you want to be called from managed code must have the following signature: int YourFunc(void** args); When you invoke that function from the managed side, any arguments you pass will be found in that void** parameter. If you pass five arguments, then args will be an array of five void pointers. It is your job to then cast each of these pointers to their native equivalent. The following table shows the supported NETMF parameter types and their native equivalent: | C# Parameter | Native Parameter | | byte | unsigned char | | sbyte | char | | short | short | | ushort | unsigned short | | int | int | | uint | unsigned int | | long | long | | ulong | unsigned long | | float | float | | double | double | | bool | unsigned char | | Bitmap | unsigned short[] | Arrays of each of the above parameters (except bitmaps) are also supported. When passing a non-array parameter, it is by value. Any changes to these parameters on the native side are not seen on the managed side. Arrays, however, are passed by reference. Any change to the value of a member of an array is seen on the managed side. Make sure to not read or write past the end of the array. It is up to you to track its length, perhaps through a second parameter you pass. For example, imagine you have passed an integer, a byte array, its length, and a boolean down to the native side. You can retrieve those parameters using the following code: int YourFunc(void** args) { int arg1 = *(int*)(args[0]); //the integer unsigned char* arg2 = (unsigned char*)(args[1]); //the byte array int arg3 = *(int*)(args[2]); //the length of the byte array unsigned char arg4 = *(unsigned char*)(args[3]); //the boolean } When you pass a primitive value, you simple cast the void pointer to a pointer of the corresponding native type and dereference it. When the argument is an array, you again cast the void pointer to a pointer of the corresponding native type but you do not reference it. You can dereference that pointer as if it were an array. Again, make sure to not read beyond its length. Warning Make sure you do not store the pointer to a passed array parameter between function invocations. The array is managed by the CLR and the garbage collector may relocate it between invocations. If you want to pass data outside of the parameters to Invoke for performance reasons, you can allocate a buffer on the native side and return its address to managed code. From there, you can read and write to that buffer using Register and AddressSpace. Compiling Once you have written your code, in the folder that contains makefile, LinkerScript.lds, and NativeCode.c run the file Build.bat. You will see some compiler output and an elf and a map file will appear in the directory. Both files will be called [board name]RLP. The ELF file is the one that you will need to load into RLP from the managed code. To be able to invoke the native function from managed code, you must get the compiled ELF file into a byte array in the managed side. You can save the ELF file as a resource, to an SD card, or to the network and then read or download it. Warning If the native code you execute hangs or crashes, NETMF and the device will become unresponsive. It is recommended that you do not execute any RLP code as soon as the board boots because if it crashes you will have no way to redeploy a program requiring you to completely erase and reflash the board. Invoking Your Function The below code shows you how to load the byte array representing the ELF file into RLP and calling it natively. (It assumes you have added the ELF file as a resource to your C# project.) You pass the name of your native function into the FindFunction function and it will return an object that you can call Invoke() on and pass parameters. We will use the same four parameters as above, an integer, byte array, its length, and a boolean. This code requires the GHI.Hardware assembly. using GHI.Processor; using Microsoft.SPOT; public class Program { public static void Main() { byte[] elfBuffer = Resources.GetBytes(Resources.BinaryResources.ELFFile); //Make sure to load the ELF file you compiled into this array. var elfImage = new RuntimeLoadableProcedures.ElfImage(elfBuffer); var yourFunction = elfImage.FindFunction(\"YourFunc\"); var byteArray = new byte[] { 25, 5, 0 }; int anInteger = 5; var result = yourFunction.Invoke(anInteger, byteArray, byteArray.Length, true); Debug.Print(\"The function returned \" + result.ToString()); //Should be 5 Debug.Print(\"The third element of the byte array is \" + byteArray[2].ToString()); //Should be 30 } } Now imagine we defined the native function like this: int YourFunc(void** args) { int arg1 = *(int*)(args[0]); //the integer unsigned char* arg2 = (unsigned char*)(args[1]); //the byte array int arg3 = *(int*)(args[2]); //the length of the byte array unsigned char arg4 = *(unsigned char*)(args[3]); //the boolean if (arg4 != 0) arg2[2] = arg2[0] + arg2[1]; return arg1; } The first parameter, the integer, is returned from the function. You can access that value as the return value of the Invoke function in the managed side. The above C# example prints out that value. If the fourth parameter, the boolean, is not false (0 is false, otherwise it is true) we will add the first and second elements of the byte array and store the result in the third element. You will see the change to the array in the managed side. Events and Tasks Sometimes you might have a long running function that runs in RLP. Since RLP blocks the managed side, nothing else on the board will run for the duration of the that function call. Using RLP tasks, your native function can register a function to be called at some future point so that you can return to NETMF. As long as this callback function is short lived, the managed side will continue to execute. You can break your work up into smaller chunks that are worked on during each callback invocation. When you are done, you can trigger an event on the managed side. Make sure to re-register the callback so long as there is more work to do. The below example passes the first and only argument passed to RLP into the task and then fires that many events. It schedules itself to fire again in one second until the parameter is zero. RLP_Task task; void TaskCallback(void* arg) { unsigned int* count = (unsigned int*)arg; RLP->PostManagedEvent(*count); if (*count > 0) { *count -= 1; RLP->Task.ScheduleTimeOffset(&task, 1000000); } else { RLP->Task.Abort(&task); } } int StartTask(void** args) { RLP->Task.Initialize(&task, TaskCallback, args[0], RLP_FALSE); RLP->Task.Schedule(&task); return 1; } As before, we create and invoke the RLP function object but we also subscribe to the NativeEvent event and then print out the value received. Every time PostManagedEvent is called from the native side, this event will be fired with the data passed to it. In this example, it should be fired six times, printing out 5, 4, 3, 2, 1, and then 0. using GHI.Processor; using Microsoft.SPOT; using System.Threading; public class Program { public static void Main() { byte[] elfBuffer = Resources.GetBytes(Resources.BinaryResources.ELFFile); //Make sure to add an ELF file as a resource RuntimeLoadableProcedures.NativeEvent += RuntimeLoadableProcedures_NativeEvent; var elfImage = new RuntimeLoadableProcedures.ElfImage(elfBuffer); var startTask = elfImage.FindFunction(\"StartTask\"); startTask.Invoke(5); Thread.Sleep(-1); } private static void RuntimeLoadableProcedures_NativeEvent(object sender, RuntimeLoadableProcedures.NativeEventEventArgs e) { Debug.Print(\"We've received \" + e.Data.ToString() + \" from the native side.\"); //Should be 5 to 0 } } Bitmaps You can also pass bitmaps to RLP. You will receive an unsigned short array in the argument list. Changes made to that array will be reflected in the bitmap back in C#. As with all arrays, make sure not to save it between invocations or read beyond its end. Its length is equal to bitmap.Width x bitmap.Height. Each entry in the array represents one pixel in RGB 565 format. You can access a pixel using the following code: void SetPixel(unsigned short* bmp, int x, int y, int bitmapWidth, unsigned short color) { bmp[y * bitmapWidth + x] = color; } Multiple Files If you load more than one ELF image at a time, you must be sure that all images after the first occupy a unique location in RAM. The header and linker scripts we provide place the ELF image at a certain default location. You must change that for the second file so that you do not overwrite the first file when you load the second. When compiling, you should see a map file created as one of the outputs. This file tells you exactly how big and where each function is located. You can use it to determine where your second image must start."
  },
  "software/netmf/tutorials/register-access.html": {
    "href": "software/netmf/tutorials/register-access.html",
    "title": "Register Access",
    "keywords": "Register Access Introduction To make the processor registers directly available to developers, We added the Register class. Register PCONP = new Register(0xE01FC0C4); // Enable timer2 and timer3 PCONP.SetBits((1 << 22) | (1 << 23)); Do you understand why 1 << 22 was used? It's easy to get the first bit (0x01), second bit (0x02) and so on but what about the higher bits such as 0x00400000? Which bit is this one? Instead of complicating things, let the compiler do the work for you. Simply use 1 << 22 for the 22nd bit. Pulse Counter NETMF doesn't have a way to count pulses. What if the processor supports it? Here is an example that sets timer 3 and P0.4 on the LPC2478 processor to count pulses. While this code will compile on any platform, it will only work on LPC2478. Other processors have different registers and different features. Tip You will need the LPC2478 datasheet and manuall to fully understand the example. using System; using System.Threading; using Microsoft.SPOT; using GHI.Processor; namespace MFConsoleApplication1 { public class Program { public static void Main() { Register PCONP = new Register(0xE01FC0C4); PCONP.SetBits(1 << 22);//enable timer2 // Select IO0 on EMX CAP2.0 Register PINSEL0 = new Register(0xE002C000); PINSEL0.SetBits((3 << 8));//set bits 8 and 9 // To enable timer/counter Register T2TCR = new Register(0xE0070004); T2TCR.Value = 1; // set prescale to 0 Register T2PR = new Register(0xE007000C); T2PR.Value = 0; Register T2CTCR = new Register(0xE0070070); T2CTCR.Value = (2 << 0 | 0 << 2);//count on falling edge and use CAPn.0 // should be 0 for a counter Register T2CCR = new Register(0xE0070028); T2CCR.ClearBits(0x07); // Don't do anything on match Register T2MCR = new Register(0xE0070014); T2MCR.Value = 0; // To reset the counter T2TCR.SetBits((1 << 1)); T2TCR.ClearBits((1 << 1)); // To read Register T2TC = new Register(0xE0070008); while (true) { uint count = T2TC.Value; Debug.Print(\"Total count: \" + count); Thread.Sleep(1000); } } } }"
  },
  "software/netmf/tutorials/files.html": {
    "href": "software/netmf/tutorials/files.html",
    "title": "Files",
    "keywords": "Files The file system features in NETMF are very similar to full .NET. There are no limits on file counts or sizes other than the limits of the FAT file system itself. NETMF supports FAT16 and FAT32. With a few minor changes, NETMF file system access can be tested from within the Microsoft NETMF emulator. Changes include removing any of the GHI library dependencies. Unlike full .NET, NETMF does require mounting of media. NETMF also handles media names differently than full .NET. Media name differences are easily handled by accessing the root directory name at runtime and then using that name. Consequently, most online examples of how to use .NET to access files on PCs can be used with NETMF. In NETMF, other than differences for specific physical characteristics, usage of SD/MMC cards and USB memory devices are identical to .NET. This document splits it's examples into two sets. One for SD/MMC Card file system access and the other for USB Mass Storage. The core file operations (open, read, write, etc.) are identical between the two. Warning The file system does a lot of data buffering internally to speed up file access time and to increase the life of flash media. When you write data to a file, it is often saved somewhere in internal buffers rather than being written immediately to the media. To make sure the data is stored on the media, you need to flush the data. Flushing (or closing) a file is the only way to guarantee that the data you are trying to write is on the actual media. In addition to the file data there is other information, such as directory information, that may not be written to the media when the file is flushed. For example, if you delete a file and remove the card from the system, the file is probably not actually erased because the directory structure was not flushed. Under current versions of .NET Micro Framework, there can be a variable time delay before the buffers are actually written to the media when using the FileStream's Flush method. This delay can reportedly be as long as a minute (see: https://netmf.codeplex.com/workitem/2149 ). To guarantee that the file buffers and the meta-data are written to the media you need to flush the volume: VolumeInfo.GetVolumes()[0].FlushAll() -or- Microsoft.SPOT.IO.VolumeInfo(\"\\SD\").FlushAll() . Ideally, you would unmount the media before it is removed from the system. This may not be always possible -- FlushAll will guarantee your data is saved Tip The SD/MMC Card examples shown below require the GHI.Hardware, Microsoft.SPOT.IO, and System.IO assemblies. Some Microsoft documentation class descriptions, such as for Directory, place the library code in the mscorlib assembly; however, it is found in the System.IO assembly. SD Card: Show Files in Root Directory This example assumes the card is already inserted; it lists all files available in the root directory. Note Some SD card sockets/interfaces have an internal switch that closes when a card is inserted or ejected. Utilizing the switch is shown in the \" SD Card: Media Detection \" example further down on this page. using System.IO; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; using Microsoft.SPOT.IO; using GHI.IO; using GHI.IO.Storage; class Program { public static void Main() { // ... // assume SD card is inserted // Create a new storage device // NETMF only allows one SD card // to be supported at a time. SDCard sd_card = new SDCard(); // this is a non-blocking call // it fires the RemovableMedia.Insert event after // the mount is finished. sd_card.Mount(); // for some cases, a simple sleep might suffice // This example just waits on the event before proceeding // (After first time firing of the event, you may want // to disable the handler or re-assign it bool fs_ready = false; RemovableMedia.Insert += (a, b) => { fs_ready = true; }; while (! fs_ready) { System.Threading.Thread.Sleep(50); } // Assume one storage device is available, access it through // NETMF and display the available files and folders: Debug.Print(\"Getting files and folders:\"); if (VolumeInfo.GetVolumes()[0].IsFormatted) { string rootDirectory = VolumeInfo.GetVolumes()[0].RootDirectory; string[] files = Directory.GetFiles(rootDirectory); string[] folders = Directory.GetDirectories(rootDirectory); Debug.Print(\"Files available on \" + rootDirectory + \":\"); for (int i = 0; i < files.Length; i++) Debug.Print(files[i]); Debug.Print(\"Folders available on \" + rootDirectory + \":\"); for (int i = 0; i < folders.Length; i++) Debug.Print(folders[i]); } else { Debug.Print(\"Storage is not formatted. \" + \"Format on PC with FAT32/FAT16 first!\"); } // Unmount when done sd_card.Unmount(); } } SD Card: Writing Files There is more than one way to open files. I will only cover FileStream objects. This example will open a file and write a string to it. Since FileStream will only take byte arrays, we need to convert our string to a byte array. using System.Threading; using System.Text; using Microsoft.SPOT; using System.IO; using Microsoft.SPOT.IO; using GHI.IO.Storage; public class Program { static void Main() { // if necessary, check that SD is present here... SDCard sd_card = new SDCard(); sd_card.Mount(); bool fs_ready = false; RemovableMedia.Insert += (a, b) => { fs_ready = true; }; while (! fs_ready ) { System.Threading.Thread.Sleep(1); } // Assume only one storage device is available // and that the media is formatted string rootDirectory = VolumeInfo.GetVolumes()[0].RootDirectory; FileStream FileHandle = new FileStream(rootDirectory + @\"\\hello.txt\", FileMode.Create); byte[] data = Encoding.UTF8.GetBytes(\"This string will go in the file!\"); FileHandle.Write(data, 0, data.Length); FileHandle.Close(); sd_card.Unmount(); } } SD Card: Reading a File Take the SD Card used in the last example, put it in a PC and you will see the file. For this example, we use the same SD Card written to by the last example. The file is opened and read to verify its contents. using System.Threading; using System.Text; using Microsoft.SPOT; using System.IO; using Microsoft.SPOT.IO; using GHI.IO.Storage; public class Program { static void Main() { // ... If desired, check if SD is inserted // SD Card is inserted // Create a new storage device SDCard sd_card = new SDCard(); // Mount the file system sd_card.Mount(); bool fs_ready = false; RemovableMedia.Insert += (a, b) => { fs_ready = true; }; while (!fs_ready) { System.Threading.Thread.Sleep(1); } // Assume one storage device is available, // access it through NETMF string rootDirectory = VolumeInfo.GetVolumes()[0].RootDirectory; FileStream FileHandle = new FileStream(rootDirectory + @\"\\hello.txt\", FileMode.Open, FileAccess.Read); byte[] data = new byte[100]; int read_count = FileHandle.Read(data, 0, data.Length); FileHandle.Close(); Debug.Print(\"The size of data read is: \" + read_count.ToString()); Debug.Print(\"Data from file:\"); Debug.Print(new string(Encoding.UTF8.GetChars(data), 0, read_count)); sd_card.Unmount(); } } SD Card: Media Detection The previous examples assumed that the card was already inserted and mostly ignored whether that media was formatted (contained a file system). The following example shows an application without such assumptions; additionally, it demonstrates the Format method. Together, InsertEventHandler , EjectEventHandler , and IsSDCardPresent are used to respond to physical card activities, which in turn are used to control mounting ( Mount , Unmount ) of the card. Once the card is mounted, the file-system can be used. using System; using System.IO; using System.Threading; using Microsoft.SPOT; using Microsoft.SPOT.IO; using GHI.IO.Storage; public class Program { // evt is used to avoid the possibility that accesses to the // mounted file system do not occur until mount() // is fully done. private static AutoResetEvent evt = new AutoResetEvent(false); //Make sure to set the pin to your sd card detect pin. private static InputPort sdCardDetect = new InputPort(Cpu.Pin.GPIO_NONE, false, Port.ResistorMode.Disabled); public static void Main() { RemovableMedia.Insert += new InsertEventHandler(RemovableMedia_Insert); RemovableMedia.Eject += new EjectEventHandler(RemovableMedia_Eject); // Start auto mounting thread new Thread(SDMountThread).Start(); evt.WaitOne(); // yield here until mounting and initializing is finished // Your program goes here // ... } // This event is fired by unmount; not neccesarily by physical ejection of media static void RemovableMedia_Eject(object sender, MediaEventArgs e) { Debug.Print(\"SD card unmounted, eject event fired\"); // as desired signal other thread(s) in application // that unmount occurred } static void RemovableMedia_Insert(object sender, MediaEventArgs e) { Debug.Print(\"Insert event fired; SD card mount is finished.\"); // insert code here for anything the program wants to do immediately // after mounting occurs... if (e.Volume.IsFormatted) { Debug.Print(\"Available folders:\"); string[] strs = Directory.GetDirectories(e.Volume.RootDirectory); for (int i = 0; i < strs.Length; i++) Debug.Print(strs[i]); Debug.Print(\"Available files:\"); strs = Directory.GetFiles(e.Volume.RootDirectory); for (int i = 0; i < strs.Length; i++) Debug.Print(strs[i]); } else { Debug.Print(\"SD card is not formatted. Formatting...\"); // VolumeInfo is the class that contains volume information for a specific // media. // .GetVolumes()[0] aquires the first volume on the device. Change the // index for different volumes. // .Format(\"FAT\", 0); Selects the \"FAT\" file system as the format type. VolumeInfo.GetVolumes()[0].Format(\"FAT\", 0); } evt.Set(); // proceed with other processing } public static void SDMountThread() { SDCard SD = null; const int POLL_TIME = 500; // check every 500 millisecond bool sdExists; while (true) { try { // If SD card was removed while mounting, it may throw exceptions. sdExists = sdCardDetect.Read(); // make sure it is fully inserted and stable if (sdExists) { Thread.Sleep(50); sdExists = sdCardDetect.Read(); } if (sdExists && SD == null) { SD = new SDCard(); SD.Mount(); } else if (!sdExists && SD != null) { SD.Unmount(); SD.Dispose(); SD = null; } } catch { if (SD != null) { SD.Dispose(); SD = null; } } Thread.Sleep(POLL_TIME); } } } USB Mass Storage Devices USB mass storage devices, such as memory sticks and card readers are supported by GHI's NETMF devices. If you compare the following example with those above for SD Cards, you will see how easy it is to program for one, the other, or both with virtually identical code. using System; using System.Threading; using System.IO; using Microsoft.SPOT; using System.Text; using Microsoft.SPOT.IO; using GHI.Usb; using GHI.Usb.Host; using GHI.IO.Storage; public class Program { // evt is used to avoid the possibility that accesses to the // mounted file system do not occur until mount() // is fully done. private static AutoResetEvent evt = new AutoResetEvent(false); private static MassStorage usb_storage; private static string rootDirectory; public static void Main() { RemovableMedia.Insert += new InsertEventHandler(RemovableMedia_Insert); RemovableMedia.Eject += new EjectEventHandler(RemovableMedia_Eject); // Unlike SD Card detection, the USB Host Controller sends an // event when a Mass Storage device is plugged-in. Controller.MassStorageConnected += (sender, massStorage) => { usb_storage = massStorage; usb_storage.Mount(); // fires the insert event when finished }; Controller.Start(); evt.WaitOne(); // yield here until mounting and initializing is finished byte[] data; // write using (var FileHandle = new FileStream(rootDirectory + @\"\\hello.txt\", FileMode.Create)) { data = Encoding.UTF8.GetBytes(\"This string will go in the file!\"); FileHandle.Write(data, 0, data.Length); } // read int read_count; using (var FileHandle = new FileStream(rootDirectory + @\"\\hello.txt\", FileMode.Open, FileAccess.Read)) { data = new byte[100]; read_count = FileHandle.Read(data, 0, data.Length); } Debug.Print(\"The size of data we read is: \" + read_count.ToString()); Debug.Print(\"Data from file:\"); Debug.Print(new string(Encoding.UTF8.GetChars(data), 0, read_count)); usb_storage.Unmount(); } // This event is fired by unmount static void RemovableMedia_Eject(object sender, MediaEventArgs e) { Debug.Print(\"USB unmounted, eject event fired\"); } static void RemovableMedia_Insert(object sender, MediaEventArgs e) { Debug.Print(\"Insert event fired; USB Storage mount is finished.\"); if (e.Volume.IsFormatted) { rootDirectory = e.Volume.RootDirectory; Debug.Print(\"Available folders:\"); string[] strs = Directory.GetDirectories(e.Volume.RootDirectory); for (int i = 0; i < strs.Length; i++) Debug.Print(strs[i]); Debug.Print(\"Available files:\"); strs = Directory.GetFiles(e.Volume.RootDirectory); for (int i = 0; i < strs.Length; i++) Debug.Print(strs[i]); } else { Debug.Print(\"Media is not formatted. Formatting...\"); e.Volume.Format(\"FAT\", 0); rootDirectory = e.Volume.RootDirectory; } evt.Set(); // proceed with other processing } } Warning Media formatted as FAT12 will not work. This shouldn't be an issue since FAT12 is no longer in use."
  },
  "software/netmf/tutorials/digital-outputs.html": {
    "href": "software/netmf/tutorials/digital-outputs.html",
    "title": "Digital Outputs",
    "keywords": "Digital Outputs A digital output pin can be set to either high or low. There are different ways of describing these two states. High can also be called \"true\" or \"one;\" low can be called \"false\" or \"zero\". If the processor is powered off of 3.3 V, then the state high means that there is 3.3 V on the output pin. It is not going to be exactly 3.3 V but very close. When the pin is set to low then it is voltage is very close to zero volts. Warning Never connect two output pins together. If they are connected and one is high and the other is low, the entire processor can be damaged. The digital pins on micro-controllers are very weak. They can not be used to drive devices that require a lot of power. Tip All the examples shown below require the Microsoft.SPOT.Hardware assembly. Consult the device schematics or manual for specific pin numbers. Light Up an LED This example turns a LED on. The initial state of the pin (true or false) must be specified when creating the OutputPort. This example makes the pin true which will cause the LED to be on by default. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { OutputPort LED; LED = new OutputPort(Cpu.Pin.GPIO_Pin1, true); Thread.Sleep(Timeout.Infinite); } } Blink an LED To blink an LED, the pin is toggled between high and low. Due to the high speed of the microcontroller (it can flash the LED millions of times per second) a delay needs to be added between ON and OFF to see the blinking. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { OutputPort LED; LED = new OutputPort(Cpu.Pin.GPIO_Pin1, true); while (true) { LED.Write(!LED.Read()); Thread.Sleep(200); } } }"
  },
  "hardware/scm/usbizi.html": {
    "href": "hardware/scm/usbizi.html",
    "title": "USBizi",
    "keywords": "USBizi USBizi was the first single chip .NET Micro Framework (NETMF) on the market. It was available in 100pin and 144pin LQFP packages. We are no longer selling this chipset but we are making all bootloader binaries available for free, including for commercial use. To use with NETMF, follow these setup instructions . Requires the NETMF 4.1 SDK. Resources User Manual USBizi DevSys The original development board for USBizi. Schematic"
  },
  "hardware/scm/intro.html": {
    "href": "hardware/scm/intro.html",
    "title": "Surface Mount Compute Modules",
    "keywords": "Surface Mount Compute Modules SCMs are surface mount embedded controllers that are well suited to harsh or high vibration environments. A variety of tools and software options are available. Check the individual product documentation for details. G30 Learn more... G80 Learn more... G120 / G120E Learn more... G400S Learn more... TinyCLR lets you program our devices (and others) in C# or Visual Basic using Microsoft's Visual Studio -- and it's all free! Learn more... . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/scm/embedded-master.html": {
    "href": "hardware/scm/embedded-master.html",
    "title": "Embedded Master",
    "keywords": "Embedded Master Embedded Master is a NETMF (.NET Micro Framework) System on Module. To use with NETMF, follow these setup instructions . Requires the NETMF 4.1 SDK. Resources User Manual"
  },
  "hardware/loaders/stm32-bootloader.html": {
    "href": "hardware/loaders/stm32-bootloader.html",
    "title": "The STM32 Bootloader",
    "keywords": "The STM32 Bootloader The STM32 Bootloader lives on all STM32 chips. The bootloader is used to load files (bootloaders and/or firmware) onto the chip. These instructions apply to all STM32 chips with built in USB and DFU features. Loading the GHI Bootloader v2 The bootloader often comes pre-installed on our devices. It only needs to be installed once. It does not need to be reinstalled unless it becomes erased or corrupted. Download and save the latest bootloader file . Download and install the DfuSe USB device firmware upgrade software from STMicroelectronics. Run the DfuSeDemo program installed in the previous step. It should appear in the programs menu under STMicroelectronics . Put your board in DFU (Device Firmware Upgrade) mode. Instructions for putting your device in DFU mode are found on the documents page for the board you are using. STM Device in DFU Mode should now appear under Available DFU Devices at the upper left of the DfuSe Demo program screen. Near the bottom of the DfuSe Demo program window click on the Choose... button. Find the bootloader file you saved in step 1 (...Bootloader v2.x.x.dfu), click on it and click on the Open button. Now click on the Upgrade button . Make sure you are using the \"Upgrade\" and not the \"Upload\" button. If a dialog box appears with Your device was plugged in DFU mode... click the Yes button. You should see a message at the bottom of the DfuSe Demo window saying the upgrade was successful. Now reset the your device or click on the Leave DFU mode button. Congratulations! You have successfully installed the GHI STM32 bootloader! Creating a DFU file Creating DFU files are not necessary for most users. This is only provided as a reference for advanced used. You can create DFU files from .hex or .bin files using the DFU file manager software which is part of the DfuSe USB device firmware upgrade software download from step 2 of the above instructions. The instructions are slightly different depending on whether you are starting with a .hex or .bin file. From .hex files Find and open the \"Dfu file manager\" program. It should appear in the programs menu under STMicroelectronics . Select I want to generate a DFU file . Click on the S19 or Hex... button to select the .hex file. Click Generate... You now have a DFU file! From .bin files Find and open the \"Dfu file manager\" program. It should appear in the programs menu under STMicroelectronics . Select I want to generate a DFU file . Click on Multi BIN... button to select the .bin file. Change the address to 08000000 Click on the Add to list >> button then click the OK button. Click Generate... You now have a DFU file!"
  },
  "software/tinyclr/tutorials/filesystem.html": {
    "href": "software/tinyclr/tutorials/filesystem.html",
    "title": "File System",
    "keywords": "File System The file system library can be used to read and write files. FAT16 and FAT32 are supported. USB Mass Storage This allows file access on USB devices with MSC class, such as USB memory sticks. The support for USB drives is still not publicly available. SD Card The below example requires the GHIElectronics.TinyCLR.IO and GHIElectronics.TinyCLR.Storage libraries and a device with an SD card. using GHIElectronics.TinyCLR.Devices.Storage; using GHIElectronics.TinyCLR.IO; using System; using System.IO; using System.Text; namespace Filesystem { public class Program { private static void Main() { var sd = StorageController.FromName(@\"GHIElectronics.TinyCLR.NativeApis.STM32F4.SdCardStorageController\\0\"); var drive = FileSystem.Mount(sd.Hdc); var file = new FileStream($@\"{drive.Name}Test.txt\", FileMode.OpenOrCreate); var bytes = Encoding.UTF8.GetBytes(DateTime.UtcNow.ToString() + Environment.NewLine); file.Write(bytes, 0, bytes.Length); file.Flush(); FileSystem.Flush(sd.Hdc); } } } Low-level Access You can access the raw underlying data of the storage provider using the Provider property of the controller. Be careful when using this interface, however, as it bypasses any file system present and writes directly to the device. This is useful for implementing your own or otherwise unsupported file systems. var controller = StorageController.FromName(@\"GHIElectronics.TinyCLR.NativeApis.STM32F4.SdCardStorageController\\0\"); controller.Provider.Read(address, buffer, 0, buffer.Length, -1);"
  },
  "software/tinyclr/tutorials/dac.html": {
    "href": "software/tinyclr/tutorials/dac.html",
    "title": "DAC",
    "keywords": "DAC A Digital to Analog Converter (DAC) will convert a digital input (number) to an analog output (voltage). The voltage of a DAC usually swings from very close to zero volts up to nearly the voltage of the microcontroller (usually 3.3 volts). This output voltage is only a weak signal and is not meant to drive a load. An op-amp or similar circuit can be added to drive a load, such as a speaker. The analog out on a microcontroller has a given resolution which in large part determines its precision or accuracy. Check the device documentation for details. For example, an 8-bit DAC has 256 possible output voltage levels and a resolution of 3.3V/256 or 0.013 volts. This example will generate a triangular waveform on the G120. using System.Threading; using GHIElectronics.TinyCLR.Devices.Dac; using GHIElectronics.TinyCLR.Pins; class Program { private static void Main() { var dac = DacController.GetDefault(); var analog = dac.OpenChannel(G120.DacChannel.P0_26); double d = 0.5; double dd = 0.01; while (true) { analog.WriteValue(d); d += dd; if (d <= 0 || d >= 1) dd *= -1; //Invert Thread.Sleep(10); } } } Tip Do not use analog outputs to control the power of an LED or a motor. Use PWM for that."
  },
  "software/tinyclr/tinyclr-config.html": {
    "href": "software/tinyclr/tinyclr-config.html",
    "title": "TinyCLR Config",
    "keywords": "TinyCLR Config TinyCLR Config is a stand-alone tool to help manage TinyCLR OS devices. The tool is cloud-connected. It automatically finds and downloads newer firmware versions from a list of provided sources. These sources can be on the Internet or local on your computer if you don't have (or don't want) Internet access. The firmware update functionality only works for devices that have GHI Bootloader v2 . You can download TinyCLR Config from the TinyCLR Config section of the Downloads page. Using TinyCLR Config After installing TinyCLR Config, the program will be found in the GHI Electronics folder of the Start Menu. Upon starting the program, you will notice two tabs near the top of the window named Debug and Loader . The Debug mode of the program is used to communicate through the device's USB debug port. TinyCLR firmware must be installed on the device to communicate through the debug interface. The debug mode of TinyCLR Config can be used to update firmware, manipulate your application, save and load binary images of your application, and enter bootloader mode. The Loader mode of the program is used to communicate with devices that are in bootloader mode. You do not need firmware installed to communicate, but GHI Bootloader v2 must be installed. The loader mode allows you to load or update the firmware, erase the device, and run your application. Using Debug Mode Start TinyCLR Config and plug your device into your computer's USB port. Select your device as show below. We are using the FEZ for this example. Note You must have GHI Bootloader v2 and TinyCLR firmware installed on your device to communicate using the Debug mode of TinyCLR Config. . Hit the Connect button. The device, name, manufacturer and firmware versions should be displayed. If you have an application on your device, any debug output will be shown in the Debug text box. The assemblies listed in the text box at the bottom of the window should match the libraries (NuGet packages) that were loaded as part of your application. Debug Mode Command Buttons Update Firmware Updates device firmware to the latest version found from whatever sources have been specified (a default source points to the official GHI Electronics downloads). See firmware sources below for more information. Ping Used to ping the device to verify the connection. Reboot Reboots the device. Will restart any loaded application. Enter Loader Used to enter bootloader mode. While in bootloader mode you can select the Loader tab to communicate with the device in bootloader mode. Pause App Pauses the application program. Can be used to stop debug output to give you time to read previous debug messages. Resume App Resumes a paused application. Erase App Used to erase an application program from a device. Does not erase the firmware or bootloader. Save App Used to save a binary image of the device application program as a .tca file. Does not save the TinyCLR firmware or the bootloader. Load App Used to load a previously saved binary image of an application (.tca file) onto your device. Keep in mind that you need to make sure that the device is the same model and is running the same firmware when you load the application that it was when the application was saved. Using Loader Mode Plug the device into your computer's USB port and start TinyCLR Config. To use Loader mode, the device must first be placed into bootloader mode. Devices without firmware installed should boot into loader mode by default. You can also use the Enter Loader button in the Debug section of TinyCLR Config to put your device in loader mode. You may also assert one of the boot pins to force the device to stay in loader mode on power up -- see your device specifications for details. Note You must have GHI Bootloader v2 installed on your device to communicate using the Loader mode of TinyCLR Config. Click on the Loader tab of TinyCLR Config. Next to Port: , use the drop down text box to select the com port of your device. You may have to click the Refresh button if the connection to your device is not shown. When a connection is established, you should see the name and bootloader version of your device. Loader Mode Command Buttons Update to Latest Updates the device firmware to the latest version found using the same rules as the firmware update section of the Debug tab. It will always erase and reload the latest found firmware, regardless of version. Manual Update Allows you to update from a locally stored firmware file. Erase Erases the application program and firmware from the device. Does not erase the bootloader. Run Takes the device out of bootloader mode and starts the firmware on the device. Firmware Sources When TinyCLR Config starts up, it looks for a file called FirmwareSources.txt in the same directory as the TinyCLR Config executable itself. If the file isn't present, it's created automatically with one entry pointing to the official GHI firmware store. The file is a comma-separated list of sources, one per line. The first value is an integer priority with lower numbers being searched first. Each source is tried until a newer version than the currently flashed version is found. The next value is either Local or Network which determines where the next value points to: the local disk or the network. The last value is a URI that points to an xml file that defines the list of available firmwares. The firmware xml list is made up of a list of devices. Each device has a name attribute and firmware list child. Within the firmware list is a list of each available firmware. Each firmware must have an MD5 hash that matches the file pointed to, a version of the form major.minor.patch , a release date, and a uri that points to the location of the firmware (the location type must match the location type of the firmware list itself, i.e. local vs network). See the official hosted FirmwareList.xml file for a complete example. Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/gadgeteer/intro.html": {
    "href": "hardware/gadgeteer/intro.html",
    "title": ".NET Gadgeteer Intro",
    "keywords": ".NET Gadgeteer Intro .NET Gadgeteer is a discontinued technology that was initiated by Microsoft Research and taken to production by GHI Electronics in the year 2011. .NET Gadgeteer had a great few year run, where it was loved for its plug-and-play mainboard and modules. Tip We will refer to .NET Gadgeteer as Gadgeteer throughout the rest of the documentation. The core of .NET Gadgeteer is .NET Micro Framework (NETMF). Like Gadgeteer, NETMF is no longer evolved by Microsoft and left for the community. Learn more about NETMF Sadly, and after 5 years of building modules and mainboards, GHI Electronics had to announce the EOL for Gadgeteer; however, most of the Gadgeteer hardware can still be used with TinyCLR OS . External resources: Microsoft's .NET Gadgeteer website (down) http://www.gadgeteer.com/ Microsoft's NETMF website (outdated) http://www.netmf.com/ Most of the Gadgeteer ecosystem is open-source: Microsoft's .NET Gadgeteer Core GHI Electronics' Software sources and Hardware design files Socket Map The magic of Gadgeteer is in its socket map Socket Pin1 Pin2 Pin3 Pin4 Pin5 Pin6 Pin7 Pin8 Pin9 Pin10 A +3.3V +5V AIN (G!) AIN (G) AIN GPIO [UN] [UN] [UN] GND B +3.3V +5V LCD B0 LCD B1 LCD B2 LCD B3 LCD B4 LCD ENABLE LCD CLK GND C +3.3V +5V GPIO! CAN TD (G) CAN RD (G) GPIO [UN] [UN] [UN] GND D +3.3V +5V GPIO! D- D+ GPIO GPIO [UN] [UN] GND E +3.3V +5V [UN] LED1 (OPT) LED2 (OPT) TX D- TX D+ RX D- RX D+ GND F +3.3V +5V GPIO! DAT0 DAT1 CMD DAT2 DAT3 CLK GND G +3.3V +5V LCD G0 LCD G1 LCD G2 LCD G3 LCD G4 LCD G5 LCD BACKLIGHT GND H +3.3V +5V GPIO! D- D+ [UN] [UN] [UN] [UN] GND I +3.3V +5V GPIO! [UN] [UN] GPIO [UN] SDA SCL GND K +3.3V +5V GPIO! TX (G) RX (G) RTS CTS [UN] [UN] GND O +3.3V +5V GPIO! GPIO AOUT [UN] [UN] [UN] [UN] GND P +3.3V +5V GPIO! [UN] [UN] GPIO PWM (G) PWM (G) PWM GND R +3.3V +5V LCD R0 LCD R1 LCD R2 LCD R3 LCD R4 LCD VSYNC LCD HSYNC GND S +3.3V +5V GPIO! GPIO GPIO CS MOSI MISO SCK GND T +3.3V +5V [UN] YU XL YD XR [UN] [UN] GND U +3.3V +5V GPIO! TX (G) RX (G) GPIO [UN] [UN] [UN] GND X +3.3V +5V GPIO! GPIO GPIO [UN] [UN] [UN] [UN] GND Y +3.3V +5V GPIO! GPIO GPIO GPIO GPIO GPIO GPIO GND Z +3.3V +5V [MS] [MS] [MS] [MS] [MS] [MS] [MS] GND * +3.3V +5V GPIO! GPIO GPIO [MS] [MS] [MS] [MS] GND Symbol Description AIN Analog input pin. GPIO A general-purpose digital input/output pin, operating at 3.3 volts. (G) In addition to another functionality, a pin that is also usable as a GPIO. [UN] Modules must not connect to this pin if using this socket type. Mainboards can support multiple socket types on one socket, as long as individual pin functionalities overlap in a compatible manner, so that a pin from one socket type can overlap with a [UN] pin of another. ! Interrupt-capable and software pull-up capable GPIO (the pull-up is switchable and in the range of 10,000 to 100,000 ohms). +3.3V Connection to the +3.3 V power net. +5V Connection to the +5 V power net. GND Connection the power ground net. Using .NET Gadgeteer To use .NET Gadgeteer's legacy software, install: Visual Studio 20013 (community edition is also supported) Unzip and install netmfvs2013.vsix and MicroFramewrokSDK.msi from here Microsoft's Gadgeteer Core GHI Electronics' NETMF SDK . The latest is recommended. The Gadgeteer for Beginners guide is a good starting point. Tip You can only use Visual Studio 2013, not a newer edition, unless you are using your Gadgeteer hardware with TinyCLR OS . With TinyCLR OS Most of the .NET Gadgeteer devices are still usable today, and with the latest technologies, thanks to efforts by GHI Electronics and the community. It all started in this video! This means you can still use all your beloved .NET Gadgeteer gear with TinyCLR OS . The first step needed to use TinyCLR OS is to load the GHI Bootloader v2 onto your mainboard, then use that to load the TinyCLR OS firmware. Each mainboard product page includes the needed instructions. Once those are loaded, you can start blinking the debug LED, detailed in the next section. Blinking the LED Tip If you have never used TinyCLR OS before, start here This example will blink the debug LED. You only need to add a power module to your mainboard. using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var led = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.DebugLed); led.SetDriveMode(GpioPinDriveMode.Output); while(true) { led.Write(GpioPinValue.High); Thread.Sleep(200); led.Write(GpioPinValue.Low); Thread.Sleep(200); } } } Tip The complete pin mapping is made available through GHIElectronics.TinyCLR.Pins . You should not need to use any schematics. Replace FEZSpider with your mainboard's name. Adding Gadgeteer Modules You are now ready to start adding modules ."
  },
  "hardware/gadgeteer/fez-spider.html": {
    "href": "hardware/gadgeteer/fez-spider.html",
    "title": "FEZ Spider",
    "keywords": "FEZ Spider FEZ Spider is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Spider is the EMX System on Module (SoM). To use with NETMF/Gadgeteer, follow these setup instructions . Resources Schematic"
  },
  "hardware/gadgeteer/fez-cobra-ii.html": {
    "href": "hardware/gadgeteer/fez-cobra-ii.html",
    "title": "FEZ Cobra II Eco and Wi-Fi",
    "keywords": "FEZ Cobra II Eco and Wi-Fi FEZ Cobra II is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Cobra II is the G120 System on Module (SoM). Follow the instructions on the G120 page to learn how to use FEZ Cobra with NETMF and TinyCLR OS. Resources Eco and WiFi Schematic Net Schematic Cobra II Extender schematic Tip To activate bootloader v2, press and hold the LDR0 button while resetting the board."
  },
  "hardware/filesystem/intro.html": {
    "href": "hardware/filesystem/intro.html",
    "title": "File System",
    "keywords": "File System This page has the technical details and manuals for the File System products. The main website's File System page has more info as well. F40 (ALFAT) Chipset F40, originally called ALFAT, is the flagship file system chipset. Part Number ALF2X-SC-512 Datasheet User Manual Firmware v1.0.8 Firmware v2.0.0 ALFAT OEM Board F40 chipset with SD and dual-USB connectors. The PHY needed for USB 2.0 480 MHz speeds is available on one of the USB ports. Part Number ALFAT-OM-337 ALFAT-OEM Schematic ALFAT SD F40 chipset with SD connector. Part Number ALFAT-SD-338 ALFAT-SD Schematic ALFAT USB F40 chipset with USB connector. Part Number ALFAT-USB-428 ALFAT-USB Schematic ALFAT SDR This board wires the F40 in SD-reader mode. Part Number AFSDR-FS-523 ALFAT-SDR Schematic ALFAT Evaluation Kit This kit offers everything needed to evaluate F40 (ALFAT) and the different ALFAT OEM boards. The kit includes: ALFAT OEM board ALFAT SDR board ALFAT EVAL carrier board Storage devices and USB cable Part Number AFEVL-FS-524 ALFAT Eval Kit Schematic F20 Chipset This low-cost chipset is compatible with F40 but with a limited feature set. Part Number F20SC-SC-558 Datasheet User Manual Firmware v1.0.3 F20 uSD Board This boards combines F20 with a micro SD card connector on a very tiny circuit. Part Number F20FS-546 F20-uSD Schematic Legacy Products uALFAT Chipset This is a legacy product, replaced by F40. User Manual Firmware v3.13 USBwiz Chipset This is a legacy product, replaced by F40. User Manual Firmware v2.29 Legal License This product and its firmware and libraries are licensed royalty-free for commercial and noncommercial use. None of the provided documentation/schematics/libraries/sources are to be used in any manner outside for the benefit of implementing and using this product into your design. Disclaimer IN NO EVENT SHALL GHI ELECTRONICS, LLC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS PRODUCT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. GHI ELECTRONICS, LLC LINE OF PRODUCTS ARE NOT DESIGNED FOR LIFE SUPPORT APPLICATIONS. SPECIFICATIONS, PRICE AND AVAILABILITY ARE SUBJECT TO CHANGE WITHOUT ANY NOTICE. Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/duino/fez-panda-iii.html": {
    "href": "hardware/duino/fez-panda-iii.html",
    "title": "FEZ Panda III",
    "keywords": "FEZ Panda III An Arduino-pinout compatible single board computer. Resources Schematic Software For information on programming the FEZ Panda II, please go to the G80 page."
  },
  "hardware/duino/fez-lemur.html": {
    "href": "hardware/duino/fez-lemur.html",
    "title": "FEZ Lemur",
    "keywords": "FEZ Lemur A Arduino-pinout compatible single board computer. Resources Schematic Software For information on programming the FEZ Lemur, please go to the G30 page."
  },
  "hardware/breakout/g80-th.html": {
    "href": "hardware/breakout/g80-th.html",
    "title": "G80 TH Module",
    "keywords": "G80 TH Module A through-hole version of the G80. Resources Schematics Software For information on programming the G80 TH Module, please go to the G80 page."
  },
  "hardware/breakout/g120-th.html": {
    "href": "hardware/breakout/g120-th.html",
    "title": "G120 TH Module",
    "keywords": "G120 TH Module A through-hole version of the G120. Resources Schematic Software For information on programming the G120 TH Module, please go to the G120 page."
  },
  "hardware/automotive.html": {
    "href": "hardware/automotive.html",
    "title": "CANxtra",
    "keywords": "CANxtra CANxtra is a hand-held programmable OBD-II tool that includes CAN, LIN and other vehicle buses. Resources below are provided for reference only. Please contact us for all of your custom automotive needs. Resources Brochure Schematic"
  },
  "software/netmf/tutorials/firmware-update.html": {
    "href": "software/netmf/tutorials/firmware-update.html",
    "title": "Firmware Update",
    "keywords": "Firmware Update Note If you need to update the loader, it should always be done before updating the firmware. See your device's developers' guide or manual for more detail on updating the loader. Connect your device to your PC. Launch FEZ Config and click on Check device for update button. This will show the version numbers on the PC and what is loaded on the device. Note Fez Config is installed when you install the NETMF SDK . To proceed with updating TinyCLR, click on the Firmware Updater button on the left and follow the instructions. After FEZ Config selects the firmware and the default configuration files, click Next . Click OK to proceed when the dialog appears asking if you are having issues. As the update occurs, the steps and progress are shown. When it is finished, the module is ready to be flashed with NETMF applications."
  },
  "software/netmf/getting-started.html": {
    "href": "software/netmf/getting-started.html",
    "title": ".NET Micro Framework Getting Started",
    "keywords": ".NET Micro Framework Getting Started Installation Steps Install Visual Studio Community Edition Download and install Microsoft's Visual Studio 2013 Community Edition . Install Microsoft .NET Micro Framework Uninstall any currently installed NETMF SDKs. Download Microsoft .NET Micro Framework 4.3 (QFE2) and unzip the file. Open the file's folder and install MicroFrameworkSDK.MSI and netmfvs2013.vsix . Install Microsoft .NET Gadgeteer Core (for Gadgeteer users only) Download and install Microsoft .NET Gadgeteer Core . For more information on the future of Gadgeteer, please see this news post . Install GHI Electronic's NETMF SDK Download and install GHI Electronics NETMF SDK 2016 R1 from our NETMF Downloads page. When installing newer GHI NETMF SDKs, click the Advanced button on the opening dialog box and uncheck the boxes to install the FEZ CERB Family and G400/FEZ Hydra loader updaters (the first two options). If needed, these loaders can be installed separately as highlighted in the individual product pages. Older GHI NETMF SDKs are also available on the NETMF Downloads page. For the latest 2016 R1 SDK, we've also made a zip archive of the sub-installers available so that you can install just the pieces you need in a quicker fashion. Get Started with .NET Micro Framework for Beginners To help you get started we have a free e-book in .pdf format: .NET Micro Framework for Beginners The Emulator The NETMF SDK includes an emulator for running NETMF applications on the PC. For the first part of this project, the emulator will be used to run a very simple application; afterwards the same program is run on NETMF hardware. Create a New Project Open Visual Studio, select File > New Project . There should be a Micro Framework option in the left menu. Click on it and then select Console Application in the center panel. Note The pictures used in this tutorial may vary slightly with different versions of the development platform. Click the OK button to create a new project. The project has only one C# file, called Program.cs . C# source files are listed in the Solution Explorer window. If the Solution Explorer is not open, use the View > Solution Explorer menu to open it. Double click on Program.cs to open the file in the editor. using System; using Microsoft.SPOT; namespace MFConsoleApplication1 { public class Program { public static void Main() { Debug.Print( Resources.GetString(Resources.StringResources.String1)); } } } For simplicity change the code to match the listing below: Tip All example code should be copied directly from this page and pasted into the Visual Studio program editor. using Microsoft.SPOT; public class Program { public static void Main() { Debug.Print(\"Amazing!\"); } } Selecting Transport When compiling a NETMF Console Project, there are options in Video Studio that control where the program is loaded and run. Select the menu item for the project's properties: In the Properties window, on the left side tabs, select .NET Micro Framework and make sure that Transport: is set to Emulator. Console applications have their Debug.Print statements appear in Visual Studio's Output Window. The application in this example uses print statements. If the Output window is not visible, open it by selecting Output in the View menu. Executing Press F5 and Visual Studio will compile the program, load it into the emulator and run it. The emulator displays a hypothetical NETMF device, complete with buttons and a screen. Do not close it. After a few seconds, the program will stop and the Output window will have \"Amazing!\" printed (surrounded by other application information). Introduction to Debugging The following sections are a quick introduction to the power and ease of debugging NETMF applications. Start running the program by pressing F11 (instead of F5 ), this will \"step\" into the application instead of just running it. After deployment, the program starts to run and stops at the very first line of the code. This is indicated by the yellow arrow. Press F11 to step to the \"Debug.Print\" statement. Finally, after pressing F11 one more time, \"Amazing!\" is printed in the Output window. Press F5 to let the program run to completion. Breakpoints Setting breakpoints is simple! -- Click in the bar to the left of the line that prints \"Amazing!\" A red dot appears to mark the breakpoint location. Press F5 to run the software. When the application reaches the breakpoint the debugger will pause: F11 can be used to single step execution line by line. F5 can be used to let the program run. Running on Hardware Deploying and running NETMF applications on hardware is very simple. Just connect the hardware, change an option in Visual Studio, and all loading, running, debugging, etc. are done on the device. The complete procedure is described below. Warning When working with hardware, take care not to expose the hardware to static electricity as it can damage the device. Connect and Power-up Connect the NETMF hardware to the PC using a USB cable. This is done one of two ways. If the processor has an integral USB port and is colored red, plug a USB cable from the computer directly to the board. Processors without an integral USB port will use a Gadgeteer socket to connect the power/USB module to the board. For these boards connect the power module to a \"D\" labeled socket on the board, then connect the power/USB module to the computer. (These circuit boards are black). The first time a processor is connected to the computer, Windows will need to load a driver. Wait until the driver is fully loaded before proceeding. Updating Device Software Before using a NETMF device, the embedded software must match the version of the SDK being used. Instructions for updating the embedded software are found on the Firmware Update page. If necessary, update your firmware, and then return here to continue the tutorial. Skipping the above step is the most common problem faced by beginners . Tip Many USB hubs are poorly implemented in PCs. If Windows failed to recognize the NETMF device or had any connection problems, make sure the device is connected directly to the PC, not through a USB hub. If problems persist, try using a power transformer or powered USB hub to guarantee the device is getting sufficient power. Deploying to Hardware Once the board is connected, Visual Studio has a control to switch back and forth between the emulator and connected hardware. From the project properties, select USB for transport.. Make sure the setup looks similar to the image below: Pressing F5 sends the simple application to the hardware and runs it. Debugging works exactly the same as described above. Next Steps We are currently updating the NETMF documentation found in our NETMF Tutorials ."
  },
  "index.html": {
    "href": "index.html",
    "title": "GHI Electronics Documentation",
    "keywords": "GHI Electronics Documentation Here you will find GHI Electronic's product documentation. For more information visit the main website at www.ghielectronics.com . You can also visit our community forums at forums.ghielectronics.com . Note Please check back often for the latest updates to our products, documentation, and software. Product Sections UCMs (Universal Compute Modules) Interchangeable plug-in microcontroller modules suitable for a wide variety of applications. Learn More... SCMs (Surface Compute Modules) Surface mount microcontroller modules ideal for harsh or high vibration environments. Learn More... FEZ The Maker Board to Rule Them All! Learn More... TinyCLR Operating System TinyCLR OS is light weight .NET operating system for IoT and embedded devices. Learn More... NETMF The original embedded .NET upon which TinyCLR OS is based Learn More... File System Technical details and manuals for the File System products. Learn More... You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/gadgeteering.html": {
    "href": "hardware/gadgeteering.html",
    "title": "Gadgeteering",
    "keywords": "Gadgeteering Gadgeteering was meant to extend Gadgeteer beyond NETMF. We are making our hardware and software available for reference only. All material is found at this github repository Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/duino/intro.html": {
    "href": "hardware/duino/intro.html",
    "title": "Duino Intro",
    "keywords": "Duino Intro Our Duino boards offer Arduino pinout compatible sockets that will accept standard Arduino expansion boards or \"shields.\" They run TinyCLR and can be programmed in C# or Visual Basic using the Microsoft Visual Studio development environment."
  },
  "hardware/duino/fez-panda-ii.html": {
    "href": "hardware/duino/fez-panda-ii.html",
    "title": "FEZ Panda II",
    "keywords": "FEZ Panda II An Arduino-pinout compatible single board computer. Resources Schematic Software For information on programming the FEZ Panda II, please go to the USBizi page."
  },
  "hardware/duino/fez-cerbuino-net.html": {
    "href": "hardware/duino/fez-cerbuino-net.html",
    "title": "FEZ Cerbuino Net",
    "keywords": "FEZ Cerbuino Net An Arduino-pinout compatible single board computer with Gadgeteer sockets. Resources Schematic Software For information on programming the FEZ Cerbuino Net, please go to the FEZ Cerberus page."
  },
  "hardware/breakout/g30-th.html": {
    "href": "hardware/breakout/g30-th.html",
    "title": "G30 TH Module",
    "keywords": "G30 TH Module A through-hole version of G30. Resources Schematic Software For information on programming the G30 TH Module, please go to the G30 page."
  },
  "hardware/breakout/fez-cerb40.html": {
    "href": "hardware/breakout/fez-cerb40.html",
    "title": "FEZ Cerb40",
    "keywords": "FEZ Cerb40 DIP40 form factor board. Not really a Gadgeteer board but it is very small! Schematic FEZ Cerb40 II Same as the FEZ Cerb40 with an added regulator chip. Schematic"
  },
  "hardware/mbuino.html": {
    "href": "hardware/mbuino.html",
    "title": "mBuino",
    "keywords": "mBuino The mBuino is a tiny keychain circuit. It is GHI Electronics contribution to the mbed community. Learn more here Schematic Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/tinyclr/tutorials/resources.html": {
    "href": "software/tinyclr/tutorials/resources.html",
    "title": "Resources",
    "keywords": "Resources From fonts and bitmaps to lookup tables and binary files, TinyCLR OS lets you add resources right into the program to access later. Right-click on your project and Add->New Item... . From here select Resource File . You can now drag resources right into the file. In the background, a file is generated to reflect the added resources. Using the resource will look similar to var resourceData = Resource.GetBytes(Resource.BinaryResources.data); Tip If you are copying an example code that uses resource, some minor changes are needed to match the resources' names in your project."
  },
  "software/tinyclr/tutorials/pwm.html": {
    "href": "software/tinyclr/tutorials/pwm.html",
    "title": "PWM",
    "keywords": "PWM Pulse Width Modulation (PWM) is a very useful feature found on most microcontrollers. PWM is a method of generating a square wave signal of uniform frequency with variable duty cycle. PWM is often used to generate analog voltages, but has many other uses such as generating digital pulses for driving servo motors or driving infrared LEDs for communication. The ratio of the pulse width to it's period is called the duty cycle. Through software, you can control both the PWM frequency and duty cycle. Tip We usually use GetDefault() for most peripherals. For example, there is only one GPIO controller on most systems. This is not the case with PWM. Never use the Default controller and always select the proper channel on the corresponding controller. Tip PWM2.3 is channel 3 on controller 2 Energy Level PWM is perfect for dimming an LED or controlling the speed of a motor. When the duty cycle is 50%, half the energy is transferred to the attached load. This demo will fade the FEZ LED1 in and out using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Pins; class Program { private static void Main() { var controller = PwmController.FromName(FEZ.PwmChannel.Controller4.Id); var led = controller.OpenChannel(FEZ.PwmChannel.Controller4.Led1); controller.SetDesiredFrequency(10000); double duty = 0.5, speed = 0.01; led.Start(); while (true) { if (duty <= 0 || duty >= 1.0) { speed *= -1; //Invert direction. duty += speed; } led.SetActiveDutyCyclePercentage(duty); duty += speed; Thread.Sleep(10); //Always give the system time to think! } } } Musical Tones Musical notes have specific frequencies; C for example is about 261Hz. Plugging these numbers into an array and knowing the length of each tone is all that is needed to play some simple music. When playing notes by changing the frequency, keep the duty cycle set to 0.5. using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Pins; class Program { const int NOTE_C = 261; const int NOTE_D = 294; const int NOTE_E = 330; const int NOTE_F = 349; const int NOTE_G = 392; const int WHOLE_DURATION = 1000; const int EIGHTH = WHOLE_DURATION / 8; const int QUARTER = WHOLE_DURATION / 4; const int QUARTERDOT = WHOLE_DURATION / 3; const int HALF = WHOLE_DURATION / 2; const int WHOLE = WHOLE_DURATION; //Make sure the two below arrays match in length. Each duration element corresponds to // one note element. private static int[] note = { NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_E, NOTE_D, NOTE_D, NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_D, NOTE_C, NOTE_C}; private static int[] duration = { QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, HALF, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, WHOLE}; private static void Main() { var controller = PwmController.FromName(FEZ.PwmChannel.Controller1.Id); var toneOut = controller.OpenChannel(FEZ.PwmChannel.Controller1.D0); toneOut.SetActiveDutyCyclePercentage(0.5); toneOut.Start(); while (true) { for (int i = 0; i < note.Length; i++) { controller.SetDesiredFrequency(note[i]); Thread.Sleep(duration[i]); } Thread.Sleep(100); } } } Servo Motors A servo motor is basically a motor that has a small internal circuit allowing you to control it using electrical pulses. Servo motors are available as either continuous or positional servos. While they look identical, a positional servo only turns to a given position and then holds that position until you tell it to move to another position. A continuous servo motor will rotate continuously in one direction until it is told to either stop or reverse direction. The pulse that controls servos is sent every 20 ms. This pulse will usually have a width between 1 ms and 2 ms but varies depending on the make and model of the motor. The position of a positional servo is based on the width of the pulse, with a 1.5 ms pulse moving to the middle of travel (90 degree position). With a rotational servo, 1.5ms will stop the motor, 1 ms is full speed, and 2 ms is full speed in the opposite direction. Tip As a rule, servos have three wires. Be sure the central wire is connected to 5V. The lighter color wire on one side of the connector is a signal and should be connected to a PWM pin. The third one, which is usually a darker color, is ground. This example will turn the positional servo to the zero degree position, wait half a second, and then turn it to 180 degrees. It will then rotate the continuous servo at maximum speed for half a second, and then reverse direction for half a second. You must add add the servo class (the code below this example) to your project for it to work. Tip Most servos will have a 1 ms minimum pulse width and a 2 ms maximum pulse width, but check the specs of the motor to be sure. using GHIElectronics.TinyCLR.Pins; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Devices.Servo; using System.Threading; class Program { private static void Main() { ServoMotor servo1 = new ServoMotor(ServoMotor.ServoType.Positional, PwmController.FromName(FEZ.PwmChannel.Controller1.Id), FEZ.PwmChannel.Controller1.D0); servo1.ConfigurePulseParameters(0.5, 2.4); //Settings for TowerPro SG90 micro servo. ServoMotor servo2 = new ServoMotor(ServoMotor.ServoType.Continuous, PwmController.FromName(FEZ.PwmChannel.Controller3.Id), FEZ.PwmChannel.Controller3.D6); servo1.Set(0); Thread.Sleep(500); servo1.Set(180); Thread.Sleep(500); servo1.Stop(); servo2.Set(100); Thread.Sleep(500); servo2.Set(-100); Thread.Sleep(500); servo2.Stop(); Thread.Sleep(-1); } } This is the servo.cs class that provides the methods used in the above code to control the servos: using GHIElectronics.TinyCLR.Devices.Pwm; using System; namespace GHIElectronics.TinyCLR.Devices.Servo { public class ServoMotor { private PwmChannel servo; private ServoType type; private double minPulseLength; private double maxPulseLength; public double position { get; set; } public enum ServoType { Positional, Continuous } public ServoMotor(ServoType type, PwmController controller, int PwmPin) { this.servo = controller.OpenChannel(PwmPin); this.ConfigurePulseParameters(1.0, 2.0); controller.SetDesiredFrequency(50); this.type = type; this.position = 0; } public void ConfigurePulseParameters(double minimumPulseWidth, double maximumPulseWidth) { if (minimumPulseWidth > 1.5 || minimumPulseWidth < 0.1) throw new ArgumentOutOfRangeException(\"Must be between 0.1 and 1.5 ms\"); if (maximumPulseWidth > 3 || maximumPulseWidth < 1.6) throw new ArgumentOutOfRangeException(\"Must be between 1.6 and 3 ms\"); this.minPulseLength = minimumPulseWidth; this.maxPulseLength = maximumPulseWidth; } public void Set(double value) { if (this.type == ServoType.Positional) { this.PositionalSetPosition(value); this.position = value; } else this.ContinousSetSpeed(value); } private void PositionalSetPosition(double angle) { if (angle < 0 || angle > 180) throw new ArgumentOutOfRangeException(\"degrees\", \"degrees must be between 0 and 180.\"); var duty = ((angle / 180.0 * (this.maxPulseLength - this.minPulseLength)) + this.minPulseLength) / 20; this.servo.SetActiveDutyCyclePercentage(duty); this.servo.Start(); } private void ContinousSetSpeed(double speed) { if (speed < -100 || speed > 100) throw new ArgumentOutOfRangeException(\"speed\", \"speed must be between -100 and 100.\"); PositionalSetPosition(speed / 100 * 90 + 90); } public void Stop() => this.servo.Stop(); } }"
  },
  "software/tinyclr/tutorials/pulse-feedback.html": {
    "href": "software/tinyclr/tutorials/pulse-feedback.html",
    "title": "Pulse Feedback",
    "keywords": "Pulse Feedback The PulseFeedback class can be used in three different modes. The below image shows an example pin capture for each of the modes. It is not drawn to scale. The area marked by the arrows is the time measured for each mode. Remember that the pulse and echo may be on separate pins. The first mode is EchoDuration. This mode sends a pulse of a given length and state over the provided pin. It then waits for an echo on the other specified pin and measures how long that echo pulse was. The echo and pulse pin can be the same if desired. The next mode is DurationUntilEcho. It is very similar to EchoDuration, although instead of sending a pulse and measuring the length of the resulting echo, it measures how long it takes until that echo is received. The final mode is DrainDuration. This mode is often used in capacitive touch. When calling Read, the pulse line will be held in the specified state for the specified time and then set to an input. When a resistor and capacitor are connected to this pin and ground, the pin will fall to ground after a short period of time dependent on the capacitance on the pin. The below image shows a sample circuit. Do note that this mode can only be used with a single pin. The below example illustrates sending a pulse of 10us and reading an echo on a second pin where both the pulse and echo are high, without using any pull-up or pull-down resistors. It prints out the total duration of the echo. It repeats every 250ms. using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Devices.Signals; using GHIElectronics.TinyCLR.Pins; using System; using System.Diagnostics; using System.Threading; public static class Program { public static void Main() { var pulse = new PulseFeedback(FEZ.GpioPin.D0, FEZ.GpioPin.D1, PulseFeedbackMode.EchoDuration) { DisableInterrupts = false, Timeout = TimeSpan.FromSeconds(1), PulseLength = TimeSpan.FromTicks(100), PulsePinValue = GpioPinValue.High, EchoPinValue = GpioPinValue.High, PulsePinDriveMode = GpioPinDriveMode.Input, EchoPinDriveMode = GpioPinDriveMode.Input }; while (true) { Debug.WriteLine(pulse.GeneratePulse().TotalMilliseconds.ToString(\"N0\")); Thread.Sleep(250); } } }"
  },
  "software/tinyclr/tutorials/memory.html": {
    "href": "software/tinyclr/tutorials/memory.html",
    "title": "Memory Management",
    "keywords": "Memory Management RAM Memory This memory type loses its content when the system is turned off. The system uses this memory at runtime to function. TinyCLR OS is a managed operating system. Allocated objects are automatically tracked and freed as needed. The Garbage Collector (GC) runs when the system runs low on available RAM, where it will look for unused objects and frees the memory they had occupied. You may also invoke the GC at any time using GC.Collect() . RAM is used a lot at runtime. It is important to understand needed memory and plan accordingly. When creating a data receiving buffer from UART for example, use a reasonable size that you really need. RAM Memory Size Free and used memory sizes can be measured at runtime. This helps in optimizing systems. var freeRam = GHIElectronics.TinyCLR.Native.Memory.FreeBytes; var usedRam = GHIElectronics.TinyCLR.Native.Memory.UsedBytes; Allocating Memory TinyCLR OS Garbage Collector allocates and frees objects automatically on the heap. When the memory gets fragmented, the system will compact the heap. This is the desired behavior but this also creates a problem when sharing resource between TinyCLR OS and native drivers. In advance setup, a user may have a buffer that gets written to from an interrupt routine. Assuming this is implemented in native code, we would need a buffer that always sits at a fixed address. Using var buffer = new byte[12]; will not work as the garbage collector may move the buffer to compact the heap. A fixed location buffer can be allocated using GHIElectronics.TinyCLR.Native.Memory.Allocate() . Keep in mind that this is not managed memory anymore and you are responsible to free this memory using GHIElectronics.TinyCLR.Native.Memory.Free() . Memory Allocation Cost Creating/disposing objects is costly, especially when used in inner loops. Assuming there is a method that sends a byte array over a buses/network. Also assuming we there is a byte that needs to be sent. We will need to create a byte array of size one. void WritByte(byte b) { var ba = new byte[1]; // use that byte ba[0] = b; Network.SendByteArray(b); } The code will work just fine but if it is being used in inner loops and it is being called 1000/second, then it will need to create and lose 1000 individual arrays. The system will run better if the array is created only once. byte[] ba = new byte[1]; void WritByte(byte b) { // use that byte ba[0] = b; Network.SendByteArray(b); } Disposing Objects With TinyCLR OS being managed system that monitors and frees resources, memory/object leaks become less of a concern. However, there is still chance that issues can arise, especially in embedded systems, where objects can be a combination of memory and a physical thing. Take a GPIO pin for example. What happens when we no longer have a reference to a pin? Will the GC free the object? Will the pin change in state when the GC frees the pin? And finally, why would a pin (or any physical object) be left for the GC to decide how it should be freed? The right answer is that we need to understand and track these resources manually. This example code will turn an LED on but we it not be able to control that pin anymore. The BadExample method uses a pin but it doesn't free it. class Program { static void BadExample() { var led = GpioController.GetDefault().OpenPin(FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); led.Write(GpioPinValue.High); } static void Main() { BadExample(); // This code will raise an exception var led = GpioController.GetDefault().OpenPin(FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); led.Write(GpioPinValue.Low); //... } } This example will Dispose the pin and the code will work; however, disposing the pin may take the pin back to the default state. There is no exact definition on what a piece of hardware (pin in this example) does when disposed. class Program { static void BadExample() { var led = GpioController.GetDefault().OpenPin(FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); led.Write(GpioPinValue.High); // Free the pin, but this may change the pin status to default led.Dispose(); } static void Main() { BadExample(); // This code will now work var led = GpioController.GetDefault().OpenPin(FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); led.Write(GpioPinValue.Low); //... } } In this basic example, the fix can be in moving the LED object to be always available and accessible to the entire class. class Program { static GpioPin led; static void Example() { led.Write(GpioPinValue.High); } static void Main() { // Init the hardware led = GpioController.GetDefault().OpenPin(FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); // You can use the pin everywhere now // ... in the method Example(); // ... and here led.Write(GpioPinValue.Low); //... } } Flash Memory Flash memory does not lose its content on power loss, like an SD memory card for example. There are special requirements to write to flash but you can read Flash just like RAM. When deploying a program, the TinyCLR Device Deployment window will show what is being loaded and how large it is. It will then show how much free Flash is still available. Assemblies deployed. There are 2,408,408 bytes left in the deployment area. Flash is not typically written to at runtime. The system will function even with no free available FLASH. Resources TinyCLR OS allows resources, like fonts and images, to be merged into the project as a resource and then deployed to the device's flash. Those resources can then be fetched into RAM and used at runtime. The Resource tutorial has more details. Direct Access In some cases, it is necessary to be able to write/read directly to a specific address in memory. For example, to configure an internal register. The Marshal class found in System.Runtime.InteropServices provides several methods to read and write memory directly. This code assumes we need to set the third bit in a 32 bit register located at 0x12345678. var address = new System.IntPtr(0x12345678); Marshal.WriteInt32(address, Marshal.ReadInt32(address) | (1 << 3)); Tip You can only read from Flash, not write."
  },
  "software/tinyclr/tutorials/adc.html": {
    "href": "software/tinyclr/tutorials/adc.html",
    "title": "ADC",
    "keywords": "ADC Unlike digital input pins, which can only read high or low, analog pins can read a range of voltage levels. Microcontrollers based on 3.3V can typically read voltages anywhere between zero and 3.3V. Analog inputs connect internally to an Analog to Digital Converter (ADC) that converts the analog voltage level on the pin to a digital value. The resolution of the ADC determines its accuracy. An 8bit ADC has 256 steps to work with, 3.3V/256=0.013V. This means an increase of 0.013V will increase the value by one. In other words, a voltage change of less than 0.013V has no effect. The ADC on FEZ is 12bit and should fit most needs. Tip Note that the analog channel number is not the pin number. We have these easily enumerated for FEZ, but you need to determine the channel number on a specific pin using your system's documentation. This example will read the ratio, that is 0 to 1, of an analog input. After running the program, connect a wire from the analog pin to ground and you should see a zero or something really close to zero. Connect to 3.3V and you will see 1 or something close, like 0.99. using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Pins; class Program { private static void Main() { var adc = AdcController.GetDefault(); var analog = adc.OpenChannel(FEZ.AdcChannel.A0); while (true) { double d = analog.ReadRatio(); Debug.WriteLine(\"An-> \" + d.ToString(\"N2\")); Thread.Sleep(100); } } }"
  },
  "software/tinyclr/native/porting.html": {
    "href": "software/tinyclr/native/porting.html",
    "title": "Porting TinyCLR",
    "keywords": "Porting TinyCLR TinyCLR OS can be ported to new devices. We provide the precompiled .NET interpreter and runtime for several architectures. Currently Cortex M3, Cortex M4, Cortex M7, ARM7, and ARM9 are supported. To get started we'll build the FEZCLR firmware that the FEZ uses. Clone the ports repo to your computer. Make sure to clone the master branch so you're using the latest stable version. If you're new to git or haven't even heard of it, take a look at the Git Book to learn more about it. Download and install GCC . The latest version we have tested is 7-2018-q2-update . Download and extract the contents of CMSIS into the CMSIS folder of the cloned repo. While the file extension is *.pack , it's actually a zip that you can extract once you rename it to *.zip . Download and extract the latest TinyCLR OS Core Library into the Core folder of the cloned repo. Make sure to download the version corresponding to the version of the source code that you're trying to build. If you're building the master branch, then you want to use the very latest released version. Open a command prompt, change the directory to the cloned repo, and then execute build.bat FEZCLR . The compiled firmware can then be found in the repo directory under build\\release\\FEZCLR . The build system automatically produces firmware images in hex format (.hex), a raw binary (.bin), and either a binary meant to be loaded by our GHI Bootloader with its U command (.glb) or a binary meant to be loaded by the same bootloader with the X command (.ghi). For the FEZCLR firmware we built, flash the FEZCLR Firmware.glb to your FEZ following the instructions on the bootloader page. When you restart it, it should be running TinyCLR OS and you can deploy to it from Visual Studio. Creating your own device To create a new firmware for a board that a Target already exists for, you just need to create a new folder under Devices to define your board. You can do this easily by copying an existing board, like the FEZ, and making the changes you need for your board. Make sure you update the scatterfile to place the final firmware image in memory where it needs to be. For example, the FEZ scatterfile expects the GHI Bootloader to be present but you need to place your firmware's image at the start of flash. To make using a custom port easier, we're specifically making the USB product ID 0x5000 under our vendor ID (0x1B9F) available for anyone to use for the USB debug interface on their TinyCLR device. Make sure to only use this product ID because other product IDs are assigned by us for our own use. Of course, if you have your own vendor ID, you are free to use it. So when you copy an existing device to make a new one, be sure to verify the USB vendor and product IDs are correct. Creating a new target To port to a new board with a new Target , make sure it is one of the architectures that we have made a core library available for. Then, like above, you'll need to make a new folder for your device under the Devices folder. You'll also need to create a new folder under Targets that implements the needed APIs. The TinyCLR runtime requires you to provide a few APIs for it to function correctly: deployment, interrupt, power, and time. The runtime also makes a few APIs available to you automatically: the API provider itself; a memory allocator; a recurring task creator; and a way to interact with managed objects, arguments, and events. Beyond that, you can provide whatever APIs you need like GPIO and SPI. See the native API document for details on APIs. On top of providing several APIs, you must call all the functions under TinyCLR_Startup_* to properly initialize the system. The main.cpp provided in the repo that our existing ports use and the build system includes is a good starting point. Contributing We are taking contributions to the TinyCLR OS ports and documentation, but we don't have an established process just yet, so standard contributing practices apply. Create a fork of the repo, create a new branch from dev, work on your changes, then submit a PR. Make sure to follow the existing style for the project and keep your changes easily reviewable. Your changes will need to be licensed under Apache 2 and you need to sign a Contributor License Agreement with us before your PR can be accepted."
  },
  "software/tinyclr/roadmap.html": {
    "href": "software/tinyclr/roadmap.html",
    "title": "Roadmap",
    "keywords": "Roadmap We've shipped TinyCLR 1.0 and have begun to work on the next version. We will continue to evaluate stability and may issue some bug-fix only releases like a 1.0.1. The bulk of our effort is going towards the next major release where we plan to investigate commercial features like In-Field Update, USB Host and USB Client and networking -- specifically a built-in networking and TLS stack with drivers for our Ethernet PHYs and perhaps also some WiFi modules. Previews for these features will start landing over the next few months. Longer term we do plan to investigate support for generics and a fully conforming ECMA-335 implementation and, once we have that, alignment with .NET Standard. Keep in mind that all of this is subject to change and does not include many smaller improvements and features. We may change what features we plan to deliver, drop some entirely, or change when they get delivered. Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/tinyclr/release-notes.html": {
    "href": "software/tinyclr/release-notes.html",
    "title": "Release Notes",
    "keywords": "Release Notes 1.0.0 on 2018-12-27 Notes We're happy to release the first production-ready version of TinyCLR OS, our modern and managed .NET development system for tiny IoT and embedded devices that uses the world-class Microsoft Visual Studio with C# and Visual Basic. TinyCLR can be used commercially on our System on Modules but you can also port it to your own system, free of charge, using our prebuilt cores for ARM7, ARM9, Cortex M3, Cortex M4, and Cortex M7 and the freely available GCC compiler. We're already hard at work on the next release where we plan to bring even more features that make embedded development even faster and easier. The libraries, extension, and firmwares are all uploaded to their online sources so you can update your firmware using TinyCLR Config, update your packages using the NuGet package manager with the NuGet.org source, and update the VSIX from the extensions area of Visual Studio. To get going, take a look at the Getting Started guide. Libraries Changes None. Known Issues Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors #51 . DrawPicture on the BrainPad does not work correctly #313 . SPWF04Sx Wi-Fi on the FEZ does not work unless PA0 is manually set low before initialization #28 . Firmware Changes None. Known Issues Testing NaN s for equality gives unexpected results #231 . The .constrained IL prefix is not supported and throws UnsupportedInstructionException #76 . Using exception filters may crash the system in some uses #177 . CAN message timestamps use the wrong origin #579 . CAN timing calculation does not use all of the values correctly #576 . Signal generator generates incorrect timings in some cases #526 . Multi-pin reservations where the first pin is already reserved mistakenly return okay #580 . PWM polarity is opposite from what it should be on G120 and G400 #581 . The first clock for signal generator is the same as idle state #582 . When not debugging the application may slow down #584 . TinyCLR Config Changes None. Known Issues None. Extension Changes None. Known Issues When adding an image or font to a resx file, a reference to the drawing assembly is not automatically added #90 . Porting Changes None. Known Issues None. 1.0.0-preview3 on 2018-11-30 Notes This release is the third and final planned preview of the 1.0 release for TinyCLR. There have been no major changes in this release -- its entire focus was bug fixing. We'll wait a few weeks to ensure no major issues are discovered before rebuilding with the final release version numbers and doing the final release. We are also maintaining our decision to keep throwing an exception when .constrained is encountered instead of potentially allowing silent and incorrect behavior. It is currently known to be used when accessing overridden members on structs, particularly those from object like ToString , Equals , and GetHashCode . You'll encounter it on enum and TimeSpan , among others. The libraries, extension, and firmwares are all uploaded to their online sources so you can update your firmware using TinyCLR Config, update your packages using the NuGet package manager with the NuGet.org source, and update the VSIX from the extensions area of Visual Studio (make sure to include pre-releases for NuGet as this is still a preview). We will still make these binaries available on our own hosting as well, but the expected workflow remains the usual NuGet/marketplace search and download process you have for other packages and extensions. You can find all downloads in their respective sections on the downloads page. Libraries Changes Fixed cases where SPWF04Sx will sometimes lose writes #14 . Fixed SPWF04SxConnectionType being misspelled #26 . Fixed GetFiles and EnumerateFileSystemEntries having an extra slash in path #309 . Fixed managed drawing functions throwing when out of range #300 . Fixed red and blue being swapped in the UI library #306 . Fixed some pins and ports names being out of sync #193 . Fixed software I2C not running at a consistent speed #515 . Fixed software SPI not respecting ChipSelectType #459 . Added missing SD, RTC, and Wi-Fi names to pins #266 . Added chipselect hold and setup time to software SPI #292 . Added support for carrier frequency in signal generator #477 . Changed DrawPixel in display controller to use the format of the display controller #543 . Removed setter from IDriveProvider.Name in place of an Initialize method #297 . Known Issues Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors #51 . SPWF04Sx Wi-Fi on the FEZ does not work unless PA0 is manually set low before initialization #28 . Firmware Changes Fixed PWM jittering when decreasing the pulse width #102 . Fixed the reported messages received on CAN being incorrect #527 . Fixed the CTS changed event not working #59 . Fixed deployment not getting added to api manager #545 . Fixed SupportedDataFormats in display throwing an exception on access #572 . Fixed DrawString not resetting row/column on soft reboot #542 . Fixed enabling CAN before setting timings throwing the wrong exception #554 . Fixed the Read and Write in storage provider crashing the device #495 . Fixed use of filesystem crashing the second deploy without a power cycle #457 . Fixed being able to mount the filesystem after previously unmounting it #491 #506 . Fixed the system crashing if the SD card is removed after acquiring the controller #498 . Fixed deploying on G120 and G400 sometimes failing #431 . Fixed G120 disappearing in TinyCLR Config if the device is rebooted #513 . Fixed enabling handshaking on UART2 crashing the G30 #518 . Fixed signal generator failing on G400 #461 . Fixed software I2C failing on G400 #458 . Fixed G80 serial debug not working #456 . Fixed GPIO interrupts not always working #496 #578 . Fixed graphics getting corrupt on the UC5550 after some time #562 . Fixed RTC not working on G400 #460 . Fixed rebooting the device in serial mode taking a long time #509 . Fixed the native SPI drivers not respecting ChipSelectType #471 . Fixed SPI SupportedDataBitLengths throwing an exception on access #557 . Fixed the storage description having wrong values and format for size, address, and attributes #544 #571 . Fixed multi-pin reservations not releasing previously reserved pins if a pin fails to reserve #312 . Fixed the timestamp for HAL events using the wrong origin #546 . Fixed GetMessagesToWrite in CAN crashing the device #555 . Fixed the UART DataReceived event not raising for all data #547 . Fixed UART handshaking not always working #462 . Fixed UARTHS-B handshaking not working on UC2550 #517 . Fixed entering bootloader from TinyCLR Config not working on UC5550 #503 . Fixed UC5550 sometimes crashing #484 . Removed the -mlong-calls compiler flag #501 . Removed display backlight from the native driver #481 . Improved performance of flushing the display on STM32F7 #487 . Changed pins to default pull-up #563 . Known Issues Testing NaN s for equality gives unexpected results #231 . The .constrained IL prefix is not supported #76 . Using exception filters may crash the system in some uses #177 . CAN message timestamps use the wrong origin #579 . CAN timing calculation does not use all of the values correctly #576 . Signal generator generates incorrect timings in some cases #526 . Multi-pin reservations where the first pin is already reserved mistakenly return okay #580 . PWM polarity is opposite from what it should be on G120 and G400 #581 . The first clock for signal generator is the same as idle state #582 . TinyCLR Config Changes Added a version field to the UI #24 . Known Issues None. Extension Changes Fixed deploying a project using fewer sectors than a previous project leaving old assemblies on the device #151 . Fixed inspecting certain variables in the debugger locking up the device #152 . Fixed rebooting TinyCLR sometimes throwing when trying to connect to the USB stream #155 . Known Issues When adding an image or font to a resx file, a reference to the drawing assembly is not automatically added #90 . Porting Changes Fixed product version string showing the version numbers and not the friendly string #356 . Fixed some API IDs and target names not matching #292 . Added interrupt and sleep data to power #480 . Added USB get connection status #568 . Added OneWire API type ID #359 . Added TouchController API type ID #357 . Added USB connection event and property #367 . Removed the presence event and property from storage #361 . Known Issues None. 1.0.0-preview2 on 2018-09-28 Notes This release is the second preview of the 1.0 release for TinyCLR. It also marks the point where we are feature complete for 1.0! If we do another preview release, it'll just be a bug fix release. The biggest change in this release is the addition of a managed graphics provider and the initial release of some drivers for common chips (like the one on our old N18 display). There are also several usability tweaks to SPI and the three signals classes. To support uploading to the Visual Studio gallery, we had to change the package ID used by the project system extension. This means the old one will not get uninstalled when installing this release, so please uninstall the preview1 or older extensions manually. We're also releasing a tool to convert desktop TrueType fonts to the format used by TinyCLR. Keep in mind there are legal implications to using and distributing fonts and that we cannot provide advice on that. The tool used to convert binary files to glb and ghi files was also updated to support generating UF2 files used by the BrainPad (which has its own new firmware in this release as well, available on https://brainpad.com/ ). The UC2550 and UC5550 now come in a glb format instead of the old ghi format and you can find their device definitions in the ports repo as well. There is also a new bootloader for the UC5550 available on the bootloader page . We have decided to keep throwing an exception when .constrained is encountered instead of potentially allowing silent and incorrect behavior. It is currently known to be used when accessing overridden members on structs, particularly those from object like ToString , Equals , and GetHashCode . You'll encounter it on enum and TimeSpan , among others. The libraries are once again uploaded to our NuGet account . Make sure to enable finding prereleases in the NuGet package manager. We've also uploaded the extension to the Visual Studio Marketplace so you can download and install it from there and then keep it up to date with Visual Studio. We will still make them available on our own hosting as well, but the expected workflow remains the usual NuGet/marketplace search and download process you have for other packages and extensions. You can find all downloads in their respective sections on the downloads page. As before, you can update your firmware using TinyCLR Config and now you can update your packages using the NuGet package manager from the online source. Libraries Changes Added chip select setup time, hold time, and polarity to SPI settings. Added Now to RtcController that takes a DataTime . Added IsValid to RtcController . Added Rgb444 and VerticalByteStrip1Bpp display formats. Added I2C display interface type. Added a public constructor to Font . Added infrastructure to provide custom draw targets to be used with a managed graphics implementation using GraphicsManager in drawing. Added built in draw targets that draw to an in-memory buffer in various formats. Added AssemblyInformationalVersion attributes to every library. Added SSD1306 , ST7735 , and APA102C drivers. Added Memory to the native library that exposes members from the native provider. Added ChipSelectType to SpiConnectionSettings to pick between GPIO, controller, and none. Fixed red and blue being swapped in the internal field of Color . Fixed software I2C not working #365 . Fixed software SPI not working #293 . Moved SPWF04Sx driver to the drivers namespace and package. Removed UseControllerChipSelect from SpiConnectionSettings . Removed the constructor from SpiConnectionSettings . Known Issues SPWF04Sx may sometimes lose writes #14 . Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. A number of API names are missing from pins, notably RTC and SD. Carrier frequency does not work on signal generator. Firmware Changes Added new BrainPad BP2 firmware. Added signals to UC2550 and UC5550. Added filesystem to G30 #322 . Fixed DisplayController.DrawBuffer failing for data not sized to the entire screen #410 . Fixed DisplayController.DrawPixel using an incorrect format. Fixed ADC on G120E failing if closed multiple times #438 . Fixed UART failing to receive any data after receiving an error on G400 #428 . Fixed CAN pins being reversed on the UC2550. Fixed memory intensive applications crashing low-memory devices #423 . Fixed I2C failing on some slaves, #416 . Fixed UART DataReceived event always returning a count of zero. Fixed servo not working on the BrainPad, #414 . Fixed multiple I2C devices failing when used together. Fixed heavy serial load crashing STM32Fx devices #411 . Fixed the Edge property on the GPIO interrupt sometimes being incorrect. Fixed G400 ADC not always being accurate #373 . Fixed several HAL functions having no implementation #376 . Fixed the run-app pin failing on USBizi #333 . Fixed the UD700 getting corrupt on the UC5550 after a few minutes. Implemented all of signal capture and pulse feedback and most of signal generator #357 . Implemented many functions missing on USB client #398 . Known Issues PWM may jitter when decreasing the pulse length while enabled. Testing NaN s for equality gives unexpected results. The .constrained IL prefix is not supported. Using exception filters may crash the system in some uses #177 . During multi-pin reservations, if a later pin fails to reserve, previously reserved ones are not released #312 . Serial debug sometimes fails on G80 #456 . Deployment after accessing filesystem fails #457 . Software I2C fails on G400 #458 . Software SPI fails for some slaves #459 . RTC fails on G400 #460 . G400 signal generator generates incorrect timings #461 . UART handshaking behaves inconsistently #462 . TinyCLR Config Changes Fixed help URLs. Known Issues None. Extension Changes Updated the package ID of the VSIX. Known Issues When adding an image or font to a resx file, a reference to the drawing assembly is not automatically added. Porting Changes Added timestamps to many device event handlers #388 #368 . Added IsValid to TinyCLR_Rtc_Controller . Added a config object to TinyCLR_Display_SpiConfiguration . Added TinyCLR_Display_I2cConfiguration . Added TinyCLR_Startup_SetMemoryProfile that allows setting the memory profile of the device. Added GetStats to TinyCLR_Memory_Manager to return amount of memory free and used. Added wake source to TinyCLR_Power_Controller::Sleep . Added contiguous and equal-sized properties to the deployment configuration. Added UC2550 and UC5550 device headers to ports. Added UF2 support to imagegen.exe #412 . Changed the sleep level names to LevelN . Changed SPI, I2C, UART, and CAN configuration to take a config struct. Changed CAN read and write to take a message struct. Changed TinyCLR_Startup_SetDeploymentApi to TinyCLR_Startup_AddDeploymentRegion . Changed return type to TinyCLR_Result on power. Changed TinyCLR_Task_Manager::Enqueue time unit to be native ticks. Changed many of the members in TinyCLR_Interrupt_Controller . Changed the parameter apiName to data0 (and shifted the rest) in TinyCLR_Interop_Manager::RaiseEvent . Changed RegionsRepeat into contiguous and equal-sized in storage. Fixed the linker not always complaining when regions overflow #30 . Known Issues None. 1.0.0-preview1 on 2018-08-15 Notes This release is the first preview of the 1.0 release for TinyCLR. We will have at least one other preview after this one. The biggest change in this release is the rework and simplification of the devices library. It was divided into one library per peripheral to reduce deployment size for apps that don't require all libraries. We did keep the devices package as a metapackage that depends on the other packages so you can easily bring them all into your project if desired. Many of the devices did keep a familiar API like ADC, DAC, and GPIO. Others like I2C and SPI did keep a similar device API but the controller was reworked. Previously you'd be able to call FromId on the device or controller object. Now you must call FromName on the controller and then call GetDevice . A few others had minor tweaks to names and members. Of particular note are that you must now call Enable to turn the display on and mounting with FileSystem now requires the Hdc property from the SdCardController instead of the controller instance itself. UART saw a lot of changes in this release. The entire storage library was removed and the SerialCommunication class was changed into UartController to mirror the pattern used with all of the other devices. DataReader and DataWriter are gone as well, so reading and writing to UART can only be done with a byte array. We also introduced a new native library that holds many of the things we added to mscorlib previously like interops, APIs, system time, NativeEventDispatcher , and, new in this release, power. Given the amount of changes in the HAL layer we do expect a few more bugs in this release, but we are working to iron them all out before 1.0. .constrained continues to throw in this release as we gather more data. It is currently known to be used when accessing overridden members on structs, particularly those from object like ToString , Equals , and GetHashCode . You'll encounter it on enum and TimeSpan , among others. We will be making a decision soon on whether or not to revert the exception before the final release. In preparation for the official 1.0 release we are no longer building the firmwares for older unsupported devices. Please see this doc for more information. The source code remains available though so we invite you to contribute to it and build your own firmware. We have also uploaded the libraries to our NuGet account . Make sure to enable finding prereleases in the NuGet package manager. We will still make them available on our own hosting as well, but the expected workflow going forward is the usual NuGet search and download process you have for other packages and extensions. You can find all downloads in their respective sections on the downloads page. As before you, can update your firmware using TinyCLR Config and now you can update your packages using the NuGet package manager from the online source. There are no new bootloaders in this release. Libraries Changes Reworked the APIs of many of the peripherals in GHIElectronics.TinyCLR.Devices library, particularly UART. Split up the GHIElectronics.TinyCLR.Devices into one library per peripheral. Removed the GHIElectronics.TinyCLR.Storage library. Added a new GHIElectronics.TinyCLR.Native library and moved SystemTime , Interop , Api , and DeviceInformation to it. Added Power to GHIElectronics.TinyCLR.Native . Added DrawPixel to the display controller. Added DrawBuffer to the display controller. Added Enable and Disable to many controllers. Reworked SystemTime to have GetTime and SetTime with DateTime overloads. Reworked and simplified the entire provider model, removing many classes in the process. Renamed OutputEnable to DataEnable on DisplayController . Renamed ApplySettings to SetConfiguration on DisplayController . Renamed PwmPin to PwmChannel . Fixed GetDirectories always throwing #343 . Reduced the default brightness of the light bulb on the BrainPad. Known Issues SPWF04Sx may sometimes lose writes. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. A number of API names are missing from pins, notably RTC and SD. The Edge property of GPIO interrupts is not always correct. Many properties on SignalGenerator and SignalCapture do not work. PulseFeedback does not work. SoftwareI2C does not work #365 . DisplayController.DrawBuffer does not work with a non-zero origin or size different than the entire screen #410 . DisplayController.DrawPixel draws the incorrect color. The timestamp is incorrect when creating a new file. Firmware Changes Fixed I2C sharing conflicts incorrectly throwing OutOfMemoryException #298 . Fixed OutputEnablePolarity being inverted on UC5550 #315 . Fixed some SD cards getting corrupt after use on G400 #319 . Fixed G120 getting stuck deploying #331 . Fixed CAN not working on G400 #332 . Fixed the run app pin not working on USBizi #333 . Fixed paths requiring an extra \\ after the drive letter #334 . Fixed the display on the G400 reserving PC26 #336 . Removed the SPI display controller implementation. Known Issues PWM may jitter when decreasing the pulse length while enabled. UART handshaking may miss data on STM32F4. Testing NaN s for equality gives unexpected results. SignalGenerator and SignalCapture do not work on UC2550 and UC5550. The UD700 will become corrupted after running for a few minutes on the UC5550. Using exception filters may crash the system in some uses #177 . Software SPI does not work with some devices #293 . During multi-pin reservations if a later pin fails to reserve, previously reserved ones are not released #312 . Filesystem is not available on G30 #322 . The ADC is not accurate on the G400 #373 . Many events do not pass a timestamp #368 . Many of the non-essential functions of USB client are not implemented #398 . Using UART may eventually lockup the UC5550 #411 . TinyCLR Config Changes Allowed the app to be resized. Known Issues None. Extension Changes None. Known Issues When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. Porting Changes Simplified many of the controller APIs. Removed the controller number from the various controllers. Renamed many instances of provider to manager or controller. Updated to use the latest GCC. Removed Acquire and Release from core-provided APIs. Changed to an initialize and uninitialize pattern for required APIs. Added InteropManager to TinyCLR_Interop_MethodData . Merged DeploymentProvider and SdCardProvider . Changed specifying the deployment API to a dedicated function call. Changed InteropManager::GetArgument to start at index 0 for all arguments, regardless of instance or static. Known Issues The linker will not error when regions overflow or overlap #30 . Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/netmf/tutorials/usb-host.html": {
    "href": "software/netmf/tutorials/usb-host.html",
    "title": "USB Host",
    "keywords": "USB Host There is usually a lot of confusion between USB host and USB client. USB host is the system that connects to multiple USB clients. For example, the PC is a USB host and it can connect to multiple USB clients like mice, keyboards, and mass storage devices. Implementing a USB client is rather simple but implementing a host is far more complicated. USB host is an exclusive feature from GHI Electronics. With this feature, you can connect almost any USB device to GHI's NETMF products. This feature opens new possibilities for embedded systems. Your product can now connect to a standard USB keyboard and can also access files on a USB thumb drive. USB is a hot pluggable system which means any device can be connected or disconnected at any time. Events are generated when devices are connected or disconnected. The program that you write should subscribe to these events and handle them accordingly. With USB hub support, devices can be connected directly to the USB host port or the user may connect multiple USB devices through a USB hub. Getting Started When working with USB host, you interact with the Controller. You subscribe to the connected event for various devices and then start the controller. When a device connected, you receive an object representing that device as the event arguments. You can subscribe to the Disconnect event on that device to do any clean up you might need. The below code requires the GHI.Usb and GHI.Hardware assemblies and shows you briefly how to handle device connections and disconnections. using GHI.Usb.Host; using Microsoft.SPOT; using System.Threading; public class Program { public static void Main() { Controller.DeviceConnectFailed += Controller_DeviceConnectFailed; Controller.KeyboardConnected += Controller_KeyboardConnected; Controller.Start(); Thread.Sleep(-1); } private static void Controller_DeviceConnectFailed(object sender, EventArgs e) { Debug.Print(\"Failed.\"); } private static void Controller_KeyboardConnected(object sender, Keyboard keyboard) { Debug.Print(\"Keyboard connected.\"); keyboard.Disconnected += keyboard_Disconnected; } private static void keyboard_Disconnected(BaseDevice sender, EventArgs e) { Debug.Print(\"Keyboard disconnected.\"); } } Mice, keyboards, and joysticks Once you receive a connect event and the associated object for a mouse, keyboard, or joystick, you can subscribe to various events on those objects to receive data from the device. The below code simply prints out when a button or key is pressed. using GHI.Usb.Host; using Microsoft.SPOT; using System.Threading; public class Program { public static void Main() { Controller.KeyboardConnected += Controller_KeyboardConnected; Controller.MouseConnected += Controller_MouseConnected; Controller.JoystickConnected += Controller_JoystickConnected; Controller.Start(); Thread.Sleep(-1); } private static void Controller_KeyboardConnected(object sender, Keyboard keyboard) { Debug.Print(\"Keyboard connected.\"); keyboard.KeyUp += keyboard_KeyUp; keyboard.KeyDown += keyboard_KeyDown; } private static void Controller_MouseConnected(object sender, Mouse mouse) { Debug.Print(\"Mouse connected.\"); mouse.ButtonChanged += mouse_ButtonChanged; mouse.CursorMoved += mouse_CursorMoved; mouse.WheelMoved += mouse_WheelMoved; } private static void Controller_JoystickConnected(object sender, Joystick joystick) { Debug.Print(\"Joystick connected.\"); joystick.ButtonChanged += joystick_ButtonChanged; joystick.CursorMoved += joystick_CursorMoved; joystick.HatSwitchPressed += joystick_HatSwitchPressed; } private static void keyboard_KeyUp(Keyboard sender, Keyboard.KeyboardEventArgs e) { Debug.Print(\"Up: \" + e.Which.ToString()); } private static void keyboard_KeyDown(Keyboard sender, Keyboard.KeyboardEventArgs e) { Debug.Print(\"Down: \" + e.Which.ToString()); } private static void mouse_ButtonChanged(Mouse sender, Mouse.ButtonChangedEventArgs e) { Debug.Print(e.State.ToString() + \" \" + e.Which); } private static void mouse_CursorMoved(Mouse sender, Mouse.CursorMovedEventArgs e) { Debug.Print(e.Delta.ToString() + \" \" + e.NewPosition.ToString()); } private static void mouse_WheelMoved(Mouse sender, Mouse.WheelMovedEventArgs e) { Debug.Print(e.Delta.ToString() + \" \" + e.NewPosition.ToString()); } private static void joystick_ButtonChanged(Joystick sender, Joystick.ButtonChangedEventArgs e) { Debug.Print(e.State.ToString() + \" \" + e.Which); } private static void joystick_CursorMoved(Joystick sender, Joystick.CursorMovedEventArgs e) { Debug.Print(e.Delta.ToString() + \" \" + e.NewPosition.ToString() + \" \" + e.Which.ToString()); } private static void joystick_HatSwitchPressed(Joystick sender, Joystick.HatSwitchPressedEventArgs e) { Debug.Print(e.Direction.ToString()); } } Serial Serial (UART) communication is a very common interface. There are many companies that create chips that convert USB to serial. GHI currently supports chipsets from FTDI. Their FT232 is known to work, though others may as well. USB chipsets are made to be somewhat customized. A company can use an FTDI chip to make their product run on USB and they will change the strings in USB descriptors so that when you plug in their device to a PC you will see the company name and not FTDI. They can also change the USB VID/PID, vendor ID and product ID. Many of the interface products on the market use the FTDI chipset. A few other USB-Serial manufacturers, like Prolific, are included, but they are deprecated and not supported by us. The below example simply echoes any data received back out to the sender and prints it to the debug output. using GHI.Usb.Host; using Microsoft.SPOT; using System.Threading; public class Program { public static void Main() { Controller.UsbSerialConnected += Controller_UsbSerialConnected; Controller.Start(); Thread.Sleep(-1); } private static void Controller_UsbSerialConnected(object sender, UsbSerial usbSerial) { Debug.Print(\"UsbSerial connected.\"); usbSerial.DataReceived += usbSerial_DataReceived; } private static void usbSerial_DataReceived(UsbSerial sender, UsbSerial.DataReceivedEventArgs e) { for (int i = 0; i < e.Data.Length; i++) Debug.Print(e.Data[i].ToString()); sender.Write(e.Data); } } Mass Storage When you connect a mass storage device, it can be accessed through the regular NETMF filesystem functions with the device root \"USB\". Once you mount the device, you need to wait for NETMF to fire the RemovableMedia.Insert event before you try accessing the filesystem. The below code simply opens or creates a file on the drive, writes \"Hello, World!\" to it, and then unmounts the device. It requires the Microsoft.SPOT.IO and System.IO assembly. using GHI.Usb.Host; using Microsoft.SPOT; using Microsoft.SPOT.IO; using System.IO; using System.Text; using System.Threading; public class Program { private static AutoResetEvent evt = new AutoResetEvent(false); public static void Main() { Controller.MassStorageConnected += Controller_MassStorageConnected; Controller.Start(); Thread.Sleep(-1); } private static void Controller_MassStorageConnected(object sender, MassStorage massStorage) { RemovableMedia.Insert += RemovableMedia_Insert; massStorage.Mount(); evt.WaitOne(); using (var fs = new FileStream(\"\\\\USB\\\\Hello.txt\", FileMode.OpenOrCreate)) fs.Write(Encoding.UTF8.GetBytes(\"Hello, World!\"), 0, 13); massStorage.Unmount(); } private static void RemovableMedia_Insert(object sender, MediaEventArgs e) { Debug.Print(\"Inserted.\"); evt.Set(); } } Warning Under current versions of NETMF, the Flush method of FileStream will eventually write the buffers; unfortunately, there is a delay (sometimes up to a minute) from when Flush is called to when the data is actually flushed. See Files and Folders for more details. Webcams You can also connect a webcam and stream images from it. Webcams only support certain image formats and sizes so you need to query the formats supported and tell the camera to stream images using that format. We support cameras that support the YUV2 color format. The below code requires the Microsoft.SPOT.Graphics and Microsoft.SPOT.TinyCore assemblies. It looks for a format that has a size of 320x240 and starts to stream it. When a new image is available an event is raised and we draw the received image to the bitmap that represents our screen and then flush it. Make sure you have a display properly configured. using GHI.Usb.Host; using Microsoft.SPOT; using Microsoft.SPOT.Presentation; using System.Threading; public class Program { private static Bitmap lcd = new Bitmap(SystemMetrics.ScreenWidth, SystemMetrics.ScreenHeight); public static void Main() { Controller.WebcamConnected += Controller_WebcamConnected; Controller.Start(); Thread.Sleep(-1); } private static void Controller_WebcamConnected(object sender, Webcam webcam) { webcam.ImageAvailable += webcam_ImageAvailable; foreach (Webcam.ImageFormat i in webcam.SupportedFormats) { if (i.Width == 320 && i.Height == 240) { webcam.StartStreaming(i); break; } } } private static void webcam_ImageAvailable(Webcam sender, EventArgs e) { sender.GetImage(lcd); lcd.Flush(); } } Unknown Devices If your device is not recognized by our libraries, the UnknownDeviceConnected event will be triggered. This event will give you the USB parameters of the device that you can use to \"force\" the creation of a specific type. This method is not guaranteed to work with every unknown device, however. The below code illustrates how to do this with a usb to serial device. using GHI.Usb.Host; using Microsoft.SPOT; using System.Threading; public class Program { private static UsbSerial serial; public static void Main() { Controller.UnknownDeviceConnected += Controller_UnknownDeviceConnected; Controller.Start(); Thread.Sleep(-1); } private static void Controller_UnknownDeviceConnected(object sender, Controller.UnknownDeviceConnectedEventArgs e) { Debug.Print(\"Unknown device connected.\"); serial = new UsbSerial(e.Id, e.InterfaceIndex, e.VendorId, e.ProductId, e.PortNumber, BaseDevice.DeviceType.SerialProlific); serial.DataReceived += serial_DataReceived; } private static void serial_DataReceived(UsbSerial sender, UsbSerial.DataReceivedEventArgs e) { for (int i = 0; i < e.Data.Length; i++) Debug.Print(e.Data[i].ToString()); sender.Write(e.Data); } }"
  },
  "software/netmf/tutorials/usb-client.html": {
    "href": "software/netmf/tutorials/usb-client.html",
    "title": "USB Client",
    "keywords": "USB Client By default, all of GHI's NETMF devices use USB for deploying and debugging. You may optionally use the USB client (not the host) for something other than debugging. This is actually supported by NETMF and GHI adds more functionality making it even easier to use. Say you are making a device that that reads temperature and humidity and logs all of this data on an SD card. This device can be configured to set the time or give file names and you want this configuration to happen over USB, perhaps in the field. So when your device plugs into a USB port, you want it to show as a virtual serial port. This way, anyone can open a terminal software (like TeraTerm) to connect to your device and configure it. Using the USB client, there is no need to add the extra cost of additional RS232 serial ports or USB<->serial chipsets. The built-in USB client port can be configured to act as a CDC device, a virtual COM port. However, you still need to connect the PC to your device for debugging and deploying applications. Since the USB client port is used by your end application, you need to debug and deploy using a serial connection. You only need the serial interface in the development and deployment stage. Setting Up Debugging and deploying serially is specific to each device so you may want to consult your device's manual or Developers' Guide. Once the device is configured for the serial interface, remember to select the proper transport in Visual Studio. Tip The examples shown below require the Microsoft.SPOT.Hardware.Usb and GHI.Usb assemblies. Mouse The following example tells your device to act as a mouse and send random commands to your computer. You could use this to prank others and send their computer fake mouse commands or to have a second mouse for your own computer. using System; using System.Threading; using GHI.Usb; using GHI.Usb.Client; using Microsoft.SPOT; using Microsoft.SPOT.Hardware.UsbClient; public class Program { public static void Main() { // Start Mouse Mouse mouse = new Mouse(); Controller.ActiveDevice = mouse; // Move pointer in a swirl const int ANGLE_STEP_SIZE = 15; const int MIN_CIRCLE_DIAMETER = 50; const int MAX_CIRCLE_DIAMETER = 200; const int CIRCLE_DIAMETER_STEP_SIZE = 1; int diameter = MIN_CIRCLE_DIAMETER; int diameterIncrease = CIRCLE_DIAMETER_STEP_SIZE; int angle = 0; int factor; Random rnd = new Random(); int i = 0; while (true) { // we want to do it every sometime randomely i = rnd.Next(5000) + 5000;//between 5 and 10 seconds Debug.Print(\"Delaying for \" + i + \" ms\"); Thread.Sleep(i); i = rnd.Next(200) + 100;//do it for a short time Debug.Print(\"Looping \" + i + \" times!\"); while (i-- > 0) { // Check if connected to PC if (Controller.State == UsbController.PortState.Running) { // Note Mouse X, Y are reported as change in position // (relative position, not absolute) factor = diameter * ANGLE_STEP_SIZE * (int)System.Math.PI / 180 / 2; int dx = (-1 * factor * (int)Microsoft.SPOT.Math.Sin(angle) / 1000); int dy = (factor * (int)Microsoft.SPOT.Math.Cos(angle) / 1000); angle += ANGLE_STEP_SIZE; diameter += diameterIncrease; if (diameter >= MAX_CIRCLE_DIAMETER || diameter <= MIN_CIRCLE_DIAMETER ) diameterIncrease *= -1; // report mouse position mouse.SendRawData(dx, dy, 0,Buttons.None); } Thread.Sleep(10); } } } } Keyboard Emulating a keyboard is as very similar to emulating a mouse. The following example will create a USB Keyboard and send \"Hello world!\" to a computer every second. using System.Threading; using GHI.Usb; using GHI.Usb.Client; using Microsoft.SPOT; using Microsoft.SPOT.Hardware.UsbClient; public class Program { public static void Main() { // Start keyboard Keyboard kb = new Keyboard(); Controller.ActiveDevice = kb; Debug.Print(\"Waiting to connect to PC...\"); // Send \"Hello world!\" every second while (true) { // Check if connected to PC if ( Controller.State == UsbController.PortState.Running) { // We need shift down for capital \"H\" kb.Press(Key.LeftShift); kb.Stroke(Key.H); kb.Release(Key.LeftShift); // Now \"ello world\" kb.Stroke(Key.E); kb.Stroke(Key.L); kb.Stroke(Key.L); kb.Stroke(Key.O); kb.Stroke(Key.Space); kb.Stroke(Key.W); kb.Stroke(Key.O); kb.Stroke(Key.R); kb.Stroke(Key.L); kb.Stroke(Key.D); // The \"!\" kb.Press(Key.LeftShift); kb.Stroke(Key.D1); kb.Release(Key.LeftShift); // Send an enter key kb.Stroke(Key.Enter); } Thread.Sleep(1000); } } } CDC - Virtual Serial Port Serial ports are the most common interface, especially in the embedded system world. It is an ideal solution for devices to transfer data between computers and embedded devices NETMF products. To combine the popularity and usefulness of USB with the ease of serial, we have virtual USB devices. To Windows' applications or devices, a virtual serial port works just like a serial port but it is actually a USB port. To use CDC, you need the USB Drivers that come with the GHI Electronics NETMF and Gadgeteer SDK (2016 R1 and later). This will only work if you use the default constructor of the Cdc class. If you do not and you provide different Vendor and Product Ids, this driver will not work and you will need to create your own. You can use the one we provide in the SDK as a model, though it will not be signed. Note: CDC drivers usually handle one transaction in every frame. The max EP size on USB is 64 bytes and there 1000 frames per second on full-speed USB. This means that the maximum transfer rate in ideal conditions for CDC is 64KB/sec. The buffer size is limited so you must be make sure to read all data quickly because there is no overflow event. The following example will create a USB CDC and send \"Hello world!\" to computer every second. using System.Threading; using GHI.Usb; using GHI.Usb.Client; using Microsoft.SPOT; using Microsoft.SPOT.Hardware.UsbClient; public class Program { public static void Main() { // Start Cdc Cdc vsp = new Cdc(); Controller.ActiveDevice = vsp; // Send \"Hello world!\" to PC every second. (Append a new line too) byte[] bytes = System.Text.Encoding.UTF8.GetBytes(\"Hello world!\\r\\n\"); while (true) { // Check if connected to PC if (Controller.State != UsbController.PortState.Running) { Debug.Print(\"Waiting to connect to PC...\"); } else { vsp.Stream.Write(bytes, 0, bytes.Length); } Thread.Sleep(1000); } } } Mass Storage GHI's USB client supports Mass Storage Class (MSC). This allows access to connected media right from USB. For example, a data logger application that needs to save data to an SD card or USB memory. When the user is done collecting data, they can plug the USB data logger into the PC and now the PC can detect the device as a mass storage device. The user can then transfer the files using standard operating system controls. It may be helpful to think of the device as a memory card reader. We can even enhance our logger where the USB client interface can be CDC to configure the device and later dynamically switch to MSC to transfer files. Once very common question on GHI support is \"Why can't I access the media from my application while the media is also accessed externally (from windows)?\" Due to caching of file system data and/or the possibility of a write from one interface while the other is doing a read and/or a write, data on the media and/or data used by the interface will likely (and quickly) be corrupted. Note: you can easily switch back and forth between internal file system and USB MSC. This example code assumes an SD card is always plugged in. It enables MSC showing the device as a card reader. This code assumes that the USB port is NOT being used for debugging. In addition to the assemblies mentioned above in the Note, the following code requires the GHI.Hardware assembly. using System; using System.Threading; using GHI.Usb.Client; using GHI.Usb; using GHI.IO.Storage; public class Program { public static void Main() { // Start MS MassStorage ms = new MassStorage(); Controller.ActiveDevice = ms; // Assume SD card is connected SDCard sd; try { sd = new SDCard(); } catch { throw new Exception(\"SD card not detected\"); } ms.AttachLogicalUnit(sd,0, \" \", \" \"); // enable host access ms.EnableLogicalUnit(0); Thread.Sleep(Timeout.Infinite); } } HID and Custom Devices Windows and other operating systems have built in drivers for USB HID (Human Interface Devices). These drivers are ideal as they provide a simple way to transfer data between a computer and a device. HID's are usually mice and keyboards but they can also be simple data transfer devices. Although examples in codeshare may need changes for differences in SDK releases, this project provides a good example: http://www.ghielectronics.com/community/codeshare/entry/420 The GHI USB Client allows you to control the USB client in anyway you like. This feature requires advanced knowledge of USB. If you do not know what an EndPoint or a Pipe is then do not attempt to create custom devices. It is very important to have the device configured correctly the first time it is plugged into Windows since Windows stores a lot of information in its registry. If you change the configuration of your device after you had it plugged into Windows previously, Windows may not see the changes since it will be using the old configuration from its registry. Do not use USB Client Custom Devices unless you really have good reason to use them and you are knowledgeable in USB and Windows drivers."
  },
  "software/netmf/tutorials/can.html": {
    "href": "software/netmf/tutorials/can.html",
    "title": "CAN",
    "keywords": "CAN Controller Area Network (CAN) is a very common interface in industrial and automotive control. CAN is very robust and works very well in noisy environments at high speeds. All error checking and recovery methods are done automatically on the hardware. TD (Transmit Data) and RD (Receive Date) are the only two pins needed. There is no master/slave relationship in CAN. All nodes are equal and can both transmit and receive. CAN includes a protocal which easily allows for a node to claim a slice of time for its use so that collisions do not occur. You must have at least two nodes on the bus, however, or CAN will not work. There are many kinds of physical layers, but the most commonly used is a high-speed-dual wire that uses a twisted pair for noise immunity. This transceiver can run at up to 1 Mbit/s and can transfer data on very long wires if a low bit rate is used. Data can be transferred between nodes on the bus where any node can transfer at any time and all other nodes are required to successfully receive the data. All nodes must have a predefined bit timing criteria. This is much more complicated than calculating a simple baud rate for UART. For this reason, many CAN bit rate calculators are available which you can find using a simple internet search. We provide a few precalculated speeds that you can use but you can create more precise custom timings if you wish. There is an informative CAN guide in our downloads. The above image shows two CAN nodes connected over a bus with the 120 ohm resistors required on these transceivers. Tip Make sure to check the datasheet from the tranceiver. Most CAN controllers will divide the frequency by 2 before actually using it. Getting Started The code below sends a message over the CAN bus and prints out every message it receives to the debug window. It requires the GHI.Hardware assembly be added to the resources in your Visual Studio project. using GHI.IO; using Microsoft.SPOT; using System.Threading; public class Program { public static void Main() { var can = new ControllerAreaNetwork(ControllerAreaNetwork.Channel.One, ControllerAreaNetwork.Speed.Kbps1000); can.ErrorReceived += can_ErrorReceived; can.MessageAvailable += can_MessageAvailable; can.Enabled = true; can.SendMessage(new ControllerAreaNetwork.Message() { Data = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 }, ArbitrationId = 0x12345678, Length = 8, IsRemoteTransmissionRequest = false, IsExtendedId = true }); Thread.Sleep(-1); } private static void can_MessageAvailable(ControllerAreaNetwork sender, ControllerAreaNetwork.MessageAvailableEventArgs e) { var received = sender.ReadMessage(); var data = string.Empty; for (int i = 0; i < received.Length; i++) data += \"0x\" + received.Data[i].ToString(\"x2\") + \" \"; Debug.Print(\" CAN Message \"); Debug.Print(\"-----------------\"); Debug.Print(\" ID: \" + received.ArbitrationId.ToString()); Debug.Print(\" Time: \" + received.TimeStamp.ToString()); Debug.Print(\" RTR: \" + received.IsRemoteTransmissionRequest.ToString()); Debug.Print(\" EID: \" + received.IsExtendedId.ToString()); Debug.Print(\"Length: \" + received.Length.ToString()); Debug.Print(\" Data: \" + data); Debug.Print(\"\"); } private static void can_ErrorReceived(ControllerAreaNetwork sender, ControllerAreaNetwork.ErrorReceivedEventArgs e) { Debug.Print(\"Error on CAN: \" + e.Error.ToString()); } }"
  },
  "software/netmf/downloads.html": {
    "href": "software/netmf/downloads.html",
    "title": "NETMF Downloads",
    "keywords": "NETMF Downloads General Resources .NET Micro Framework for Beginners (ebook PDF) Gadgeteer mainboards and moudle driver Source code NETMF Open Source Ports Microsoft Visual Studio The lastest version of Visual Studio that works with NETMF is VS2013. The Community Version can be downloaded from the following link: Microsoft Visual Studio 2013 Community Edition Microsoft .NET Gadgeteer Core Microsoft .NET Gadgeteer Core GHI Electronics Product NETMF SDKs Tip Release notes are found within the SDKs. Date NETMF Core Rev SDK Jun 27, 2016 4.3 QFE2 GHI Electronics NETMF SDK 2016 R1 GHI Electronics NETMF SDK 2016 R1 zip Aug 31, 2015 4.3 QFE2 GHI Electronics NETMF SDK 2015 R1 Oct 29, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R5 Oct 8, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R4 Sep 15, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R3 Jul 31, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R2 Jan 29, 2014 4.3 RTM NETMF and Gadgeteer Package 2014 R1 Oct 23, 2013 4.3 RTM NETMF and Gadgeteer Package 2013 R3 Aug 27, 2013 4.3 RTM NETMF and Gadgeteer Package 2013 R2 Apr 30, 2013 4.3 RTM NETMF and Gadgeteer Package 2013 R1 Update 1 Feb 14, 2013 4.2 QFE2 NETMF and Gadgeteer Package 2013 R1 Feb 17, 2012 4.1 RTM NETMF 4.1 SDK, for Embedded Master, USBizi and ChipworkX (Includes IoT book for FEZ Panda)"
  },
  "hardware/ucm/uc5550.html": {
    "href": "hardware/ucm/uc5550.html",
    "title": "UC5550",
    "keywords": "UC5550 Overview The UC5550 System on Module has the processor and memory needed to run the most intense embedded applications, thanks to its 216 MHz Cortex-M7 and 32 MByte of RAM. Its built in native parallel TFT display makes it an ideal option for applications that require professional display support. Pricing, purchasing and other information can be found on the UC5550 Page on our main website. Tip Modules designed for the UCM standard have more functionality available when not following the rules set by the standard. It is up to you to decide how much your design will follow the UCM standard. Ordering Part Number Model Number WiFi Ethernet PHY External SDRAM External QSPI Flash UC5550-67HFN no no 32 MByte 4 MByte UC5550-67HFW yes no 32 MByte 4 MByte UC5550-67HFE no yes 32 MByte 4 MByte Specifications Spec UC5550 Processor ST STM32F767 32-bit ARM Cortex-M7 Speed 216 MHz Internal RAM 512 KByte (SRAM) Internal Flash 2 MByte External RAM 32 MByte (SDRAM) External Flash 4 MByte (QSPI) Dimensions 67.7 x 31.7 x 4.5 mm Note: Resources are shared between your application and the operating system. Peripherals This table lists the available peripherals. The \"overall\" column shows the available pins if the design did not follow the UCM standard. Peripheral UCM Standard Overall UART 4 5 (including HS) UART HS 1 2 I2C 1 2 SPI 2 3 CAN 2 2 SDIO 1 1 ADC 8 9 PWM 8 20 GPIO 12 103 IRQ 4 103 USB Client Supported Supported USB Host Supported Supported LCD Supported (16bpp & 24bpp) Supported (16bpp & 24bpp) Ethernet PHY Supported Supported WiFi Supported Supported Camera Supported Supported VBAT Supported Supported JTAG SWD SWD Tip The TinyCLR tutorials is a good resource on using these peripherals. Development Options The UCM development options can greatly simplify the process of building a product or prototype using the UC5550. Options include a development board and displays which can get you programming in minutes. Tip We are assuming you are using the UCM Development Board for all instructions provided. TinyCLR OS TinyCLR OS provides a way to program the UC5550 in C# or Visual Basic from the Microsoft Visual Studio integrated development environment. To get started you must first install the bootloader and firmware on the UC5550 (instructions below) and then go to the TinyCLR Getting Started page for instructions. Loading Bootloader v2 Download the UC5550 bootloader here . Connect your device to the USB client port. Put the board in DFU mode: Hold the SYS A pin low and press/release the reset button. Wait for a second then release SYS A. Windows Device Manager will now show \"STM Device in DFU Mode\" under the 'Universal Serial Bus controller' TAB. Go to the STM32 Bootloader to learn how to upload DFU files. Loading the Firmware Activate the bootloader, hold the LDR0 signal (SYS B) low while resetting the board. Open TinyCLR Config tool. Click the loader tab. Select the correct COM port. If you are not seeing it then the device is not in the loader mode. Click the Update to Latest button. You can also update the firmware manually. Download the firmware and learn how to use the GHI Bootloader manually. Start Coding Now that you have installed the bootloader and firmware on the UC5550, you can setup your host computer and start programming. Go to the TinyCLR Getting Started page for instructions. Code Samples For some examples of using TinyCLR, take a look at the TinyCLR Samples repo . You may also find the TinyCLR tutorials useful. Native Code You have the choice of loading the module with your preferred RTOS. Also, you can load Native Code in TinyCLR OS at runtime that works alongside your managed application. Native code can be used to provide improved performance or access to advanced features. The memory area reserved for native code in TinyCLR OS on UC5550 starts at 0xC1F00000 and its length is 0xFFFF8. WiFi Support The WiFi module is made by STMicroelectronics. this page has further details. Schematic The schematic for the UC5550 can be found here . Customization We also offer customized, non-stock versions of our SoMs. Many options are available, such as various sizes of external QSPI flash. Please contact us for details. We will always do our best to provide you with a module to fit your exact needs. Pin Assignments SO-DIMM Pin Universal Compute Standard Function Name 1 AGND AGND 2 Ethernet TX- ETH PHY TX- 3 Module Specific 1 (WiFi PIN14) WiFi Power LED 4 Ethernet TX+ ETH PHY TX+ 5 Analog VREF- Analog VREF- 6 Ethernet RX- ETH PHY RX- 7 Reserved 8 Ethernet RX+ ETH PHY RX+ 9 Reserved PH7, DCMI GP 10 Indicator A ETH PHY LED SPEED 11 Indicator B ETH PHY LED LINK 12 Reserved 13 GND GND 14 DCMI D0 PH9, DCMI D0 15 DCMI D1 PH10, DCMI D1 16 DCMI D2 PG10, DCMI D2 17 DCMI D3 PH12, DCMI D3 18 DCMI D4 PE4, DCMI D4 19 DCMI D5 PI4, DCMI D5 20 Analog 3.3V Analog 3.3V 21 DCMI D6 PE5, DCMI D6 22 DCMI D7 PE6, DCMI D7 23 DCMI VSYNC PG9, DCMI VSYNC 24 DCMI HSYNC PH8, DCMI HSYNC 25 DCMI PIXCLK PA6, DCMI PIXCLK 26 DCMI XCLK PA8, DCMI XCLK, MCO1 27 GND GND 28 PWM E PI6, TIM8 CH2 29 PWM F PI7, TIM8 CH3 30 PWM G PI2, TIM8 CH4 31 PWM H PA3, TIM9 CH2, ADC3 32 Analog VREF+ Analog VREF+ 33 Reserved 34 5V 35 Module Specific 4 (WiFi PIN13) 36 Module Specific 5 (WiFi PIN16) 37 Module Specific 6 (WiFi PIN22) 38 Module Specific 7 39 Module Specific 8 40 GND GND 41 GND GND 42 LCD 24bpp R0 PI15, LCD R0 43 LCD 24bpp R1 PJ0, LCD R1 44 LCD 24bpp R2 PJ1, LCD R2 45 LCD 24bpp G0 PJ7, LCD G0 46 3.3V 3.3V 47 LCD 24bpp G1 PJ8, LCD G1 48 LCD 24bpp B0 PJ12, LCD B0 49 LCD 24bpp B1 PJ13, LCD B1 50 LCD 24bpp B2 PJ14, LCD B2 51 GND GND 52 Module Specific 9 53 Reserved 54 Reserved 55 Reserved 56 5V 57 IRQ A PI8 58 IRQ B PI11 59 IRQ C PH14 60 3.3V 3.3V 61 IRQ D PH15 62 GPIO A PD7 63 GPIO B PE3 64 GPIO C PG3 65 GND GND 66 GPIO D PG6 67 GPIO E PG7 68 GPIO F PH4 69 GPIO G PI0 70 5V 71 Reserved 72 3.3V 3.3V 73 I2C B SDA 74 I2C B SCL 75 UART C TX PF7, UART7 TX 76 UART C RX PF6, UART7 RX 77 UART D TX (WiFi PIN9) PB10, USART3 TX, TIM2 CH3, I2C2 SCL 78 UART D RX (WiFi PIN7) PB11, USART3 RX, TIM2 CH4, I2C2 SDA 79 GND GND 80 Reserved 81 Reserved 82 Reserved 83 Reserved 84 Reserved 85 Reserved 86 5V 87 USB Device ID 88 3.3V 3.3V 89 UART B TX PC6, USART6 TX, TIM3 CH1 90 UART B RX PC7, USART6 RX, TIM3 CH2 91 ADC A PA0, ADC0, TIM5 CH1 92 GPIO H PA1, ETH RMII REF CLK 93 SPI B MISO (WiFi PIN6) PF8, SPI5 MISO, TIM13 CH1, UART7 RTS 94 SPI B MOSI (WiFi PIN8) PF9, SPI5 MOSI, TIM14 CH1, UART7 CTS 95 GND GND 96 SPI B SCK (WiFi PIN10) PH6, SPI5 SCK, TIM12 CH1 97 ADC B PA4, ADC4, DAC1 98 CAN A TD PH13, CAN1 TX 99 CAN A RD PI9, CAN1 RX 100 CAN B TD PB13, CAN2 TX 101 CAN B RD PB12, CAN2 RX 102 UART HS A TX PD5, USART2 TX 103 UART HS A RX PD6, USART2 RX 104 ADC C PA5, ADC5, DAC2 105 PWM A PA15, TIM2 CH1 106 3.3V 3.3V 107 SYS A BOOT0 108 Module Specific 2 (WiFi PIN2) 109 Module Specific 3 (WiFi PIN4) 110 ADC D PB0, ADC8, TIM3 CH3 111 SYS C PI1, LDR1 112 PWM B PB7, TIM4 CH2 113 GND GND 114 ADC E PB1, ADC9, TIM3 CH4 115 I2C A SDA PB9, I2C1 SDA, TIM4 CH4 116 I2C A SCL PB8, I2C1 SCL, TIM4 CH3 117 UART A RX PA10, USART1 RX 118 UART A TX PA9, USART1 TX 119 GPIO I PA2, ETH MDIO 120 UART HS A RTS PD4, USART2 RTS 121 UART HS A CTS PD3, USART2 CTS 122 GPIO J PA7, ETH RMII CRS DV 123 SD Card D0 PC8, SD D0 124 3.3V 3.3V 125 SD Card CMD PD2, SD CMD 126 SD Card CLK PC12, SD CLK, SPI3 MOSI 127 SD Card D1 PC9, SD D1 128 SD Card D2 PC10, SD D2, SPI3 SCK 129 SD Card D3 PC11, SD D3, SPI3 MISO 130 PWM C PH11, TIM5 CH2 131 GND GND 132 GPIO K PC4, ETH RMII RXD0 133 PWM D PI5, TIM8 CH1 134 SYS B PB2, LDR0 135 SYS D PI3, MODE 136 GPIO L PC5, ETH RMII RXD1 137 Module Specific 10 (ETH PHY OSCILLATOR PIN1) OE OFF# 138 UART HS B RTS 139 UART HS B CTS 140 UART HS B TX 141 UART HS B RX 142 3.3V 3.3V 143 LCD VSYNC PI13, LCD VSYNC 144 LCD HSYNC PI12, LCD HSYNC 145 LCD CLK PI14, LCD CLK 146 LCD DE PK7, LCD DE 147 Module Specific 11 148 SD Card CD PC13 149 Module Specific 12 150 Reserved 151 GND GND 152 LCD B3 PJ15, LCD B3 153 LCD B4 PK3, LCD B4 154 LCD B5 PK4, LCD B5 155 LCD B6 PK5, LCD B6 156 LCD B7 PK6, LCD B7 157 ADC F PC0, ADC10 158 ADC G PC2, ADC12 159 ADC H PC3, ADC13 160 3.3V 3.3V 161 LCD G2 PJ9, LCD G2 162 LCD G3 PJ10, LCD G3 163 LCD G4 PJ11, LCD G4 164 LCD G5 PK0, LCD G5 165 LCD G6 PK1, LCD G6 166 Module Specific 13 167 Indicator C (WiFi PIN15) WiFi Link Up LED 168 LCD R7 PJ6, LCD R7 169 GND GND 170 LCD G7 PK2, LCD G7 171 LCD R3 PJ2, LCD R3 172 LCD R4 PJ3, LCD R4 173 LCD R5 PJ4, LCD R5 174 LCD R6 PJ5, LCD R6 175 SPI A SCK PB3, SPI1 SCK 176 SPI A MISO PB4, SPI1 MISO 177 Module Specific 14 178 SPI A MOSI PB5, SPI1 MOSI 179 Module Specific 15 180 3.3V 3.3V 181 Module Specific 16 182 Module Specific 17 183 VBAT VBAT 184 Module Specific 18 185 GND GND 186 GND GND 187 RESET RESET 188 USB Host D+ PB15, USBH D+ 189 JTAG RTCK 190 USB Host D- PB14, USBH D- 191 JTAG TDO 192 3.3V 3.3V 193 JTAG NTRST 194 USB Device D+ PA12, USB D+ 195 JTAG TDI 196 USB Device D- PA11, USB D- 197 JTAG TCK (SWCLK) PA14, JTCK, SWCLK 198 GND GND 199 JTAG TMS (SWDIO) PA13, JTMS, SWDIO 200 Indicator D (WiFi PIN5) WiFi Running (Blink) LED CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a UC5550 driving the SN65HVD230 CAN transceiver chip. See the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 33.333K 1 12 2 108 1 False 86.7% 0.33% 2145M 83.333K 1 15 2 36 1 False 88.9% 0.28% 879M 125K 1 13 2 27 1 False 87.5% 0.31% 545M 250K 1 15 2 12 1 False 88.9% 0.28% 257M 500K 1 15 2 6 1 False 88.9% 0.28% 101M 1M 1 15 2 3 1 False 88.9% 0.28% 23M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested to ensure reliability. Legal License This product with its accompanying firmware are licensed royalty-free for commercial and noncommercial use. Using the provided firmware on a non-official product requires additional licensing. The provided documentation/schematics/libraries/sources are not to be used in any manner outside for the benefit of implementing and using this GHI Electronics product into your design. Disclaimer IN NO EVENT SHALL GHI ELECTRONICS, LLC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS PRODUCT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. GHI ELECTRONICS LINE OF PRODUCTS ARE NOT DESIGNED FOR LIFE SUPPORT APPLICATIONS. SPECIFICATIONS, PRICE AND AVAILABILITY ARE SUBJECT TO CHANGE WITHOUT ANY NOTICE. Want to quickly build your prototype? Check out the UCM Development Options . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/scm/g80.html": {
    "href": "hardware/scm/g80.html",
    "title": "G80",
    "keywords": "G80 Overview The G80 SoC is a low-cost System on Chip part of the GHI Electronics SurfaceMount Compute Modules (SCM) line. This modules can be programmed in .NET C# and Visual Basic using TinyCLR OS or .NET Micro Framework. Pricing, purchasing and other information can be found on the G80 Page on our main website. Ordering Part Number G80 SoC: G80SC-SM-501 G80 Dev Board: G80DB-SM-483 Specifications Spec Value Processor STM32F427VGT6 Speed 180 MHz Internal RAM 256 KByte (SRAM) Internal Flash 1 MByte Package LQFP100 14 x 14 mm Temperature Range -40C to +85C Note: Resources are shared between your application and the operating system. Peripherals TinyCLR OS ready .NET Micro Framework RoHS Lead Free 180 MHz ARM Cortex-M4 STM32F427VGT6 156 Kbytes available RAM 256 Kbytes available flash 78 GPIO 16 interrupt capable GPIO 2 SPI 1 I2C 4 UART 2 CAN 26 PWM 16 12-bit analog input 4-bit SD/MMC memory card interface Low power modes LQFP6100 14 x 14 mm RTC Watchdog Threading USB host USB client TCP/IP with SSL Full .NET socket interface Ethernet PPP Graphics Images Fonts Controls File System Full .NET file interface SD cards USB drives Native extensions Runtime Loadable Procedures Device register access Signal controls Generation Capture Pulse measurement G80 Pinout Many signals on the G80 are multiplexed to offer multiple functions on a single pin. Developers can decide on the pin functionality to be used through the provided libraries. Any pin with no name, function, or note must be left unconnected. Footprint The chip is standard LQFP100 14x14mm. See the STM32F427VGT6 datasheet for exact footprint. Device Startup The G80 is held in reset when the reset pin is low. Releasing it will begin the system startup process. There are three different components of the device firmware: GHI Bootloader: initializes the system, updates TinyCLR when needed, and executes TinyCLR. TinyCLR: loads, debugs, and executes the managed application. Managed application: the program developed by the customer. Which components get executed on startup can be control by manipulating the LDR0 pin. It is pulled high on startup. When low, the device waits in the GHI Bootloader. Otherwise, the managed application is executed. LDR1 is reserved for future use. Additionally, the communications interface between the host PC and the G80 is selected on startup through the MODE pin, which is pulled high on startup. The USB interface is selected when MODE is high and COM1 is selected when MODE is low. The above discussed functions of LDR0, LDR1, and MODE are only during startup. After startup, they return to the default GPIO state and are available to use as GPIO in the user application TinyCLR OS TinyCLR OS provides a way to program the G80 in C# or Visual Basic from the Microsoft Visual Studio integrated development environment. To get started you must first install the firmware on the G80 (instructions below) and then go to the TinyCLR Getting Started page for instructions. Loading the Firmware Activate the bootloader, hold the LDR0 signal low while resetting the board. Open TinyCLR Config tool. Click the loader tab. Select the correct COM port. If you are not seeing it then the device is not in the loader mode. Click the Update to Latest button. You can also update the firmware manually. Download the firmware and learn how to use the GHI Bootloader manually. Start Coding Now that you have installed the firmware on the G80, you can setup your host computer and start programming. Go to the TinyCLR Getting Started page for instructions. Code Samples For some examples of using TinyCLR, take a look at the TinyCLR Samples repo . You may also find the TinyCLR tutorials useful. Native Code TinyCLR OS also lets you use native code that works alongside your managed application. Native code can be used to provide improved performance or access to advanced features not exposed through TinyCLR. For more information check out Native Code on TinyCLR . The memory area reserved for native code in TinyCLR OS on G80 starts at 0x2002F000 and its length is 0xFF8. .NET Micro Framework It is possible to still use .NET Micro Framework (NETMF). Details are on the NETMF Introduction page. The NETMF Getting Started page covers NETMF from setup of the host computer to program deployment on both an emulator and target device. Datasheet This documentation page replaced the legacy datasheet PDF but it is here for reference. CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a G80 driving the TJA1050T CAN driver chip. See the Configuring the Bus section of the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 33.333K 1 12 2 90 1 False 86.7% 0.33% 2145M 83.333K 1 12 2 36 1 False 86.7% 0.33% 825M 125K 1 12 2 24 1 False 86.7% 0.33% 531M 250K 1 12 2 12 1 False 86.7% 0.33% 238M 500K 1 12 2 6 1 False 86.7% 0.33% 91M 1M 1 12 2 3 1 False 86.7% 0.33% 18M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested to ensure reliability. Design Considerations Required Pins Exposing the following pins is required in every design to enable device programming, updates, and recovery: LDR0 LDR1 Reset Desired debug interface(s) MODE if required to select a debug interface Power Supply A typical clean power source, suited for digital circuitry, is needed to power the G80. Voltages should be within at least 10% of the needed voltage. Decoupling capacitors of 0.1 Î¼F are needed near every power pin. Additionally, a large capacitor, typically 47 Î¼F, should be near the G80 if the power supply is more than few inches away. Crystals The G80 requires an external 12 MHz crystal and associated circuitry to function. For the RTC to function, a 32,768 Hz crystal and circuitry are required. Please see the processorâs documentation for advanced information. Interrupt Pins Interrupts are only available on 16 pins at any given time. Of those 16 pins, the pin number must be unique. For example: PA1 and PB1 cannot both be used as interrupts at the same time, but PA1 and PB2 can. Reset The reset pin is not pulled in any direction. Designs must be sure to use an appropriate pull-up resistor. G80 Development Board The G80 Dev Board is an excellent starting point and reference design for anyone interested in evaluating and developing with the G80. Schematics TinyCLR Samples repo Legal License This product with its accompanying firmware are licensed royalty-free for commercial and noncommercial use. Using the provided firmware on a non-official product requires additional licensing. The provided documentation/schematics/libraries/sources are not to be used in any manner outside for the benefit of implementing and using this GHI Electronics product into your design. Disclaimer IN NO EVENT SHALL GHI ELECTRONICS, LLC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS PRODUCT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. GHI ELECTRONICS LINE OF PRODUCTS ARE NOT DESIGNED FOR LIFE SUPPORT APPLICATIONS. SPECIFICATIONS, PRICE AND AVAILABILITY ARE SUBJECT TO CHANGE WITHOUT ANY NOTICE. You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/scm/g400s.html": {
    "href": "hardware/scm/g400s.html",
    "title": "G400S",
    "keywords": "G400S Overview The G400S System on Module (SoM) is the surface mount version of the G400D. Originally designed for .NET Micro Framework, it now runs several other platforms including TinyCLR. Pricing, purchasing and other information can be found on the G400S Page on our main website. Ordering Part Number G400S SoM: G400S-SM-480 Specifications Spec Value Processor Atmel AT91SAM9X35 ARM 926 Speed 400 MHz Internal RAM 32 KByte (SRAM) Internal Flash 0 KByte External RAM 128 MByte (DDR2 SDRAM) External Flash 4 MByte (SPI) Dimensions 48.3 x 33.1 x 4.6 mm Temperature Range -40 C to +85 C Note: Not all memory will be available for your application. Peripherals Note: Many peripherals share I/O pins. Not all peripherals will be available to your application. TinyCLR OS ready .NET Micro Framework RoHS Lead Free 400 MHz ARM 9 Atmel SAM9X35 64 Mbytes available RAM 1.4 Mbytes available flash Embedded LCD controller 89 interrupt capable GPIO 2 SPI 1 I2C 6 UART 2 CAN 4 PWM 12 10-bit analog output 4-bit SD/MMC memory card interface Low power modes RTC Watchdog Threading USB host USB client SQLite database TCP/IP with SSL Full .NET socket interface Ethernet PPP Graphics Images Fonts Controls File System Full .NET file interface SD cards USB drives Native extensions Runtime Loadable Procedures Device register access Signal controls Generation Capture Pulse measurement G400S Pinout Many signals on the G400 are multiplexed to offer multiple functions on a single pin. Developers can decide on the pin functionality to be used through the provided libraries. Any pin with no name, function, or note must be left unconnected. Footprint G400S Recommended Footprint Device Startup The G400 is held in reset when the reset pin is low. Releasing it will begin the system startup process. It is pulled high internally There are four different components of the device firmware: GHI Bootloader: initializes the system, updates TinyBooter when needed, and executes TinyBooter. TinyBooter: executes TinyCLR, updates TinyCLR when needed, and updates the system configuration. TinyCLR: loads, debugs, and executes the managed application. Managed application: the program developed by the customer. Which components get executed on startup can be control by manipulating the LDR0 and LDR1 pins. LDR0 and LDR1 are pulled high on startup. LDRO LDR1 Effect Ignored High Execute the managed application High Low Wait in TinyBooter Low Low Wait in GHI Bootloader Additionally, the communications interface between the host PC and the G400 is selected on startup through the MODE pin, which is pulled high on startup. The USB interface is selected when MODE is high and COM1 is selected when MODE is low. The above discussed functions of LDR0, LDR1, and MODE are only during startup. After startup, they return to the default GPIO state and are available to use as GPIO in the user application. .NET Micro Framework (NETMF) The NETMF software on G400 is mature and complete. For more information on NETMF you can go to the NETMF Introduction page. The NETMF Getting Started page covers NETMF from setup of the host computer to program deployment on both an emulator and target device. Bootloader v1 is needed for G400 to work with NETMF. It is available in the NETMF SDK. TinyCLR OS TinyCLR OS provides a way to program the G400 in C# or Visual Basic from the Microsoft Visual Studio integrated development environment. To get started you must first install the bootloader and TinyCLR OS firmware (instructions below) and then go to the TinyCLR Getting Started page for instructions. Loading Bootloader Version 2 Download the G400 bootloader v2 file and load onto the dataflash. The SAM-BA Bootloader has the details. Loading the Firmware Activate the bootloader, hold the LDR0 signal (pin 101) low while resetting the board. Open TinyCLR Config tool. Click the loader tab. Select the correct COM port. If you are not seeing it then the device is not in the loader mode. Click the Update to Latest button. You can also update the firmware manually. Download the firmware and learn how to use the GHI Bootloader manually. Start Coding Now that you have installed the bootloader and firmware, you can setup your host computer and start programming. Go to the TinyCLR Getting Started page for instructions. Code Samples For some examples of using TinyCLR, take a look at the TinyCLR Samples repo . You may also find the TinyCLR tutorials useful. Native Code TinyCLR OS also lets you use native code that works alongside your managed application. Native code can be used to provide improved performance or access to advanced features not exposed through TinyCLR. For more information check out Native Code on TinyCLR . The memory area reserved for native code in TinyCLR OS on G400S starts at 0x26700000 and its length is 0x16FFFF8. Datasheet This documentation page replaced the legacy datasheet PDF but it is here for reference. CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a G400 driving the SN65HVD230 CAN driver chip. See the Configuring the Bus section of the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 83.333K 7 4 1 99 0 False 87.5% 0.31% 845M 125K 7 1 1 81 0 False 84.6% 0.38% 499M 250K 7 1 1 40 0 False 84.6% 0.38% 222M 500K 7 7 1 13 1 False 89.5% 0.41% 92M 1M 7 7 1 6 1 False 89.5% 0.41% 19M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested to ensure reliability. Design Considerations Required Pins Exposing the following pins is required in every design to enable device programming, updates, and recovery: LDR0 LDR1 Reset Desired debug interface(s) MODE if required to select a debug interface SPI1 MISO to update TinyBooter in SDK 2015 R1 and earlier and to install the GHI Bootloader once for SDK 2016 R1 and later Power Supply A typical clean power source, suited for digital circuitry, is needed to power the G400. Voltages should be within at least 10% of the needed voltage. Decoupling capacitors of 0.1 Î¼F are needed near every power pin. Additionally, a large capacitor, typically 47 Î¼F, should be near the G400 if the power supply is more than few inches away. Additionally, the G400 requires additional voltages beyond the typical 3.3 V to function properly. See the pinout table for details. Crystals The G400 includes the needed system and RTC crystals and their associated circuitry. SPI Channels SPI1 is shared internally with the flash memory on the G400. Use of a chip select with devices on this channel is required or the G400 will not function properly. The use of another SPI channel is recommended. Ethernet The built in Ethernet available on the G400D includes all needed Ethernet circuitry internally. However, an appropriate magnet and connector, like the J0011D or similar, are required. Soldering the G400S The G400S is designed to be easily machine-placed or hand-soldered. Static sensitive precautions should be taken when handling the module. Oven Reflow The G400S is not sealed for moisture. Baking the module before reflow is recommended and required in a humid environment. The process of reflow can damage the G400 if the temperature is too high or exposure is too long. The lead-free reflow profile used by GHI Electronics is shown below. The profiles shown are based on SAC 305 solder (3% silver, 0.5% copper). The thermal mass of the assembled board and the sensitivity of the components on it affect the total dwell time. Differences in the two profiles are where they reach their respective peak temperatures as well as the time above liquids (TAL). The shorter profile applies to smaller assemblies, whereas the longer profile applies to larger assemblies such as back-planes or high-density boards. The process window is described by the shaded area. These profiles are only starting-points and general guidance. The particulars of an oven and the assembly will determine the final process. Legal License This product with its accompanying firmware are licensed royalty-free for commercial and noncommercial use. Using the provided firmware on a non-official product requires additional licensing. The provided documentation/schematics/libraries/sources are not to be used in any manner outside for the benefit of implementing and using this GHI Electronics product into your design. Disclaimer IN NO EVENT SHALL GHI ELECTRONICS, LLC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS PRODUCT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. GHI ELECTRONICS LINE OF PRODUCTS ARE NOT DESIGNED FOR LIFE SUPPORT APPLICATIONS. SPECIFICATIONS, PRICE AND AVAILABILITY ARE SUBJECT TO CHANGE WITHOUT ANY NOTICE. You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/scm/emx.html": {
    "href": "hardware/scm/emx.html",
    "title": "EMX System on Module",
    "keywords": "EMX System on Module EMX is a NETMF (.NET Micro Framework) System on Module. To use with NETMF, follow the setup instructions . Resources User Manual EMX Dev Sys The development system used for evaluating the EMX SoM. Schematic"
  },
  "software/tinyclr/tutorials/spi.html": {
    "href": "software/tinyclr/tutorials/spi.html",
    "title": "SPI",
    "keywords": "SPI SPI uses three, sometimes four, wires for transferring data. The bus on SPI consists of a single master and one or more slaves. The master will send the clock signal to the slaves over the SCK pin. It will also send data over MOSI pin, while reading incoming data on the MISO pin. The SCK clock line is used to determine how fast the data is moved. If you know electronics, this is simply a shift register. The master selects which slave it will swap the data with using the SSEL (Slave SELect) pin, sometimes called CS (Chip Select). In its simplest terms, the master will swap data between itself and the slave. You cannot write data without reading data at the same time. However, often you want to write data and don't care about the incoming data. To do this you can use the Write method. Keep in mind that the Write method is also reading and discarding whatever the slave is sending. Tip Some SPI devices (slaves) can have more than one select-pin, like the VS1053 MP3 decoder chip that uses one select pin for data and other for commands. Both share the three data transfer pins (SCK, >MOSI, MISO). Tip SPI needs more wires than other similar buses but it can transfer data very quickly. A 50Mhz clock is possible on SPI, that is 50 million bits in one second. Tip Note that a board running TinyCLR OS is always an SPI master, not slave. using GHIElectronics.TinyCLR.Devices.Spi; using GHIElectronics.TinyCLR.Pins; class Program { private static void Main() { var settings = new SpiConnectionSettings() { ChipSelectType = SpiChipSelectType.Gpio, ChipSelectLine = FEZ.GpioPin.A0, Mode = SpiMode.Mode1, ClockFrequency = 4 * 1000 * 1000, //4Mhz DataBitLength = 8, }; var controller = SpiController.FromName(FEZ.SpiBus.Spi1); var device = controller.GetDevice(settings); device.Write(new byte[] { 1, 2 }); //Write something. device.TransferSequential(...); //This is good for reading registers. device.TransferFullDuplex(...); //This is the only one that truly represents how SPI works. } }"
  },
  "software/tinyclr/native/intro.html": {
    "href": "software/tinyclr/native/intro.html",
    "title": "Native Code on TinyCLR",
    "keywords": "Native Code on TinyCLR TinyCLR has a few different ways you can use native code. You may want to do this for performance reasons or to access advance features on your platform. The most commonly used option will be native interops that allow you to call native code from your managed application and interact with managed data from the native side. TinyCLR also allow access to native APIs where Interops can access to other services registered with the system like SPI, GPIO, and I2C."
  },
  "software/tinyclr/native/interops.html": {
    "href": "software/tinyclr/native/interops.html",
    "title": "Native Interops in TinyCLR",
    "keywords": "Native Interops in TinyCLR Interops allow you to write a class in managed code that is partially or entirely implemented in native code. This is useful for time critical tasks, things that would take too long in managed code, or interacting with native functionality not exposed through managed code. Keep in mind that while native code executes, all managed threads are blocked and if you crash in native code, managed code also crashes. To get started, create a TinyCLR project called InteropTest . In the project properties window, go to the TinyCLR OS tab. Check both the Generate native stubs for internal methods and the Generate bare native stubs checkboxes. Next, define your native API. Any method that you plan to implement in native code must be declared extern and be decorated with the System.Runtime.CompilerServices.MethodImpl attribute that is constructed with MethodImplOptions.InternalCall . Static and instance functions, static and instance constructors, finalizers, and property set and get bodies can all be implemented natively. They can have any visibility, can take any number or types of parameters, and can return any type. For example: class MyNativeClass { private int field = 5; [MethodImpl(MethodImplOptions.InternalCall)] public extern int MyNativeFunc(int arg0); public extern int MyNativeProperty { [MethodImpl(MethodImplOptions.InternalCall)] get; } } Once you have your native API defined, build your project. In the output folder, find and open pe and then Interop . In there are three files that let TinyCLR connect the managed methods to the native methods. There are two main files that have the same name as your project. These define the entire API. Importantly, there is an object that has the assembly name, its checksum, and an array of its methods. The remaining file contains function stubs for each native method you need to implement from the MyNativeClass class. Each function has a single parameter of type TinyCLR_Interop_MethodData that can be found in the TinyCLR.h file. This type has two memebers: an opaque stack type that you pass to other interop functions and the API provider that gives you access to the runtime. You can use this API provider to find the interop provider. The interop provider allows you to read and write object fields, read arguments passed to the function, write to reference arguments, set the return value, raise other events, and create new managed objects. The following code shows reading from a field and setting it as the return value of the property: TinyCLR_Result InteropTest_InteropTest_MyNativeClass::MyNativeFunc___I4__I4(const TinyCLR_Interop_MethodData md) { auto ip = md.InteropManager; TinyCLR_Interop_ClrValue arg; TinyCLR_Interop_ClrValue ret; ip->GetArgument(ip, 0, arg); ip->GetReturn(ip, md.Stack, ret); ret.Data.Numeric->I4 = arg.Data.Numeric->I4 * arg.Data.Numeric->I4; return TinyCLR_Result::Success; } TinyCLR_Result InteropTest_InteropTest_MyNativeClass::MyNativeProperty___I4(const TinyCLR_Interop_MethodData md) { auto ip = md.InteropManager; const TinyCLR_Interop_ClrObject* self; TinyCLR_Interop_ClrValue field; TinyCLR_Interop_ClrValue ret; ip->GetThisObject(ip, md.Stack, self); ip->GetField(ip, self, InteropTest_InteropTest_MyNativeClass::FIELD___field___I4, field); ip->GetReturn(ip, md.Stack, ret); ret.Data.Numeric->I4 = field.Data.Numeric->I4; return TinyCLR_Result::Success; } Now you need to compile these files. You can use free GCC compiler for example. Download and install GCC . The latest version we have tested is 7-2018-q2-update . Download and extract the latest TinyCLR OS Core Library . This is where you will find TinyLCR.h. To compile using GCC, the easiest way is to use a makefile and a scatterfile. We've provided samples of each below. The makefile is setup to compile all cpp in the same directory it is and to do using for a Cortex M4 architecture. If you're not on CortexM4, change the MCU_FLAGS parameter accordingly. The output file is InteropTest.bin . You can change that with the OUTPUT_NAME property. OUTPUT_NAME = InteropTest LINKERSCRIPT_NAME = scatterfile MCU_FLAGS = -mcpu=cortex-m4 -mthumb INC_DIRS = -I. CC = arm-none-eabi-g++.exe LD = arm-none-eabi-g++.exe OC = arm-none-eabi-objcopy.exe CC_FLAGS = $(INC_DIRS) $(MCU_FLAGS) -Os -std=c++11 -xc++ -Wall -Wabi -w -mabi=aapcs -fPIC -fno-exceptions -fno-rtti -fno-use-cxa-atexit -fno-threadsafe-statics LD_FLAGS = $(MCU_FLAGS) -nostartfiles -lc -lgcc -T $(LINKERSCRIPT_NAME) -Wl,-Map,$(OUTPUT_NAME).map -Wl,--oformat -Wl,elf32-littlearm OC_FLAGS = -S -O binary SRC_FILES = $(wildcard *.cpp) OBJ_FILES = $(patsubst %.cpp, %.obj, $(SRC_FILES)) rebuild: clean build clean: del $(OBJ_FILES) $(OUTPUT_NAME).bin $(OUTPUT_NAME).elf $(OUTPUT_NAME).map build: $(OBJ_FILES) $(LD) $(LD_FLAGS) -o $(OUTPUT_NAME).elf $^ $(OC) $(OC_FLAGS) $(OUTPUT_NAME).elf $(OUTPUT_NAME).bin %.obj: %.cpp $(CC) -c $(CC_FLAGS) -o $@ $^ You will need to adjust the file with the correct memory regions reserved for interops in the scatterfile by changing the INTEROP_BASE and INTEROP_LENGTH placeholders. You can find the interop region for your device, if it has one, in the device's documentation. MEMORY { SDRAM (wx) : ORIGIN = INTEROP_BASE, LENGTH = INTEROP_LENGTH } SECTIONS { . = ALIGN(4); .text : { *(.text) } .rodata ALIGN(4): { *(.rodata ) } .data ALIGN(4): { *(.data) } .bss ALIGN(4): { *(.bss) } } Lastly, make sure that you place TinyCLR.h in the folder so that the interop files can see it. You need to use the file that corresponds to the release of the firmware you are running. To execute the makefile, you'll need to have make installed. You can get it from a toolkit like MinGW or, if you're on Windows 10, the Windows Subsystem for Linux. Once you have make installed, just navigate to the folder with the makefile and interop files in a shell and execute make build . Tip If you use the Windows Subsystem for Linux, you'll need to change del in the makefile to rm . You can also build interops in Visual Studio. This is a 3-part step-by-step tutorial . Once you have a compiled image, look in the map file to find out where the interop definition variable Interop_InteropTest (if you're using the default names) got placed. You'll need to pass this address to the managed function that registers the interop. In managed code, add the compiled binary image as a resource and use the Marshal class to copy it into the correct location in memory. Then call System.Runtime.InteropServices.Interop.Add and pass it the address of the Interop_InteropTest object from the map file. You need to do this every time your program runs and before you call any of the native methods in your interop class. var interop = Resources.GetBytes(Resources.BinaryResources.InteropTest); Marshal.Copy(interop, 0, new IntPtr(0x20016000), interop.Length); Interop.Add(new IntPtr(0x2001607C)); var cls = new MyNativeClass(); var prop = cls.MyNativeProperty; var func = cls.MyNativeFunc(2);"
  },
  "software/tinyclr/intro.html": {
    "href": "software/tinyclr/intro.html",
    "title": "TinyCLR OS Introduction",
    "keywords": "TinyCLR OS Introduction TinyCLR OS started with Microsoft's .NET Micro Framework and continues to enable managed .NET development and debugging using Visual Studio on embedded devices. All you need to get started is Visual Studio (free version available), a TinyCLR device, and a USB cable. Getting Started Deploy your first TinyCLR program. Learn more... Tutorials Learn TinyCLR embedded programming. Learn more... Native Run native code on your device. Learn more... Release Notes Find the latest changes to TinyCLR. Learn more... Downloads Visual Studio and device downloads. Learn more... Roadmap The future of TinyCLR. Learn more... TinyCLR Config Our device configuration program. Learn more... To learn more about TinyCLR embedded programming check out our tutorials . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/tinyclr/getting-started.html": {
    "href": "software/tinyclr/getting-started.html",
    "title": "Getting Started",
    "keywords": "Getting Started This page explains how to set up the TinyCLR programming environment. It covers device and computer setup and deployment of a \"hello world\" program. Tip If you're an existing user of NETMF and still want to use it in addition to TinyCLR OS, don't worry. TinyCLR is completely independent of NETMF and works side-by-side with no issues. TinyCLR Device Setup To use TinyCLR with a device you must first install the latest versions of the GHI bootloader and TinyCLR firmware on the device. The bootloader is installed first and provides a way to install the firmware and to execute programs which are uploaded to the device. The TinyCLR firmware includes the Common Language Runtime (CLR) which converts compiled code into machine instructions and manages program execution. The TinyCLR firmware is also responsible for interacting with Microsoft Visual Studio to load and debug your application programs. Instructions for installing the bootloader and firmware are provided on the documentation page for each device. If you want to use your own device, visit our porting guide for information on how to get started. TinyCLR Computer Setup Download and Install Visual Studio and the TinyCLR Extension If you don't already have Visual Studio 2017, download and install the free version from here: Visual Studio Community 2017 . Make sure to select the .NET desktop development workload when installing Visual Studio. Download and install the newest TinyCLR Visual Studio Project System by going to Tools > Extensions and Updates... . In the Extensions and Updates dialog box select Online in the left panel. Type tinyclr into the Search text box in the upper right of the window to search for and install the TinyCLR OS Project System . You'll need to restart Visual Studio to let the extension installer complete the installation. You can also find the TinyCLR OS Project System on our Downloads page if you want to download the file and install it from your hard drive. Install the TinyCLR Nuget Packages Connect your device to your PC using a USB cable (make sure your device has the latest firmware installed). Start Visual Studio and create a new TinyCLR Application under C# > TinyCLR . New to Visual Studio or C#? Take a look at the getting started guide from Microsoft . Right click on your Project in the Solution Explorer panel and select Manage NuGet Packages . If the Solution Explorer window is not visible, open it by selecting Solution Explorer in the View menu. You can also select Manage NuGet Packages... in the Project menu of Visual Studio. Make sure the package source is set to \"Package source\" or \"All.\" In the search box type \"tinyclr\" Selecting the Browse tab will show all the TinyCLR NuGet packages. Those installed are noted with a green down arrow in front of the name. To install one of the packages click on the down arrow to the right of the package version. You can also select the package and click on the Install button in the center panel. Click OK to accept the proposed changes. Accept the licensing agreement to install the package. And, that's it! You're now ready to start programming using TinyCLR OS. Starting a New Project Let's make a \"hello world\" program and deploy it on the FEZ Cobra III. Open Visual Studio and select File > New > Project . There should be a TinyCLR option under Visual C# . Click on TinyCLR in the left panel, and TinyCLR Application in the center panel. Name the project and hit the OK button to create a new project. The project will have a single C# file named Program.cs whose contents are shown below. C# source files are listed in the Solution Explorer window. If the Solution Explorer window is not visible, click on View > Solution Explorer to open it. If you right click on the project name in the Solution Explorer window, a drop down menu will appear. Select Manage NuGet Packages... from the menu. Now you should see the installed TinyCLR NuGet library (GHIElectronics.TinyCLR.Core). This is the only library we will need for our \"hello world\" program. Close the NuGet... tab or click on the Program.cs tab to edit the source code. Change the contents as shown below. Make sure your device is plugged into the computer's USB port. Now hit the start button as shown on the above image (or hit the F5 key). If you've done everything correctly the program will compile and deploy to your device. The message \"Hello World!\" should appear in the output window as shown below. Congratulations! You're on your way to becoming a TinyCLR embedded developer! To learn more about TinyCLR embedded programming check out our tutorials . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/netmf/tutorials/timers.html": {
    "href": "software/netmf/tutorials/timers.html",
    "title": "Timers",
    "keywords": "Timers Introduction NETMF includes 2 timer classes, Timer and ExtendedTimes. Timer class is the same one included in full framework where ExtendedTimer is specific to NETMF with extra functionality. A timer example This example creates a timer that will run after five seconds and then it will keep firing every second. Note: the time parameters expect times in milliseconds. using System.Threading; using Microsoft.SPOT; public class Program { class OurClass { public int x; } static void RunMe(object o) { OurClass cls = (OurClass)o; Debug.Print(\"From timer!\"); Debug.Print(\"Value: \" + cls.x.ToString()); } public static void Main() { OurClass cls = new OurClass(); cls.x = 5; Timer MyTimer = new Timer(new TimerCallback(RunMe), cls, 5000, 1000); Debug.Print( \"The timer will fire in 5 seconds and then fire priodically every 1 second\"); Thread.Sleep(Timeout.Infinite); } }"
  },
  "software/netmf/tutorials/sqlite.html": {
    "href": "software/netmf/tutorials/sqlite.html",
    "title": "SQLite Database",
    "keywords": "SQLite Database Introduction According to the SQLite homepage, \"SQLite is a software library that implements a self-contained, serverless, zero-configuration, transactional SQL database engine. SQLite is the most widely deployed SQL database engine in the world\". GHI provides a driver for SQLite so that you can have access to a SQL database that resides entirely in a simple file on a persistant storage device. The below code is a simple example where a database file is created in RAM (using SD cards and USB drives is possible as well). A table is created that is filled with some initial rows and then this data is read from the database. This data is then iterated over and printed out. ColumnOriginNames returns the names of each of the columns. using System; using System.Collections; using Microsoft.SPOT; using GHI.SQLite; public class Program { public static void Main() { // Create a database in memory, // file system is possible however! Database myDatabase = new GHI.SQLite.Database(); myDatabase.ExecuteNonQuery(\"CREATE Table Temperature\" + \" (Room TEXT, Time INTEGER, Value DOUBLE)\"); //add rows to table myDatabase.ExecuteNonQuery(\"INSERT INTO Temperature (Room, Time, Value)\" + \" VALUES ('Kitchen', 010000, 4423)\"); myDatabase.ExecuteNonQuery(\"INSERT INTO Temperature (Room, Time, Value)\" + \" VALUES ('Living Room', 053000, 9300)\"); myDatabase.ExecuteNonQuery(\"INSERT INTO Temperature (Room, Time, Value)\" + \" VALUES ('bed room', 060701, 7200)\"); // Process SQL query and save returned records in SQLiteDataTable ResultSet result = myDatabase.ExecuteQuery(\"SELECT * FROM Temperature\"); // Get a copy of columns orign names example String[] origin_names = result.ColumnNames; // Get a copy of table data example ArrayList tabledata = result.Data; String fields = \"Fields: \"; for (int i = 0; i < result.RowCount; i++) { fields += result.ColumnNames[i] + \" |\"; } Debug.Print(fields); object obj; String row = \"\"; for (int j = 0; j < result.RowCount; j++) { row = j.ToString() + \" \"; for (int i = 0; i < result.ColumnCount; i++) { obj = result[j, i]; if (obj == null) row += \"N/A\"; else row += obj.ToString(); row += \" |\"; } Debug.Print(row); } myDatabase.Dispose(); } } The details on SQLite All details on SQLite are found at the offcial SQLite website http://www.sqlite.org/"
  },
  "software/netmf/tutorials/networking.html": {
    "href": "software/netmf/tutorials/networking.html",
    "title": "Networking",
    "keywords": "Networking Introduction Networks are an essential part of our everyday lives. Almost every home is connected to a network (the Internet) and most businesses can't function without an internal network (LAN or Wi-Fi) that is connected to an external network (the Internet). All these networks have a standard for communication: TCP/IP. There are actually a few protocols that handle different tasks in the network: DNS, DHCP, IP, ICMP, TCP, UDP, PPP, and others. In code, you create what is called a socket. A socket allows communication between your computer and one or more other endpoints (usually remote computers). Sockets can be TCP, UDP, and others. Socket support in NETMF is very similar to the full .NET Framework. Tip When working with networking, you may sometimes receive socket exceptions that look like \"10054\". NETMF uses the same error codes as WinSock on the desktop, so a quick search can tell you what that code means. For example,10054 means connection reset. Getting started with WiFi Since GHI Electronics's devices can provide multiple network interfaces (only one can be used at a time, however), you must initialize the interface you wish to use. To do so, you must create the interface object, open it, configure any network settings, and, in the case of WiFi, join a network. In the below example, you can see that we are using DHCP and dynamic DNS. This allows a lot of the configuration to be done automatically, depending on your network setup. (Static IP and static DNS also work.) Once you join a network and have been issued a valid IP Address, the network is ready to use. Make sure you enter your network key in the proper format. WPA/WPA2 keys are the literal string value while WEP keys are the hex digits without the leading 0x. The following code requires the GHI.Networking, Microsoft.SPOT.Hardware, and Microsoft.SPOT.Net assemblies. Make sure that you update the pins in the constructor to match your hardware setup. using GHI.Networking; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; using Microsoft.SPOT.Net.NetworkInformation; using System; using System.Net; using System.Threading; public class Program { private static WiFiRS9110 netif; public static void Main() { NetworkChange.NetworkAvailabilityChanged += NetworkChange_NetworkAvailabilityChanged; NetworkChange.NetworkAddressChanged += NetworkChange_NetworkAddressChanged; netif = new WiFiRS9110(SPI.SPI_module.SPI1, Cpu.Pin.GPIO_Pin1, Cpu.Pin.GPIO_Pin2, Cpu.Pin.GPIO_Pin3); netif.Open(); netif.EnableDhcp(); netif.EnableDynamicDns(); netif.Join(\"SSID\", \"Password\"); while (netif.IPAddress == \"0.0.0.0\") { Debug.Print(\"Waiting for DHCP\"); Thread.Sleep(250); } //The network is now ready to use. } private static void NetworkChange_NetworkAddressChanged(object sender, Microsoft.SPOT.EventArgs e) { Debug.Print(\"Network address changed\"); } private static void NetworkChange_NetworkAvailabilityChanged(object sender, NetworkAvailabilityEventArgs e) { Debug.Print(\"Network availability: \" + e.IsAvailable.ToString()); } } Wired Ethernet If you want to use a physical Ethernet connection, you can use our SPI based ENC28 or the built in Ethernet adapter. Initializing the network is similar to WiFi in either case, except you do not join a network as seen below. netif = new EthernetENC28J60(SPI.SPI_module.SPI1, Cpu.Pin.GPIO_Pin1, Cpu.Pin.GPIO_Pin2, Cpu.Pin.GPIO_Pin3); netif.Open(); netif.EnableDhcp(); netif.EnableDynamicDns(); while (netif.IPAddress == \"0.0.0.0\") { Debug.Print(\"Waiting for DHCP\"); Thread.Sleep(250); } //The network is now ready to use. netif = new EthernetBuiltIn(); netif.Open(); netif.EnableDhcp(); netif.EnableDynamicDns(); while (netif.IPAddress == \"0.0.0.0\") { Debug.Print(\"Waiting for DHCP\"); Thread.Sleep(250); } //The network is now ready to use. HTTP communication Once you configure a network interface, you probably want to start communicating over the network. One of the easiest ways to do this is through HTTP. After you have received an IP Address (as shown above), you can create an HTTP request to a URL and then receive its response. What you do with that data is up to you. Make sure the result buffer is larger enough to hold the response or process the data as you read it. byte[] result = new byte[65536]; int read = 0; using (var req = HttpWebRequest.Create(\"url to query\") as HttpWebRequest) { using (var res = req.GetResponse() as HttpWebResponse) { using (var stream = res.GetResponseStream()) { do { read = stream.Read(result, 0, result.Length); Thread.Sleep(20); } while (read != 0); } } } //The result array now contains the data received from the remote server. mIP For those who want greater control over the networking stack, there is the mIP C# library available at http://mip.codeplex.com/ It is a full networking stack allowing you to modify it to suit your needs, something not easily done with the built in stack. PPP You can use the provided PPP class to communicate with serial PPP devices such as cellular or regular modems that provide access to the internet. After you configure your device over a serial port (potentially using AT commands that differ for every device), you pass that port and any authentication parameters to our PPP class and then, once the PPP connection is established with the device, you can use the regular NETMF networking functionality to access the internet or your network. The below example shows the basic initialization, AT commands, and PPP commands needed to access the network using a SIM908 cellular modem. You must provide your own SIM card and correctly set the APN and COM port based on your setup. The code requires the GHI.Networking, Microsoft.SPOT.SerialPort, and Microsoft.SPOT.Net assemblies. Different AT commands will be needed for different modems. using GHI.Networking; using Microsoft.SPOT.Net.NetworkInformation; using System.IO.Ports; using System.Text; using System.Threading; public class Program { private static AutoResetEvent evt; private static void Main() { evt = new AutoResetEvent(false); NetworkChange.NetworkAvailabilityChanged += NetworkChange_NetworkAvailabilityChanged; using (var port = new SerialPort(\"YOUR COM PORT\", 115200, Parity.None, 8, StopBits.One)) { port.Open(); port.DiscardInBuffer(); port.DiscardOutBuffer(); SendATCommand(port, \"AT+CGDCONT=2,\\\"IP\\\",\\\"YOUR APN\\\"\"); SendATCommand(port, \"ATDT*99***2#\"); using (var netif = new PPPSerialModem(port)) { netif.Open(); netif.Connect(PPPSerialModem.AuthenticationType.Pap, \"\", \"\"); evt.WaitOne(); //The network is now ready to use. } } } private static void NetworkChange_NetworkAvailabilityChanged(object sender, NetworkAvailabilityEventArgs e) { if (e.IsAvailable) evt.Set(); } private static void SendATCommand(SerialPort port, string command) { var sendBuffer = Encoding.UTF8.GetBytes(command + \"\\r\"); var readBuffer = new byte[256]; var read = 0; port.Write(sendBuffer, 0, sendBuffer.Length); while (true) { read += port.Read(readBuffer, read, readBuffer.Length - read); var response = new string(Encoding.UTF8.GetChars(readBuffer, 0, read)); if (response.IndexOf(\"OK\") != -1 || response.IndexOf(\"CONNECT\") != -1) break; } } } SSL SSL allows you to secure the communications between your device and a remote server. Currently only SSL2, SSL3, and TLS1.0 are supported. Your NETMF device must have the proper time set for SSL to function. Unlike your PC, NETMF devices do not maintain a database of root certificates which are used to verify a remote server is who it says it is. As a result, you must manually include the root certificate for the site you are connecting to in your project. One easy way to accomplish this is to go to the site in your browser, click the padlock icon near the address bar, view the certificate, and then go to the Certification Path tab, click the top most (the root) certificate entry, view it, then under Details, copy it to a file, making sure to use base 64 encoding. Add that file as a resource to your project. Unfortunately, this will not always work. Some sites present different certificates based on who it detects it asking for them. Additionally, some certificates may be cross signed where there is another root you must use. You can try to search online for the actual root certificate or use Wireshark or a similar program. To use Wireshark, capture the traffic from the device when you try to connect to the desired site. It should fail since you do not have the correct certificate. Early in the conversation, after the \"Server Hello\" packet, find a \"Certificate\" packet. Under the SSL > Handshake Protocol > Certificates, find the very last entry. Make sure it is its own issuer. If not, you must use the issuer as the root certificate. For example, when connecting to https://www.google.com/ , the very last certificate is GeoTrust Global CA. In the browser, it is issued by itself. In Wireshark from our device however, it is actually issued by Equifax Secure Certificate Authority. Once you have added it to your project, you can use the below code to communicate with that site: just pass in the URL you want to download and the root certificate. It requires the Microsoft.SPOT.Native and System.Http assemblies. When connecting to different sites, make sure to repeat the same process and get their root certificate as well. You are also required to update the SSL seed using MFDeploy or FEZ Config any time you update the firmware. void DownloadOverSsl(string url, byte[] certificate) { using (var request = HttpWebRequest.Create(url) as HttpWebRequest) { request.HttpsAuthentCerts = new X509Certificate[] { new X509Certificate(certificate) }; request.KeepAlive = false; using (var response = request.GetResponse()) { using (var stream = response.GetResponseStream()) { var result = string.Empty; var buffer = new byte[4096]; var read = 0; stream.ReadTimeout = 5000; for (var left = response.ContentLength; left > 0; ) { Thread.Sleep(1000); try { read = stream.Read(buffer, 0, buffer.Length); } catch { continue; } left -= read; result += new string(Encoding.UTF8.GetChars(buffer, 0, read)); } Debug.Print(result); } } } } If you do not want to use the HTTP classes, you can use a raw socket. After you have called Connect on the desired socket, pass it to the constructor of SslStream found in System.Net.Security. You then have to call AuthenticateAsClient on it. The first parameter is the common name. Often that is the host portion of the URL, such as \"www.ghielectronics.com\", but it is not always. To find the common name of the site, look at the \"Issued To\" field on the certificate details window. The next parameter is null, followed by an X509Certificate array containing the root certificate. The last two parameters need to be SslVerification.CertificateRequired and SslProtocols.Default. Once that call completes, you can read and write to that stream. Calls to Read will not always succeed, especially if called in rapid succession. You should wait a bit between calls. Waits up to 1 second can be expected depending on your exact network characteristics. We recommend testing different lengths and calibrating the wait for your needs."
  },
  "software/netmf/tutorials/intro.html": {
    "href": "software/netmf/tutorials/intro.html",
    "title": ".NET Micro Framework Tutorials",
    "keywords": ".NET Micro Framework Tutorials Topics Analog Inputs Analog Outputs CAN Digital Inputs Digital Outputs Files Firmware Update Graphics I2C In-Field Update Networking PWM Pulse Feedback Real Time Clock (RTC) Register Access RLP Signal Capture Signal Generator SPI SQLite Timers Touch UART USB Client USB Host Watchdog XML XTEA What is .NET Micro Framework? If you are new to NETMF you might want to take a look at our free e-book .NET Micro Framework for Beginners"
  },
  "hardware/ucm/uc2550.html": {
    "href": "hardware/ucm/uc2550.html",
    "title": "UC2550",
    "keywords": "UC2550 Overview The efficiency of our UC2550 makes it ideal for low power applications. It is also our lowest cost UCM and offers a large complement of peripherals. Pricing, purchasing and other information can be found on the UC2550 Page on our main website Tip Modules designed for the UCM standard have more functionality available when not following the rules set by the standard. It is up to you to decide how much your design will follow the UCM standard. Ordering Part Number Model Number WiFi External QSPI Flash UC2550-13NNN no optional UC2550-13NNW yes optional Specifications Specs Value Processor STM STM32F413 32-bit ARM Cortex-M4 Speed 100 MHz Internal RAM 320 KByte (SRAM) Internal Flash 1 MByte External RAM 0 KByte External Flash Up to 4 MByte (QSPI) Dimensions 67.7 x 31.7 x 3.2 mm Note: Not all memory will be available for your application. Peripherals This table lists the available peripherals. The \"overall\" column shows the available pins if the design did not follow the UCM standard. Peripheral UCM Standard Overall UART 4 9 (including HS) UART HS 2 2 I2C 2 2 SPI 2 3 CAN 2 2 SDIO 1 1 ADC 8 15 PWM 8 27 GPIO 10 67 IRQ 4 67 USB Client Supported Supported USB Host Not supported Not supported LCD Not supported Not supported Ethernet PHY Not supported Not supported WiFi Supported Supported Camera Not supported Not supported VBAT Supported Supported JTAG SWD SWD Development Options The UCM development options can greatly simplify the process of building a product or prototype using the UC2550. Options include a development board and displays which can get you programming in minutes. Tip We are assuming you are using the UCM Development Board for all instructions provided. TinyCLR OS TinyCLR OS provides a way to program the UC2550 in C# or Visual Basic from the Microsoft Visual Studio integrated development environment. To get started you must first install the bootloader and firmware on the UC2550 (instructions below) and then go to the TinyCLR Getting Started page for instructions. Loading Bootloader v2 Download the UC2550 bootloader here . Connect your device to the USB client port. Put the board in DFU mode: Hold the SYS A pin low and press/release the reset button. Wait for a second then release SYS A. Windows Device Manager will now show \"STM Device in DFU Mode\" under the 'Universal Serial Bus controller' TAB. Go to the STM32 Bootloader to learn how to upload DFU files. Loading the Firmware Activate the bootloader, hold the LDR0 signal (SYS B) low while resetting the board. Open TinyCLR Config tool. Click the loader tab. Select the correct COM port. If you are not seeing it then the device is not in the loader mode. Click the Update to Latest button. You can also update the firmware manually. Download the firmware and learn how to use the GHI Bootloader manually. Start Coding Now that you have installed the bootloader and firmware on the UC2550, you can setup your host computer and start programming. Go to the TinyCLR Getting Started page for instructions. Code Samples For some examples of using TinyCLR, take a look at the TinyCLR Samples repo . You may also find the TinyCLR tutorials useful. Native Code You have the choice of loading the module with your preferred RTOS. Also, you can load Native Code in TinyCLR OS at runtime that works alongside your managed application. Native code can be used to provide improved performance or access to advanced features. The memory area reserved for native code in TinyCLR OS on UC2550 starts at 0x2003E000 and its length is 0x1FF8. WiFi Support The WiFi module is made by STMicroelectronics. this page has further details. Schematic The schematic for the UC2550 can be found here . Customization We also offer customized, non-stock versions of our SoMs. Many options are available, such as various sizes of external QSPI flash. Please contact us for details. We will always do our best to provide you with a module to fit your exact needs. Pin Assignments SO-DIMM Pin Universal Compute Standard Function Name 1 AGND AGND 2 Ethernet TX- 3 Module Specific 1 (Wi-Fi PIN14) Wi-Fi Power LED 4 Ethernet TX+ 5 Analog VREF- Analog VREF- 6 Ethernet RX- 7 Reserved 8 Ethernet RX+ 9 Reserved 10 Indicator A (WiFi PIN15) WiFi Link Up LED 11 Indicator B (WiFi PIN5) WiFi Running (Blink) LED 12 Reserved 13 GND GND 14 DCMI D0 15 DCMI D1 16 DCMI D2 17 DCMI D3 18 DCMI D4 19 DCMI D5 20 Analog 3.3V Analog 3.3V 21 DCMI D6 22 DCMI D7 23 DCMI VSYNC 24 DCMI HSYNC 25 DCMI PIXCLK 26 DCMI XCLK 27 GND GND 28 PWM E PE5, TIM9 CH1 29 PWM F PE6, TIM9 CH2 30 PWM G PB14, TIM12 CH1 31 PWM H PB15, TIM12 CH2 32 Analog VREF+ Analog VREF+ 33 Reserved 34 5V 35 Module Specific 4 (WiFi PIN13) 36 Module Specific 5 (WiFi PIN16) 37 Module Specific 6 (WiFi PIN22) 38 Module Specific 7 39 Module Specific 8 40 GND GND 41 GND GND 42 LCD 24bpp R0 43 LCD 24bpp R1 44 LCD 24bpp R2 45 LCD 24bpp G0 46 3.3V 3.3V 47 LCD 24bpp G1 48 LCD 24bpp B0 49 LCD 24bpp B1 50 LCD 24bpp B2 51 GND GND 52 Module Specific 9 53 I2S SCK 54 I2S WD 55 I2S WS 56 5V 57 IRQ A PC0, ADC10 58 IRQ B PC1, ADC11 59 IRQ C PC2, ADC12 60 3.3V 3.3V 61 IRQ D PC3, ADC13 62 GPIO A PC4, ADC14 63 GPIO B PC5, ADC15 64 GPIO C PA15, TIM2 CH1 65 GND GND 66 GPIO D PB0, ADC8, TIM3 CH3 67 GPIO E PB7, TIM4 CH2 68 GPIO F PD7 69 GPIO G PD10 70 5V 71 Reserved 72 3.3V 3.3V 73 I2C B SDA PB8, I2C3 SDA, TIM10 CH1 74 I2C B SCL PA8, I2C3 SCL, MCO1 75 UART C TX PE1, UART8 TX 76 UART C RX PE0, UART8 RX 77 UART D TX PD15, USART9 TX, TIM4 CH4 78 UART D RX PD14, USART9 RX, TIM4 CH3 79 GND GND 80 Reserved 81 Reserved 82 Reserved 83 Reserved 84 Reserved 85 Reserved 86 5V 87 USB Device ID 88 3.3V 3.3V 89 UART B TX PE8, USART7 TX 90 UART B RX PE7, USART7 RX 91 ADC A PA0, ADC0, TIM5 CH1 92 GPIO H PE10 93 SPI B MISO (WiFi PIN6) PE13, SPI5 MISO, TIM1 CH3 94 SPI B MOSI (WiFi PIN8) PE14, SPI5 MOSI, TIM1 CH4 95 GND GND 96 SPI B SCK (WiFi PIN10) PE12, SPI5 SCK 97 ADC B PA1, ADC1, TIM5 CH2 98 CAN A TD PD1, CAN1 TX, UART4 TX 99 CAN A RD PD0, CAN1 RX, UART4 RX 100 CAN B TD PB13, CAN2 TX, UART5 TX 101 CAN B RD PB12, CAN2 RX, UART5 RX 102 UART HS A TX PD5, USART2 TX 103 UART HS A RX PD6, USART2 RX 104 ADC C PA2, ADC2, TIM5 CH3 105 PWM A PE9, TIM1 CH1 106 3.3V 3.3V 107 SYS A BOOT0 108 Module Specific 2 (WiFi PIN2) 109 Module Specific 3 (WiFi PIN4) 110 ADC D PA3, ADC3, TIM5 CH4 111 SYS C PE3, LDR1 112 PWM B PE11, TIM1 CH2 113 GND GND 114 ADC E PA4, ADC4, DAC1 115 I2C A SDA PB9, I2C2 SDA, TIM10 CH1 116 I2C A SCL PB10, I2C2 SCL, TIM2 CH3 117 UART A RX PA10, USART1 RX 118 UART A TX PA9, USART1 TX 119 GPIO I PD14, UART9 RX, TIM4 CH3 120 UART HS A RTS PD4, USART2 RTS 121 UART HS A CTS PD3, USART2 CTS 122 GPIO J PD15, UART9 RX, TIM4 CH4 123 SD Card D0 PC8, SD D0, TIM8 CH3 124 3.3V 3.3V 125 SD Card CMD PD2, SD CMD 126 SD Card CLK PC12, SD CLK, SPI3 MOSI 127 SD Card D1 PC9, SD D1, TIM8 CH4 128 SD Card D2 PC10, SD D2, SPI3 SCK 129 SD Card D3 PC11, SD D3, SPI3 MISO 130 PWM C PC6, TIM3 CH1, USART6 TX 131 GND GND 132 GPIO K 133 PWM D PC7, TIM3 CH2, USART6 RX 134 SYS B PB2, LDR0 135 SYS D PE4, MODE 136 GPIO L 137 Module Specific 10 138 UART HS B RTS PD12, USART3 RTS 139 UART HS B CTS PD11, USART3 CTS 140 UART HS B TX PD8, USART3 TX 141 UART HS B RX PD9, USART3 RX 142 3.3V 3.3V 143 LCD VSYNC 144 LCD HSYNC 145 LCD CLK 146 LCD DE 147 Module Specific 11 148 SD Card CD PC13 149 Module Specific 12 150 Reserved 151 GND GND 152 LCD B3 153 LCD B4 154 LCD B5 155 LCD B6 156 LCD B7 157 ADC F PA5, ADC5, DAC2 158 ADC G PA6, ADC6 159 ADC H PA7, ADC7 160 3.3V 3.3V 161 LCD G2 162 LCD G3 163 LCD G4 164 LCD G5 165 LCD G6 166 Module Specific 13 167 Indicator C 168 LCD R7 169 GND GND 170 LCD G7 171 LCD R3 172 LCD R4 173 LCD R5 174 LCD R6 175 SPI A SCK PB3, SPI1 SCK, TIM2 CH2 176 SPI A MISO PB4, SPI1 MISO 177 Module Specific 14 178 SPI A MOSI PB5, SPI1 MOSI 179 Module Specific 15 180 3.3V 3.3V 181 Module Specific 16 182 Module Specific 17 183 VBAT VBAT 184 Module Specific 18 185 GND GND 186 GND GND 187 RESET RESET 188 USB Host D+ 189 JTAG RTCK 190 USB Host D- 191 JTAG TDO 192 3.3V 3.3V 193 JTAG NTRST 194 USB Device D+ PA12, USB D+ 195 JTAG TDI 196 USB Device D- PA11, USB D- 197 JTAG TCK (SWCLK) PA14, JTCK, SWCLK 198 GND GND 199 JTAG TMS (SWDIO) PA13, JTMS, SWDIO 200 Indicator D CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a UC2550 driving the SN65HVD230 CAN driver chip. See the Configuring the Bus section of the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 33.333K 1 13 2 90 1 False 87.5% 0.31% 2195M 83.333K 1 13 2 36 1 False 87.5% 0.31% 845M 125K 1 13 2 24 1 False 87.5% 0.31% 545M 250K 1 13 2 12 1 False 87.5% 0.31% 245M 500K 1 13 2 6 1 False 87.5% 0.31% 95M 1M 1 13 2 3 1 False 87.5% 0.31% 20M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested to ensure reliability. Legal License This product with its accompanying firmware are licensed royalty-free for commercial and noncommercial use. Using the provided firmware on a non-official product requires additional licensing. The provided documentation/schematics/libraries/sources are not to be used in any manner outside for the benefit of implementing and using this GHI Electronics product into your design. Disclaimer IN NO EVENT SHALL GHI ELECTRONICS, LLC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS PRODUCT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. GHI ELECTRONICS LINE OF PRODUCTS ARE NOT DESIGNED FOR LIFE SUPPORT APPLICATIONS. SPECIFICATIONS, PRICE AND AVAILABILITY ARE SUBJECT TO CHANGE WITHOUT ANY NOTICE. Want to quickly build your prototype? Check out the UCM Development Options . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/ucm/standard.html": {
    "href": "hardware/ucm/standard.html",
    "title": "The UCM Standard",
    "keywords": "The UCM Standard The UCM Standard defines a consistent hardware and software interface for the most widely used microcontroller peripherals. Universal Compute Modules are based on the 200 pin SO-DIMM form factor. They adhere to a standard pinout across models making it easy to change modules to adapt to the needs of your product. When designing a product, consider following thee UCM standard pinout. This will make your design compatible with any of the UCM modules. Software also becomes more portable with the UCM standard. For example, our TinyCLR OS provides a library to automatically map the UCM standard names to the underlying system so that your program can use the UCM standard names only, making changing to a different module very easy. The SO-DIMM Socket All of our UCMs use the same 200 pin SO-DIMM socket that was originally made for DDR2 memory modules. The fastest way to get started with UCMs is by using the optional boards and displays described on the UCM Development Options page. You can also incorporate any of our UCMs into your own custom design by adding the appropriate SO-DIMM socket to your circuit board. Tip Make sure to expose the required pins in your design. Specific pins are needed for device programming, updates, recovery, and Wi-Fi firmware updates. See device specifications for details. SO-DIMM stands for Small Outline Dual Inline Memory Module. There are two different 200 pin SO-DIMM sockets, those made for DDR memory and those made for DDR2 memory. They are identical except for the orientation notch which is in a slightly different position. These sockets are not interchangeable. There is also a 204 pin SO-DIMM socket for DDR3 memory with the notch positioned closer to the center of the module. Note Our UCMs are only compatible with DDR2 type 200 pin SO-DIMM sockets. Here is a link to the manufacturer's web page for the connector we use on our boards: EMBOSS ASSY DDR2 SODIMM SOCKET 200P 5.2H Peripherals Peripheral Up to Max UART (Universal Asynchronous Receiver/Transmitter) 4 UART HS (Handshaking) 2 I2C (Inter-Integrated Circuit) 2 SPI (Serial Peripheral Interface) 2 CAN (Controller Area Network) 2 SDIO (SD Card) 1 ADC (Analog to Digital Converter) 8 PWM (Pulse Width Modulation) 8 GPIO (General Purpose Input/Output) 12 IRQ (Interrupt Request Capable GPIO) 4 USB Client 1 USB Host 1 LCD (TFT Controller - 16bpp or 24bpp) 1 Ethernet PHY (Ethernet Physical Layer) 1 DCMI (Digital Camera Interface) 1 VBAT (Battery Backup for RTC) 1 JTAG (Debug Serial Port) 1 * Available peripherals vary by model Note that the system defines 12 GPIOs that are free from any other functions but most other peripheral pins also support GPIO, giving the user several more GPIO pin options -- keep in mind the standard does not guarantee this though. Tip The TinyCLR tutorials are a good resource on using these peripherals. UART (Universal Asynchronous Receiver Transmitter) UART is used to implement moderate speed full duplex asynchronous serial communication. It is usually used for peer to peer communication between only two devices. It can transfer data using only one wire for each direction if both devices share a common ground. UART HS (Handshaking) UART with handshaking is a configuration which allows the host and client to negotiate data transfer via Ready to Send (RTS) and Clear to Send (CTS) signals (two additional wires) to prevent missed data. I2C (Inter-Integrated Circuit) I2C is a multi-master, multi-slave, packet switched, half duplex serial communication bus typically used for attaching peripheral ICs to processors and microcontrollers in short-distance, intra-board communication. It uses two wires and has a slower maximum speed than SPI. SPI (Serial Peripheral Interface) SPI is a synchronous serial communication interface used for short distance communication. It uses a master-slave protocol. When using TinyCLR, the processor running TinyCLR is always configured as the master. SPI needs at least three wires and usually needs an additional line (chip select) for each slave. It can communicate much faster than either UART or I2C. CAN (Controller Area Network) A robust bus standard that originated in the automotive field and works very well in high noise environments. It allows microcontrollers and devices to communicate with each other in applications without a host computer. It is a message-based multi-master protocol and generally uses only two wires. Speed is up to one megabit per second but limited by bus length. SDIO (SD Card) SDIO (Secure Digital Input Output) is an interface used for reading from and writing to SD cards. ADC (Analog to Digital Converter) ADCs are used to measure an analog voltage level by converting it to a digital value. PWM (Pulse Width Modulation) PWM is a method of generating a square wave signal of uniform frequency with variable duty cycle. PWM is often used to generate analog voltages, but has many other uses such as generating digital pulses for driving servo motors or driving infrared LEDs for communication. GPIO (General Purpose Input/Output) GPIOs are the digital I/O pins that allow the user to interface with basic devices such as buttons (input) or LEDs (output). GPIOs are very versatile and can also be used to perform more advanced communication and control duties. IRQ (Interrupt Request Capable GPIO) IRQ capable GPIO pins can be programmed to interrupt a program when the input to the pin changes. For example, an IRQ could be used by a Wi-Fi module to tell the processor that the Wi-Fi module is receiving data. The processor would then stop what it is doing to get the data from the WiFi module. USB Client Used to communicate with a USB host. Often used to program and debug embedded devices. USB Host Used to communicate with one or more USB clients. Typically used to communicate with various devices such as a mouse, keyboard, camera, etc. LCD (TFT Controller - 16bpp or 24bpp) An interface providing communication with a TFT LCD (thin-film-transistor liquid-crystal display). The number of data lines connected determines the number of bits per pixel (bpp), which determines the number of colors that can be displayed. Ethernet PHY Ethernet PHY is the Ethernet physical (hardware) layer. It provides the Tx and Rx signals for the Ethernet connector. DCMI (Digital Camera Interface) A standard interface for compatible digital cameras. VBAT (Battery Backup for RTC) VBAT is used to provide battery voltage to a microcontroller's real time clock. It allows the microcontroller to keep the correct time when the main power to the controller is disconnected (the device is turned off). JTAG JTAG is a serial interface which allows communication between the processor and a host computer. It is built into the microcontroller and provides a means of software debugging including the ability to stop program execution, single step through program instructions, and read and write to memory and processor registers. Pin Assignments SO-DIMM Pin Universal Compute Standard 1 AGND 2 Ethernet TX- 3 Module Specific 1 4 Ethernet TX+ 5 Analog VREF- 6 Ethernet RX- 7 Reserved 8 Ethernet RX+ 9 Reserved 10 Indicator A 11 Indicator B 12 Reserved 13 GND 14 DCMI D0 15 DCMI D1 16 DCMI D2 17 DCMI D3 18 DCMI D4 19 DCMI D5 20 Analog 3.3V 21 DCMI D6 22 DCMI D7 23 DCMI VSYNC 24 DCMI HSYNC 25 DCMI PIXCLK 26 DCMI XCLK 27 GND 28 PWM E 29 PWM F 30 PWM G 31 PWM H 32 Analog VREF+ 33 Reserved 34 5V 35 Module Specific 4 36 Module Specific 5 37 Module Specific 6 38 Module Specific 7 39 Module Specific 8 40 GND 41 GND 42 LCD 24bpp R0 43 LCD 24bpp R1 44 LCD 24bpp R2 45 LCD 24bpp G0 46 3.3V 47 LCD 24bpp G1 48 LCD 24bpp B0 49 LCD 24bpp B1 50 LCD 24bpp B2 51 GND 52 Module Specific 9 53 Reserved 54 Reserved 55 Reserved 56 5V 57 IRQ A 58 IRQ B 59 IRQ C 60 3.3V 61 IRQ D 62 GPIO A 63 GPIO B 64 GPIO C 65 GND 66 GPIO D 67 GPIO E 68 GPIO F 69 GPIO G 70 5V 71 Reserved 72 3.3V 73 I2C B SDA 74 I2C B SCL 75 UART C TX 76 UART C RX 77 UART D TX 78 UART D RX 79 GND 80 Reserved 81 Reserved 82 Reserved 83 Reserved 84 Reserved 85 Reserved 86 5V 87 USB Device ID 88 3.3V 89 UART B TX 90 UART B RX 91 ADC A 92 GPIO H 93 SPI B MISO 94 SPI B MOSI 95 GND 96 SPI B SCK 97 ADC B 98 CAN A TD 99 CAN A RD 100 CAN B TD 101 CAN B RD 102 UART HS A TX 103 UART HS A RX 104 ADC C 105 PWM A 106 3.3V 107 SYS A 108 Module Specific 2 109 Module Specific 3 110 ADC D 111 SYS C 112 PWM B 113 GND 114 ADC E 115 I2C A SDA 116 I2C A SCL 117 UART A RX 118 UART A TX 119 GPIO I 120 UART HS A RTS 121 UART HS A CTS 122 GPIO J 123 SD Card D0 124 3.3V 125 SD Card CMD 126 SD Card CLK 127 SD Card D1 128 SD Card D2 129 SD Card D3 130 PWM C 131 GND 132 GPIO K 133 PWM D 134 SYS B 135 SYS D 136 GPIO L 137 Module Specific 10 138 UART HS B RTS 139 UART HS B CTS 140 UART HS B TX 141 UART HS B RX 142 3.3V 143 LCD VSYNC 144 LCD HSYNC 145 LCD CLK 146 LCD DE 147 Module Specific 11 148 SD Card CD 149 Module Specific 12 150 Reserved 151 GND 152 LCD B3 153 LCD B4 154 LCD B5 155 LCD B6 156 LCD B7 157 ADC F 158 ADC G 159 ADC H 160 3.3V 161 LCD G2 162 LCD G3 163 LCD G4 164 LCD G5 165 LCD G6 166 Module Specific 13 167 Indicator C 168 LCD R7 169 GND 170 LCD G7 171 LCD R3 172 LCD R4 173 LCD R5 174 LCD R6 175 SPI A SCK 176 SPI A MISO 177 Module Specific 14 178 SPI A MOSI 179 Module Specific 15 180 3.3V 181 Module Specific 16 182 Module Specific 17 183 VBAT 184 Module Specific 18 185 GND 186 GND 187 RESET 188 USB Host D+ 189 JTAG RTCK 190 USB Host D- 191 JTAG TDO 192 3.3V 193 JTAG NTRST 194 USB Device D+ 195 JTAG TDI 196 USB Device D- 197 JTAG TCK (SWCLK) 198 GND 199 JTAG TMS (SWDIO) 200 Indicator D Want to quickly build your prototype? Check out the UCM Development Options . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/scm/g30.html": {
    "href": "hardware/scm/g30.html",
    "title": "G30",
    "keywords": "G30 Overview The G30 SoC is a low-cost System on Chip part of the GHI Electronics SurfaceMount Compute Modules (SCM) line. This modules can be programmed in .NET C# and Visual Basic using TinyCLR OS or .NET Micro Framework. Pricing, purchasing and other information can be found on the G30 Page on our main website. Ordering Part Number G30 SoC: 30SOC-SC-539 G30 Dev Board: G30DB-SM-555 Specifications Spec Value Processor STM ST32F401RET6 Speed 84 MHz Internal RAM 96 KByte (SRAM) Internal Flash 512 KByte Package LQFP64 10 x 10 mm Temperature Range -40C to +85C Note: Resources are shared between your application and the operating system. Peripherals TinyCLR OS ready .NET Micro Framework RoHS Lead Free 84 MHz ARM Cortex-M4 STM32F401RET6 68 Kbytes available RAM 128 Kbytes available flash 49 GPIO 16 interrupt capable GPIO 2 SPI 1 I2C 2 UART 15 PWM 16 12-bit analog input 4-bit SD/MMC memory card interface Low power modes LQFP64 10 x 10 mm RTC Watchdog Threading USB client File System Full .NET file interface SD cards Native extensions Device register access Signal controls Generation Capture Pulse measurement G30 Pinout Many signals on the G30 are multiplexed to offer multiple functions on a single pin. Developers can decide on the pin functionality to be used through the provided libraries. Any pin with no name, function, or note must be left unconnected. Footprint The chip is standard LQFP64 10x10mm. See the ST32F401RET6 datasheet for exact footprint. Device Startup The G30 is held in reset when the reset pin is low. Releasing it will begin the system startup process. There are three different components of the device firmware: GHI Bootloader: initializes the system, updates TinyCLR when needed, and executes TinyCLR. TinyCLR: loads, debugs, and executes the managed application. Managed application: the program developed by the customer. Which components get executed on startup can be control by manipulating the LDR0 pin. It is pulled high on startup. When low, the device waits in the GHI Bootloader. Otherwise, the managed application is executed. LDR1 is reserved for future use. Additionally, the communications interface between the host PC and the G30 is selected on startup through the MODE pin, which is pulled high on startup. The USB interface is selected when MODE is high and COM1 is selected when MODE is low. The above discussed functions of LDR0, LDR1, and MODE are only during startup. After startup, they return to the default GPIO state and are available to use as GPIO in the user application. TinyCLR OS TinyCLR OS provides a way to program the G30 in C# or Visual Basic from the Microsoft Visual Studio integrated development environment. To get started you must first install the TinyCLR OS firmware (instructions below) and then go to the TinyCLR Getting Started page for instructions. Loading the Firmware Activate the bootloader, hold the LDR0 signal low while resetting the board. Open TinyCLR Config tool. Click the loader tab. Select the correct COM port. If you are not seeing it then the device is not in the loader mode. Click the Update to Latest button. You can also update the firmware manually. Download the firmware and learn how to use the GHI Bootloader manually. Start Coding Now that you have installed the firmware on the G30, you can setup your host computer and start programming. Go to the TinyCLR Getting Started page for instructions. Code Samples For some examples of using TinyCLR, take a look at the TinyCLR Samples repo . You may also find the TinyCLR tutorials useful. Native Code TinyCLR OS also lets you use native code that works alongside your managed application. Native code can be used to provide improved performance or access to advanced features not exposed through TinyCLR. For more information check out Native Code on TinyCLR . The memory area reserved for native code in TinyCLR OS on G30 starts at 0x20016000 and its length is 0x3F8. .NET Micro Framework It is possible to still use .NET Micro Framework (NETMF). Details are on the NETMF Introduction page. The NETMF Getting Started page covers NETMF from setup of the host computer to program deployment on both an emulator and target device. Datasheet This documentation page replaced the legacy datasheet PDF but it is here for reference. Design Considerations Required Pins Exposing the following pins is required in every design to enable device programming, updates, and recovery: LDR0 LDR1 Reset Desired debug interface(s) MODE if required to select a debug interface Power Supply A typical clean power source, suited for digital circuitry, is needed to power the G30. Voltages should be within at least 10% of the needed voltage. Decoupling capacitors of 0.1 Î¼F are needed near every power pin. Additionally, a large capacitor, typically 47 Î¼F, should be near the G30 if the power supply is more than few inches away. Crystals The G30 requires an external 12 MHz crystal and associated circuitry to function. For the RTC to function, a 32,768 Hz crystal and circuitry are required. Please see the processorâs documentation for advanced information. Interrupt Pins Interrupts are only available on 16 pins at any given time. Of those 16 pins, the pin number must be unique. For example: PA1 and PB1 cannot both be used as interrupts at the same time, but PA1 and PB2 can. Reset The reset pin is not pulled in any direction. Designs must be sure to use an appropriate pull-up resistor. G30 Development Board The G30 Dev Board is an excellent starting point and reference design for anyone interested in evaluating and developing with the G30. Schematic TinyCLR Samples repo Legal License This product with its accompanying firmware are licensed royalty-free for commercial and noncommercial use. Using the provided firmware on a non-official product requires additional licensing. The provided documentation/schematics/libraries/sources are not to be used in any manner outside for the benefit of implementing and using this GHI Electronics product into your design. Disclaimer IN NO EVENT SHALL GHI ELECTRONICS, LLC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS PRODUCT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. GHI ELECTRONICS LINE OF PRODUCTS ARE NOT DESIGNED FOR LIFE SUPPORT APPLICATIONS. SPECIFICATIONS, PRICE AND AVAILABILITY ARE SUBJECT TO CHANGE WITHOUT ANY NOTICE. You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/scm/g120e.html": {
    "href": "hardware/scm/g120e.html",
    "title": "G120E",
    "keywords": "G120E The G120 and G120E are very similar. G120E is slightly larger and has a built in Ethernet PHY. Please see our G120 Page"
  },
  "hardware/legacy/som.html": {
    "href": "hardware/legacy/som.html",
    "title": "Legacy System on Modules",
    "keywords": "Legacy System on Modules With the rapid advance of technology it can be hard to stay current. We take pride in our support of past products while we work hard to provide our customers with the best new technology. Legacy product should not be used for new designs; however, many of our older products can still be produced (minimum order may be required). Please contact us for information on the production of legacy products or the recommended upgrade path to current or planned products."
  },
  "hardware/legacy/intro.html": {
    "href": "hardware/legacy/intro.html",
    "title": "Legacy Products Introduction",
    "keywords": "Legacy Products Introduction This section covers GHI's legacy products. These products are not recommended for new designs and are no longer covered by our free support. Please contact us directly for details on our paid support services. SoMs Learn more... Gadgeteer Learn more... Gadgeteering Learn more... mBuino Learn more... Imaging Learn more... Raspberry PI Hats Learn more... Tip Our community forum is a great place to get help from our engineers and from thousands of community members: https://forums.ghielectronics.com/ Producing Legacy Products GHI Electronic's products are all engineered and manufactured in-house. While some of our older products are deemed legacy and not recommended for new designs, we can still produce them, however a minimum order may be required. We understand the need for continued product support and availability. Please contact us to discuss ways to fulfill your immediate needs and also to discuss upgrade options. Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/gadgeteer/fez-reaper.html": {
    "href": "hardware/gadgeteer/fez-reaper.html",
    "title": "FEZ Reaper",
    "keywords": "FEZ Reaper FEZ Reaper is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Reaper is the G80 System on Chip (SoC). Follow the instructions on the G80 page to learn how to use FEZ Raptor with NETMF and TinyCLR OS. Resources Schematic Tip To activate bootloader v2, press and hold both LDR0 and LDR1 buttons down while resetting the board."
  },
  "hardware/ucm/g400d.html": {
    "href": "hardware/ucm/g400d.html",
    "title": "G400D",
    "keywords": "G400D Overview The G400D System on Module (SoM) is a 400 MHz ARM9. It is the first Universal Compute Modules (UCMs) . Originally running .NET Micro Framework exclusively, it can now be used with TinyCLR OS. Pricing, purchasing and other information can be found on the G400D Page on our main website. Tip Modules designed for the UCM standard have more functionality available when not following the rules set by the standard. It is up to you to decide how much your design will follow the UCM standard. Ordering Part Number G400D SoM: G400D-SM-400 Specifications Spec Value Processor Atmel AT91SAM9X35 ARM 926 Speed 400 MHz Internal RAM 32 KByte (SRAM) Internal Flash 0 KByte External RAM 128 MByte (DDR2 SDRAM) External Flash 4 MByte (SPI) Dimensions 67.7 x 31.9 x 5.0 mm Note: Resources are shared between your application and the operating system. Peripherals This table lists the available peripherals. The \"overall\" column shows the available pins if the design did not follow the UCM standard. Peripheral UCM Standard Overall UART 1 5 (including HS) UART HS 1 1 I2C 1 1 SPI 1 1 CAN 1 2 SDIO 1 1 ADC 8 8 PWM 4 4 GPIO 12 70 IRQ 4 70 USB Client Supported Supported USB Host 1 2 LCD Supported (16bpp) Supported (16bpp) Ethernet PHY Supported Supported WiFi Not supported Not supported DCMI Not supported Not supported VBAT Supported Supported JTAG Full JTAG Full JTAG Development Options The UCM development options can greatly simplify the process of building a product or prototype using the UC5550. Options include a development board and displays which can get you programming in minutes. .NET Micro Framework (NETMF) The NETMF software on G400 is mature and complete. For more information on NETMF you can go to the NETMF Introduction page. The NETMF Getting Started page covers NETMF from setup of the host computer to program deployment on both an emulator and target device. Bootloader v1 is needed for G400 to work with NETMF. It is available in the NETMF SDK. TinyCLR OS TinyCLR OS provides a way to program the G400 in C# or Visual Basic from the Microsoft Visual Studio integrated development environment. To get started you must first install the bootloader and firmware on the UC5550 (instructions below) and then go to the TinyCLR Getting Started page for instructions. Loading Bootloader Version 2 Download the G400 bootloader v2 file and load onto the dataflash. The SAM-BA Bootloader has the details. Loading the Firmware Activate the bootloader, hold the LDR0 signal (SYS B) low while resetting the board. Open TinyCLR Config tool. Click the loader tab. Select the correct COM port. If you are not seeing it then the device is not in the loader mode. Click the Update to Latest button. You can also update the firmware manually. Download the firmware and learn how to use the GHI Bootloader manually. Start Coding Now that you have installed the bootloader and firmware, you can setup your host computer and start programming. Go to the TinyCLR Getting Started page for instructions. Code Samples For some examples of using TinyCLR, take a look at the TinyCLR Samples repo . You may also find the TinyCLR tutorials useful. Native Code You have the choice of loading the module with your preferred RTOS. Also, you can load Native Code in TinyCLR OS at runtime that works alongside your managed application. Native code can be used to provide improved performance or access to advanced features. The memory area reserved for native code in TinyCLR OS on G400D starts at 0x26700000 and its length is 0x16FFFF8. Datasheet This documentation page replaced the legacy datasheet PDF but it is here for reference. G400D Pinout Many signals on the G400D are multiplexed to offer multiple functions on a single pin. Developers can decide on the pin functionality to be used through the provided libraries. Any pin with no name, function, or note must be left unconnected. UCM Pinout SO-DIMM Pin UCM Standard Function Name 1 AGND GND 2 Ethernet TX- ETH PHY TX- 3 Module Specific 1 4 Ethernet TX+ ETH PHY TX+ 5 Analog VREF- GND 6 Ethernet RX- ETH PHY RX- 7 Reserved 8 Ethernet RX+ ETH PHY RX+ 9 Reserved 10 Indicator A ETH PHY LED SPEED 11 Indicator B ETH PHY LED LINK 12 Reserved 13 GND GND 14 DCMI D0 15 DCMI D1 16 DCMI D2 17 DCMI D3 18 DCMI D4 19 DCMI D5 20 Analog 3.3V 3.3V 21 DCMI D6 22 DCMI D7 23 DCMI VSYNC 24 DCMI HSYNC 25 DCMI PIXCLK 26 DCMI XCLK 27 GND GND 28 PWM E 29 PWM F 30 PWM G 31 PWM H 32 Analog VREF+ 3.3V 33 Reserved 34 5V 35 Module Specific 4 PB3 36 Module Specific 5 PB4 (DNP) 37 Module Specific 6 PB5 38 Module Specific 7 PB6 39 Module Specific 8 PB7 40 GND GND 41 GND GND 42 LCD 24bpp R0 43 LCD 24bpp R1 44 LCD 24bpp R2 45 LCD 24bpp G0 46 3.3V 3.3V 47 LCD 24bpp G1 48 LCD 24bpp B0 49 LCD 24bpp B1 50 LCD 24bpp B2 51 GND GND 52 Module Specific 9 PB1 53 Reserved 54 Reserved 55 Reserved 56 5V 57 IRQ A PD18 58 IRQ B PD17 59 IRQ C PD16 60 3.3V 3.3V 61 IRQ D PD15 62 GPIO A PD14 63 GPIO B PD13 64 GPIO C PD12 65 GND GND 66 GPIO D PD11 67 GPIO E PD10 68 GPIO F PD9 69 GPIO G PD8 70 5V 71 Reserved 72 3.3V 3.3V 73 I2C B SDA 74 I2C B SCL 75 UART C TX 76 UART C RX 77 UART D TX 78 UART D RX 79 GND GND 80 Reserved 81 Reserved 82 Reserved 83 Reserved 84 Reserved 85 Reserved 86 5V 87 USB Device ID 88 3.3V 3.3V 89 UART B TX 90 UART B RX 91 ADC A PB8, ADC9 92 GPIO H PD2 93 SPI B MISO 94 SPI B MOSI 95 GND GND 96 SPI B SCK 97 ADC B PB11, ADC0 98 CAN A TD PA5, UART3 TX, CAN2 TX 99 CAN A RD PA6, UART3 RX, CAN2 RX 100 CAN B TD 101 CAN B RD 102 UART HS A TX PA0, UART2 TX 103 UART HS A RX PA1, UART2 RX 104 ADC C PB12, ADC1 105 PWM A PC18, PWM0 106 3.3V 3.3V 107 SYS A SPI1 MISO 108 Module Specific 2 SPI1 MOSI 109 Module Specific 3 SPI1 SCK 110 ADC D PB17, ADC6 111 SYS C PA4, LDR1 112 PWM B PC19, PWM1 113 GND GND 114 ADC E PB16, ADC5 115 I2C A SDA PA30, I2C SDA 116 I2C A SCL PA31, I2C SCL 117 UART A RX PA9, UART1 RX, CAN1 RX 118 UART A TX PA10, UART1 TX, CAN1 TX 119 GPIO I PC24 120 UART HS A RTS PA2, UART2 RTS 121 UART HS A CTS PA3, UART2 CTS 122 GPIO J PD7 123 SD Card D0 PA15, SD D0 124 3.3V 3.3V 125 SD Card CMD PA16, SD CMD 126 SD Card CLK PA17, SD CLK 127 SD Card D1 PA18, SD D1 128 SD Card D2 PA19, SD D2 129 SD Card D3 PA20, SD D3 130 PWM C PC21, PWM3 131 GND GND 132 GPIO K PC26 133 PWM D PC20, PWM2 134 SYS B PA24, LDR0 135 SYS D PA25, MODE 136 GPIO L PA26 137 Module Specific 10 PA27 138 UART HS B RTS 139 UART HS B CTS 140 UART HS B TX PC16, UART6 TX 141 UART HS B RX PC17, UART6 RX 142 3.3V 3.3V 143 LCD VSYNC PC27, LCD VSYNC 144 LCD HSYNC PC28, LCD HSYNC 145 LCD CLK PC30, LCD CLK 146 LCD DE PC29, LCD DE 147 Module Specific 11 PD3 148 SD Card CD PD4 149 Module Specific 12 PD5 150 Reserved 151 GND GND 152 LCD B3 PC0, LCD B3 153 LCD B4 PC1, LCD B4 154 LCD B5 PC2, LCD B5 155 LCD B6 PC3, LCD B6 156 LCD B7 PC4, LCD B7 157 ADC F PB13, ADC2 158 ADC G PB14, ADC3 159 ADC H PB15, ADC4 160 3.3V 3.3V 161 LCD G2 PC5, LCD G2 162 LCD G3 PC6, LCD G3 163 LCD G4 PC7, LCD G4 164 LCD G5 PC8, LCD G5, UART5 TX 165 LCD G6 PC9, LCD G6, UART5 RX 166 Module Specific 13 PD1 167 Indicator C PA8, UART4 RX 168 LCD R7 PC15, LCD R7 169 GND GND 170 LCD G7 PC10, LCD G7 171 LCD R3 PC11, LCD R3 172 LCD R4 PC12, LCD R4 173 LCD R5 PC13, LCD R5 174 LCD R6 PC14, LCD R6 175 SPI A SCK PA23, SPI2 SCK 176 SPI A MISO PA21, SPI2 MISO 177 Module Specific 14 WKUP 178 SPI A MOSI PA22, SPI2 MOSI 179 Module Specific 15 SHDN 180 3.3V 3.3V 181 Module Specific 16 PWR EN 182 Module Specific 17 USB H2+ 183 VBAT VBAT 184 Module Specific 18 USB H2- 185 GND GND 186 GND GND 187 RESET RESET 188 USB Host D+ USB H1+ 189 JTAG RTCK RTCK 190 USB Host D- USB H1- 191 JTAG TDO TDO 192 3.3V 3.3V 193 JTAG NTRST NTRST 194 USB Device D+ USB D+ 195 JTAG TDI TDI 196 USB Device D- USB D- 197 JTAG TCK (SWCLK) TCK 198 GND GND 199 JTAG TMS (SWDIO) TMS 200 Indicator D PA7, UART4 TX CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a G400 driving the SN65HVD230 CAN driver chip. See the Configuring the Bus section of the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 83.333K 7 4 1 99 0 False 87.5% 0.31% 845M 125K 7 1 1 81 0 False 84.6% 0.38% 499M 250K 7 1 1 40 0 False 84.6% 0.38% 222M 500K 7 7 1 13 1 False 89.5% 0.41% 92M 1M 7 7 1 6 1 False 89.5% 0.41% 19M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested to ensure reliability. G400 Development Board This is no longer in production, replaced by the Development Options Schematic Legal License This product with its accompanying firmware are licensed royalty-free for commercial and noncommercial use. Using the provided firmware on a non-official product requires additional licensing. The provided documentation/schematics/libraries/sources are not to be used in any manner outside for the benefit of implementing and using this GHI Electronics product into your design. Disclaimer IN NO EVENT SHALL GHI ELECTRONICS, LLC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS PRODUCT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. GHI ELECTRONICS LINE OF PRODUCTS ARE NOT DESIGNED FOR LIFE SUPPORT APPLICATIONS. SPECIFICATIONS, PRICE AND AVAILABILITY ARE SUBJECT TO CHANGE WITHOUT ANY NOTICE. Want to quickly build your prototype? Check out the UCM Development Options . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/scm/g120.html": {
    "href": "hardware/scm/g120.html",
    "title": "G120",
    "keywords": "G120 Overview The G120 and G120E SoMs are powerful, low-cost, System on Modules part of the GHI Electronics SurfaceMount Compute Modules (SCM) line. These modules can be programmed in .NET C# and Visual Basic using TinyCLR OS or .NET Micro Framework. Pricing, purchasing, and other information can be found on the G120 Page on our main website. Ordering Part Number G120 SoM: G120B-SM-373 G120E SoM: G120E-SM-532 G120E Dev Board: G120D-SM-533 G120 vs G120E G120 G120E Processor NXP LPC1788FET180 NXP LPC1788FET208 Package 91 pin surface-mount module (SMT) 120 MHz Dimensions 38.1 x 26.7 x 3.5 mm 45.8 x 39.4 x 4.4 mm RTC External 32,768 Hz crystal Included GPIO 72 80 SPI 3 2 Ethernet ENC28J60 over SPI ENC28J60 over SPI and/or Built-in base 100 Ethernet PHY Specifications Spec Value Processor NXP LPC1788FET Speed 120 MHz Internal RAM 96 KByte (SRAM) Internal Flash 512 KByte External RAM 16 MByte (DRAM) External Flash 4 MByte (SPI) Dimensions (G120) 38.1 x 26.7 x 3.5 mm Dimensions (G120E) 45.8 x 39.4 x 4.4 mm Temperature Range -40 C to +85 C Note: Resources are shared between your application and the operating system. Peripherals TinyCLR OS ready .NET Micro Framework RoHS Lead Free 120 MHz ARM Cortex-M3 NXP LPC1788 6 Mbytes available RAM 2.3 Mbytes available flash Embedded LCD controller 72 to 80 GPIO 43 interrupt capable GPIO 2 to 3 SPI 1 I2C 5 UART 2 CAN 12 PWM 8 12-bit analog input 1 10-bit analog output 4-bit SD/MMC memory card interface Low power modes RTC Watchdog Threading USB host USB client SQLite database TCP/IP with SSL Full .NET socket interface Ethernet Wi-Fi PPP Graphics Images Fonts Controls File System Full .NET file interface SD cards USB drives Native extensions Runtime Loadable Procedures Device register access Signal controls Generation Capture Pulse measurement G120 Pinout Many signals on the G120 are multiplexed to offer multiple functions on a single pin. Developers can decide on the pin functionality to be used through the provided libraries. Any pin with no name, function, or note must be left unconnected. G120E Pinout Footprints We recommend no traces or vias under the module. Dimensions are in inches. G120 Recommended Footprint G120E Recommended Footprint Device Startup The G120 is held in reset when the reset pin is low. Releasing it will begin the system startup process. It is pulled high internally on the G120E and left floating on the G120. There are four different components of the device firmware: GHI Bootloader: initializes the system, updates TinyBooter when needed, and executes TinyBooter. TinyBooter: executes TinyCLR, updates TinyCLR when needed, and updates the system configuration. TinyCLR: loads, debugs, and executes the managed application. Managed application: the program developed by the customer. Which components get executed on startup can be control by manipulating the LDR0 and LDR1 pins. LDR0 and LDR1 are pulled high on startup. LDRO LDR1 Effect Ignored High Execute the managed application High Low Wait in TinyBooter Low Low Wait in GHI Bootloader Additionally, the communications interface between the host PC and the G120 is selected on startup through the MODE pin, which is pulled high on startup MODE G120 G120E High USB COM1 Low COM1 USB The above discussed functions of LDR0, LDR1, and MODE are only during startup. After startup, they return to the default GPIO state and are available to use as GPIO in the user application. .NET Micro Framework (NETMF) The NETMF software on G120 is mature and complete. For more information on NETMF you can go to the NETMF Introduction page. The NETMF Getting Started page covers NETMF from setup of the host computer to program deployment on both an emulator and target device. TinyCLR OS TinyCLR OS provides a way to program the G120 in C# or Visual Basic from the Microsoft Visual Studio integrated development environment. To get started you must first install the bootloader and firmware on the G120 (instructions below) and then go to the TinyCLR Getting Started page for instructions. Loading Bootloader v2 The G120 comes with Bootloader v1 pre-installed. You need to upgrade to Bootloader v2. Start by putting G120 into the v1 loader mode by setting LDR0 and LDR1 signals low while reseting the board. You can now load v2 loader as detailed on the GHI Bootloader page. Loading the Firmware Activate the bootloader, hold the LDR0 signal low while resetting the board. Open TinyCLR Config tool. Click the loader tab. Select the correct COM port. If you are not seeing it then the device is not in the loader mode. Click the Update to Latest button. You can also update the firmware manually. Download the firmware and learn how to use the GHI Bootloader manually. Start Coding Now that you have installed the bootloader and firmware on the G120, you can setup your host computer and start programming. Go to the TinyCLR Getting Started page for instructions. Code Samples For some examples of using TinyCLR, take a look at the TinyCLR Samples repo . You may also find the TinyCLR tutorials useful. Native Code TinyCLR OS also lets you use native code that works alongside your managed application. Native code can be used to provide improved performance or access to advanced features not exposed through TinyCLR. For more information check out Native Code on TinyCLR . The memory area reserved for native code in TinyCLR OS on G120 starts at 0xA0F00000 and its length is 0xFFF8. Datasheet This documentation page replaced the legacy datasheet PDF but it is here for reference. CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a G120 driving the SN65HVD230 CAN driver chip. See the Configuring the Bus section of the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 33.333K 1 12 2 120 1 False 86.7% 0.33% 2145M 83.333K 1 13 2 45 1 False 87.5% 0.31% 845M 125K 1 13 2 30 1 False 87.5% 0.31% 545M 250K 1 13 2 15 1 False 87.5% 0.31% 245M 500K 1 12 2 8 1 False 86.7% 0.33% 92M 1M 1 12 2 4 1 False 86.7% 0.33% 18M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested t ensure reliability.* Design Considerations Required Pins Exposing the following pins is required in every design to enable device programming, updates, and recovery: LDR0 LDR1 Reset Desired debug interface(s) MODE if required to select a debug interface Power Supply A typical clean power source, suited for digital circuitry, is needed to power the G120. Voltages should be within at least 10% of the needed voltage. Decoupling capacitors of 0.1 Î¼F are needed near every power pin. Additionally, a large capacitor, typically 47 Î¼F, should be near the G120 if the power supply is more than few inches away. Crystals The G120 and G120E include the needed system crystal and its associated circuitry. The G120E additionally includes the RTC crystal and its associated circuitry. However, the G120 does not. It requires an external 32,768 Hz crystal and circuitry for the RTC to function. Please see the processorâs documentation for advanced information. Interrupt Pins Only pins on ports 0 and 2 support interrupts. Reset The G120E includes an internal pull-up resistor on the reset pin. The G120 does not, so an external 15 kâ¦ pull-up resistor is required for correct operation. SPI Channels SPI2 is shared internally with the flash memory on the G120. Use of a chip select with devices on this channel is required or the G120 will not function properly. The use of another SPI channel is recommended. Ethernet The built in Ethernet available on the G120E includes all needed Ethernet circuitry internally. However, an appropriate magnet and connector, like the J0011D or similar, are required. Oven Reflow The G120 is not sealed for moisture. Baking the module before reflow is recommended and required in a humid environment. The process of reflow can damage the G120 if the temperature is too high or exposure is too long. The lead-free reflow profile used by GHI Electronics is shown below. The profiles shown are based on SAC 305 solder (3% silver, 0.5% copper). The thermal mass of the assembled board and the sensitivity of the components on it affect the total dwell time. Differences in the two profiles are where they reach their respective peak temperatures as well as the time above liquids (TAL). The shorter profile applies to smaller assemblies, whereas the longer profile applies to larger assemblies such as back-planes or high-density boards. The process window is described by the shaded area. These profiles are only starting-points and general guidance. The particulars of an oven and the assembly will determine the final process. G120 Development Board The G120E Dev Board is an excellent starting point and reference design for anyone interested in evaluating and developing with the G120/G120E. Schematic TinyCLR Samples repo Legal License This product with its accompanying firmware are licensed royalty-free for commercial and noncommercial use. Using the provided firmware on a non-official product requires additional licensing. The provided documentation/schematics/libraries/sources are not to be used in any manner outside for the benefit of implementing and using this GHI Electronics product into your design. Disclaimer IN NO EVENT SHALL GHI ELECTRONICS, LLC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS PRODUCT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. GHI ELECTRONICS LINE OF PRODUCTS ARE NOT DESIGNED FOR LIFE SUPPORT APPLICATIONS. SPECIFICATIONS, PRICE AND AVAILABILITY ARE SUBJECT TO CHANGE WITHOUT ANY NOTICE. You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/loaders/ghi-bootloader.html": {
    "href": "hardware/loaders/ghi-bootloader.html",
    "title": "GHI Bootloader",
    "keywords": "GHI Bootloader The GHI Bootloader is used to update the firmware on our devices. It is the first program to run and unless the device specific LDR pins are set (see device documentation for details), it will execute the firmware on the device (if present). The bootloader communicates over a USB virtual serial port and a regular serial port. The interface used is controlled by a MODE pin. See your device specifications for details on interface configuration and selection and which version of the bootloader it runs. Tip If you are running Windows 7 or Windows 8, you must install drivers for the bootloader to appear in Windows. See \"USB Drivers\" in the downloads section . Bootloader v2 All commands and results are terminated with CR and LF (\\r\\n). \"OK.\" will be sent after each successful command. On startup, a banner is sent that is terminated by \"OK.\". Once the banner is received, you are free to enter any of the case-insensitive single-character commands described below. Most commands require confirmation. Send Y or y followed by a new-line to proceed or anything else to cancel. V: returns the current version. N: returns the current device type. E: erases all user sectors of the device. R: runs the firmware if present. B: increases the baud rate in serial mode to 921,600. X: upload a ghi file to the device using 1K XMODEM. Only send *.ghi files meant for your device. U: upload a glb file to the device using 1K XMODEM. Only send *.glb files meant for your device. Loading the Firmware The individual product pages include further instructions on the firmware needed and how to set the board in the loader mode. Once you have downloaded the firmware and set the board in loader mode, use the instructions below to load the firmware. Using TinyCLR Config TinyCLR Config tool includes multiple features developers need to work with TinyCLR OS-enabled devices. It simplifies the firmware update and it includes options for accessing the TinyCLR firmware at runtime. Using this tool is the recommended path; however, manual installation instructions are also included on this page. Read more on the TinyCLR Config page. Manually Loading the Firmware TinyCLR Config tool should be used to update the firmware. As a backup, use these instructions: Put your board in bootloader mode. Each product has a specific way to enter the boot loader. Open any terminal software, for example Tera Term . Select serial and pick the COM port associated with your board. (If unsure, check Device Manager) Press V and then enter. You will see back the boot loader version number (v2.x.x) Press U or X and then enter. Use X for firmware file type GHI and U for firmware file type GLB. Press Y to confirm then enter. You will now see CCCC ... Go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the firmware file. When the transfer is complete, reset your board. GLB File Format The glb files that are loaded onto devices have some additional metadata that help the bootloader function in addition to the raw data itself. The first 1,024 bytes of a glb file is the upload header. Starting from offset 0 are the below fields. The rest of the header is currently reserved. 32 bit signature number that is unique for each device. 32 bit unsigned address in flash that this image should be copied to. 32 bit unsigned length of the image to flash rounded to the nearest 1,024 bytes. 16 bit CRC-CCITT of the image. After the upload header is the actual image to flash. If its length is not divisible by 1,024 bytes, it is padded until it is. For images that are meant to be bootable, the address in the upload header should be set to the entry point defined for the specific device. Bootable images have an additional 1,024 byte header at the beginning of the image that is used to verify the image before booting it. The boot image is also padded to the nearest 1,024 bytes. Starting from offset 0 are the below fields. The rest of the header is currently reserved. 32 bit signature number that is unique for each device. 32 bit unsigned address in flash that is the entry point the bootloader will invoke. 32 bit unsigned length of the boot image rounded to the nearest 1,024 bytes. 16 bit CRC-CCITT of the boot image bounded by the specified address and length. Bootloader v1 Currently the Embedded Master, EMX, G120, G120E and USBizi ship with this version of the bootloader. All results are terminated with LF (\\n). Commands are executed as soon as they entered without waiting for a new-line. \"BL\" or \"Done.\" will be sent after each command. On startup, a banner is sent that is terminated by \"BL\". Once the banner is received, you are free to enter any of the case-sensitive single-character commands described below. V: returns the current version. E: erases all user sectors of the device (* is sent while erasing). R: runs the firmware if present. B: increases the baud rate in serial mode to 921,600. X: upload a file to the device using 1K XMODEM. Only send *.ghi files meant for your device. The firmware is automatically run after a successful upload. Tip The USB interface on Version 1.0 doesn't always work on Windows 7 and newer operating systems. Use the serial interface instead. Upgrading GHI Bootloader v1 to v2 Some of our devices ship with v1 loader but require v2 loader to work with TinyCLR OS, such as G120. Download the bootloader file from the list below. Put your device in v1 mode (instructions are found on each product's documentation page). The PC will now detect a virtual serial (COM) device. If you need drivers, they are in the NETMF SDK. Open any terminal software, we recommend Tera Term . Select serial and pick the COM port associated with your board. Enter E and you will see back \"Erase all memory! Are you sure?\" now enter Y . (The bootloader is case sensitive) Enter X and you will see CCCC ... showing on the terminal. Now go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the bootloader file you have downloaded above. You will see File Transfer Finished Successfully . Change the configuration switches back to the off position and reset the board. You are now running GHI Electronics bootloader v2! Bootloader Downloads Most products already ship with bootloader already installed. But in case the loader needs to be reloaded, the individual product pages include instructions on how to load the bootloader. Here you can find the various bootloaders available for the various products. FEZCLR (used on FEZ and BrainPad) File Date Status MD5 v2.0.4 2017-08-31 Alpha 33F7FCAE266D07209C079CEA38AAB583 v2.0.3 2017-07-07 Alpha 056919694D6A5F06546F9B721AE141CE UC2550 File Date Status MD5 v2.0.4 2018-04-05 Alpha 692FA78A161BAA2AEF17E9F85A6AF141 UC5550 File Date Status MD5 v2.0.5 2018-09-28 Alpha 9F4DB868E5501773CC52048D8085B8D6 v2.0.4 2018-04-05 Alpha 594744A52EC07CEFE6212669D33A5FE1 G120 and G120E File Date Status MD5 v2.0.4 2017-08-31 Alpha 7052D6FFB1890987DDCC4043895788D3 v2.0.2 2017-03-07 Alpha 00ECD55A24607336863B1D61B91C3D86 G400S and G400D File Date Status MD5 v2.0.4 2017-09-13 Alpha BD46D86D41DCD42C4FC50D27AF02E5EE v2.0.2 2017-04-06 Alpha 81D45A8F078AA8E633C824C7BB3279DC v2.0.1 2016-06-27 Alpha 42CD50E4105939611ABF360475EBF4E5 USBizi File Date Status MD5 v1.0.7 144 2015-05-05 Production 853557479D8797EAB650B98E3D333DCF v1.0.7 100 2015-05-05 Production 34D17AA5CA4E13D5447C80AB8094D064 USB Drivers Only needed for Windows 7 and 8 since they do not automatically load drivers for the bootloader interface. File Date Status MD5 v1.0.0 x64 2018-12-27 Production 74D66FC4236126A83CCCFE28D556F339 v1.0.0 x86 2018-12-27 Production 8BDE68132452E22B14597C0972ABA8FD v0.6.0 x64 2017-08-31 Alpha AEDD7C00854BBF99AC3FDAB4976E1F33 v0.6.0 x86 2017-08-31 Alpha A0F487D32B882199F0A69E6CAA8DE4CB"
  },
  "hardware/duino/fez-domino.html": {
    "href": "hardware/duino/fez-domino.html",
    "title": "FEZ Domino",
    "keywords": "FEZ Domino Resources Schematic Software For information on programming the FEZ Domino, please go to the USBizi page."
  },
  "hardware/breakout/intro.html": {
    "href": "hardware/breakout/intro.html",
    "title": "Breakout",
    "keywords": "Breakout We offer breakout boards for all of our SoMs to speed the path to programming and product development. All of these boards offer through hole connections which accept standard 0.10 inch headers. Some boards also offer surface mount edge connections which are ideal for short production runs."
  },
  "hardware/breakout/fez-cobra.html": {
    "href": "hardware/breakout/fez-cobra.html",
    "title": "FEZ Cobra",
    "keywords": "FEZ Cobra Resources Schematic Software For information about programming the FEZ Cobra, please visit our EMX page."
  },
  "hardware/intro.html": {
    "href": "hardware/intro.html",
    "title": "Hardware",
    "keywords": "Hardware UCMs (Universal Compute Modules) Interchangeable plug-in microcontroller modules suitable for a wide variety of applications. Learn More... SCMs (Surface Compute Modules) Surface mount microcontroller modules ideal for harsh or high vibration environments. Learn More... FEZ The Maker Board to Rule Them All! Learn More... File System Technical details and manuals for the File System products. Learn More... Bootloaders Learn more... Legacy Products Here you will find information on GHI's legacy products and longevity policy. Learn More... You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/tinyclr/tutorials/graphics/drawing.html": {
    "href": "software/tinyclr/tutorials/graphics/drawing.html",
    "title": "Drawing",
    "keywords": "Drawing The GHIElectronics.TinyCLR.Drawing NuGet package includes the backbone for all graphics needs. It includes support for shapes, fonts and bitmaps. Shape examples are Graphics.FillEllipse , Graphics.DrawLine and Graphics.DrawRectangle . These methods need Pen and Brush that are also part of Graphics . TinyCLR OS has built in graphics methods for these displays. The following sample code runs on our UCM Dev Board with the UD435 Display option. You will need to add the GHIElectronics.TinyCLR.Drawing , GHIElectronics.TinyCLR.Devices.Gpio and GHIElectronics.TinyCLR.Pins NuGet package to your program. The GPIO in this example is only used to control the display's backlight. Note that the backlight is on GPIO A on the UCM Dev Board. using System.Drawing; using GHIElectronics.TinyCLR.Devices.Display; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { private static void Main() { UCMStandard.SetModel(UCMModel.UC5550); // Change to your specific board. var backlight = GpioController.GetDefault().OpenPin(UCMStandard.GpioPin.A); backlight.SetDriveMode(GpioPinDriveMode.Output); var displayController = DisplayController.GetDefault(); // Enter the proper display configurations for the UD435 displayController.SetConfiguration(new ParallelDisplayControllerSettings { Width = 480, Height = 272, DataFormat = DisplayDataFormat.Rgb565, HorizontalBackPorch = 46, HorizontalFrontPorch = 16, HorizontalSyncPolarity = false, HorizontalSyncPulseWidth = 1, DataEnableIsFixed = false, DataEnablePolarity = false, PixelClockRate = 12_000_000, PixelPolarity = false, VerticalBackPorch = 23, VerticalFrontPorch = 7, VerticalSyncPolarity = false, VerticalSyncPulseWidth = 1 }); displayController.Enable(); backlight.Write(GpioPinValue.High); // Some needed objects var screen = Graphics.FromHdc(displayController.Hdc); var greenPen = new Pen(Color.Green, 5); var redPen = new Pen(Color.Red, 3); // Start Drawing (to memory) screen.Clear(Color.Black); screen.DrawEllipse(greenPen, 40, 30, 80, 60); screen.DrawLine(redPen, 0, 0, 479, 271); // Flush the memory to the display. This is a very fast operation. screen.Flush(); } } The DisplayController.ActiveConfiguration can be used to read the configuration at any time. The Width and Height can be used to write code that automatically scales to the display's resolution. The example above can be changed to automatically draw a line from corner to corner, no matter the display resolution. screen.DrawLine(redPen, 0, 0, displayController.ActiveConfiguration.Width-1, displayController.ActiveConfiguration.Height-1); It is important to note that drawing functions process graphics in RAM independently from any display. The display driver then transfers the pixels from the internal memory to the display, through Graphics.Flush . Learn more about the display support. Images TinyCLR OS supports BMP, GIF, and JPG. Depending on your hardware's limitation, one or more of these image formats maybe supported. Images can be loaded from a stream or simply load from resources . Tip BMP supports 256 colors and 24bit. GIF does not support animated images. var screen = Graphics.FromHdc(displayController.Hdc); var logo = Resource.GetBitmap(Resource.BitmapResources.GHI_Electronics_Logo); screen.DrawImage(logo, 50, 150); screen.Flush(); Fonts Fonts are well supported. They are covered here ."
  },
  "software/tinyclr/tutorials/graphics/display.html": {
    "href": "software/tinyclr/tutorials/graphics/display.html",
    "title": "Display",
    "keywords": "Display Graphical Displays can be grouped into two distinct interface categories, parallel TFT displays and serial (SPI/I2C) displays. There are also non-graphical character displays. The display drivers are meant to transfer the pixel data from memory to the actual display. The drawing tutorial shows how drawing is done, in memory. Parallel TFT Displays These displays connect to special dedicated pins on the processor. Internally, the display controller automatically transfers (refreshes) the display directly from memory without any processor interaction, using DMA. When the system needs to update the display, it simply writes to memory. Neither the operating system nor the application program are burdened with display processing. The down side to this is that the system needs to have enough RAM to handle the display. An 800x600 display with 16bpp needs 960,000 bytes! Serial SPI/I2C Displays The internal graphics services can be mapped to work with serial displays. This is done by having access directly to the graphics memory, which then can be transfered to the desired display. As each display has its own pixel format and color depth, you also have access to the way pixels are written in the graphics memory. This blog details how this can be accomplished. Character Displays These displays are capable of only showing characters. The most commonly use the HD44780 controller. They are available in different sizes but 2x16 character is most common. These displays only require GPIO pins and can be used with TinyCLR. Low Level Display Access TinyCLR also provides low level display access as part of the GHIElectronics.TinyCLR.Devices.Display library. These methods provide a simple way to write to a display without need for the System.Drawing library or an added font resource file. The following example is written for the G120E Dev Board and will paint the screen as shown in the picture beneath the code. Note that low level display access requires that you to use the data format required by your display as configured. The G120E Dev Board used in this example expects each pixel to have 16 bits (two bytes per pixel) of color information in RGB565 format. using GHIElectronics.TinyCLR.Devices.Display; class Program { private static void Main() { var displayController = DisplayController.GetDefault(); // Enter the proper display configurations displayController.SetConfiguration(new ParallelDisplayControllerSettings { Width = 320, Height = 240, DataFormat = DisplayDataFormat.Rgb565, HorizontalBackPorch = 29, HorizontalFrontPorch = 51, HorizontalSyncPolarity = false, HorizontalSyncPulseWidth = 41, DataEnableIsFixed = true, DataEnablePolarity = true, PixelClockRate = 15000000, PixelPolarity = true, VerticalBackPorch = 3, VerticalFrontPorch = 16, VerticalSyncPolarity = false, VerticalSyncPulseWidth = 10 }); displayController.Enable(); byte[] myPic = new byte[320 * 240 * 2]; for (var i = 0; i < myPic.Length; i++) { myPic[i] = (byte)(((i % 2) == 0) ? ((i / 2400) & 0b00000111) << 5 : i / 19200); } displayController.DrawString(\"\\f\"); displayController.DrawBuffer(0, 0, 320, 240, myPic, 0); displayController.DrawString(\"GHI Electronics\\n\"); displayController.DrawString(\"Low Level Display Demo.\"); for (var x = 20; x < 300; x++) { displayController.DrawPixel(x, 50, 0xF800); //Color is 31,0,0 (RGB565). displayController.DrawPixel(x, 51, 0xF800); } } } G120E Dev Board display after running the sample code:"
  },
  "software/netmf/tutorials/xml.html": {
    "href": "software/netmf/tutorials/xml.html",
    "title": "XML",
    "keywords": "XML Introduction Extensible Markup Language (XML) is a standard for containing data. When you want to transfer some info between two devices, you can set some rules on how the data is to be packed and sent from device A. On the other side, device B receives the data and knows how to unpack it. Before XML, this created some difficulties. What if you were sending the data to a system implemented by a different designer? You would have to explain how you packed your data so the other designer can unpack it. With XML, the design is transmitted with the data. XML is extensively used. For example, when a website's shopping cart wants to know the shipping cost on a certain package, it will pack the shipment details in XML format and then send to FedEx. The FedEx website will read the info and send the cost info back in XML format as well. The usefulness of XML can also be utilized in other ways. Let's say you are designing a data logger. Let's also assume the end users will need to configure the data logger to fit their needs. When a user configures the device, you need to store the info internally somehow. You can save the data with your own format which requires extra coding and debugging, or better just use XML. All GHI Electronics NETMF devices have a built-in XML reader and writer (packer and un-packer ). Here is an example XML file that will help in our data logger design. <?xml version=\"1.0\" encoding=\"utf-8\" ?> <NETMF_DataLogger> <FileName>Data</FileName> <FileExt>txt</FileExt> <SampleFreq>10</SampleFreq> </NETMF_DataLogger> This XML example includes a root element and three child elements. XML is very flexible, for instance all info in the example could have been defined as root elements. The root element \"NETMF_DataLogger\" contains three pieces of info that are important for our logger. It contains the file name, the file extension and a frequency of our saved data. With this example, the logger will create a file called Data.txt and then will log data into that file 10 times every second. Spaces and layout do not mean anything to XML, we (humans) need them to make things easier to read. The previous example can be stored without the spaces and layout like this. <?xml version=\"1.0\" encoding=\"utf-8\" ?><NETMF_DataLogger><FileName>Data</FileName> <FileExt>txt</FileExt><SampleFreq>10</SampleFreq></NETMF_DataLogger> See why spaces are important to us human being! You can also add comments inside XML files, comments do not mean anything to XML but can help in manual reading of the files <?xml version=\"1.0\" encoding=\"utf-8\"?> <!--This is just a comment--> <NETMF_DataLogger> <FileName>Data</FileName> <FileExt>txt</FileExt> <SampleFreq>10</SampleFreq> </NETMF_DataLogger> Finally, XML support attributes. An attribute is an extra info given to an element. Alternatively, you can add another element to describe the extra information. The choice is yours. Attributes are not explained in this document; there are many excellent tutorials and examples on the internet. GHI Electronics' NETMF devices support reading and writing XML format. Reading and writing XML files work over streams which means any stream you already have or implement can work with XML. For example, we will use the built-in MemoryStream and FileStream. The examples shown below require the following assemblies: System.IO, System.Xml, MFDpwsExtensions. XML in Memory This code shows how to make an XML document in memory, it implements the XML presented above. using System.IO; using System.Xml; using System.Ext.Xml; using Microsoft.SPOT; public class Program { public static void Main() { MemoryStream ms = new MemoryStream(); XmlWriter xmlwrite = XmlWriter.Create(ms); xmlwrite.WriteProcessingInstruction(\"xml\", \"version=\\\"1.0\\\" encoding=\\\"utf-8\\\"\"); xmlwrite.WriteComment(\"This is just a comment\"); xmlwrite.WriteStartElement(\"NETMF_DataLogger\");//root element xmlwrite.WriteStartElement(\"FileName\");//child element xmlwrite.WriteString(\"Data\"); xmlwrite.WriteEndElement(); xmlwrite.WriteStartElement(\"FileExt\"); xmlwrite.WriteString(\"txt\"); xmlwrite.WriteEndElement(); xmlwrite.WriteStartElement(\"SampleFeq\"); xmlwrite.WriteString(\"10\"); xmlwrite.WriteEndElement(); xmlwrite.WriteEndElement();//end the root element xmlwrite.Flush(); xmlwrite.Close(); //////// display the XML data /////////// byte[] byteArray = ms.ToArray(); char[] cc = System.Text.UTF8Encoding.UTF8.GetChars(byteArray); string str = new string(cc); Debug.Print(str); } } When you try to add an assembly you will notice that there are two assemblies for XML, the \"System.Xml\" and \"System.Xml.Legacy\". Do not use the \"legacy\" driver, it is there for older NETMF devices with systems that did not have built-in support for XML. If the \"Unsupported Exception\" is raised on an older device, replace the System.Xml assembly with System.Xml.Legacy Readable Output When running the example above, we will see the output XML data at the end. The data is correct but it is not formatted to be \"human\" friendly. Note that we are reading and writing XML files on a very small system so the less info (spaces/formatting) the better it is. So it is actually better not to have any extra spaces or formatting but for the sake of making things look pretty, we will add new lines as follows using System.IO; using System.Xml; using System.Ext.Xml; using Microsoft.SPOT; public class Program { public static void Main() { MemoryStream ms = new MemoryStream(); XmlWriter xmlwrite = XmlWriter.Create(ms); xmlwrite.WriteProcessingInstruction(\"xml\", \"version=\\\"1.0\\\" encoding=\\\"utf-8\\\"\"); xmlwrite.WriteComment(\"This is just a comment\"); xmlwrite.WriteRaw(\"\\r\\n\"); xmlwrite.WriteStartElement(\"NETMF_DataLogger\");//root element xmlwrite.WriteString(\"\\r\\n\\t\"); xmlwrite.WriteStartElement(\"FileName\");//child element xmlwrite.WriteString(\"Data\"); xmlwrite.WriteEndElement(); xmlwrite.WriteRaw(\"\\r\\n\\t\"); xmlwrite.WriteStartElement(\"FileExt\"); xmlwrite.WriteString(\"txt\"); xmlwrite.WriteEndElement(); xmlwrite.WriteRaw(\"\\r\\n\\t\"); xmlwrite.WriteStartElement(\"SampleFeq\"); xmlwrite.WriteString(\"10\"); xmlwrite.WriteEndElement(); xmlwrite.WriteRaw(\"\\r\\n\"); xmlwrite.WriteEndElement();//end the root element xmlwrite.Flush(); xmlwrite.Close(); //////// display the XML data /////////// byte[] byteArray = ms.ToArray(); char[] cc = System.Text.UTF8Encoding.UTF8.GetChars(byteArray); string str = new string(cc); Debug.Print(str); } } Reading and Parsing Creating XML files is actually easier than parsing (reading) them. There are many ways to read the XML file but basically you can just go through the file and read one piece at the time till you reach the end. This code example creates an XML data and it reads it back. using System.IO; using System.Xml; using System.Ext.Xml; using Microsoft.SPOT; public class Program { public static void Main() { MemoryStream ms = new MemoryStream(); XmlWriter xmlwrite = XmlWriter.Create(ms); xmlwrite.WriteProcessingInstruction(\"xml\", \"version=\\\"1.0\\\" encoding=\\\"utf-8\\\"\"); xmlwrite.WriteComment(\"This is just a comment\"); xmlwrite.WriteRaw(\"\\r\\n\"); xmlwrite.WriteStartElement(\"NETMF_DataLogger\");//root element xmlwrite.WriteString(\"\\r\\n\\t\"); xmlwrite.WriteStartElement(\"FileName\");//child element xmlwrite.WriteString(\"Data\"); xmlwrite.WriteEndElement(); xmlwrite.WriteRaw(\"\\r\\n\\t\"); xmlwrite.WriteStartElement(\"FileExt\"); xmlwrite.WriteString(\"txt\"); xmlwrite.WriteEndElement(); xmlwrite.WriteRaw(\"\\r\\n\\t\"); xmlwrite.WriteStartElement(\"SampleFeq\"); xmlwrite.WriteString(\"10\"); xmlwrite.WriteEndElement(); xmlwrite.WriteRaw(\"\\r\\n\"); xmlwrite.WriteEndElement();//end the root element xmlwrite.Flush(); xmlwrite.Close(); //////// display the XML data /////////// byte[] byteArray = ms.ToArray(); char[] cc = System.Text.UTF8Encoding.UTF8.GetChars(byteArray); string str = new string(cc); Debug.Print(str); ///////////read xml MemoryStream rms = new MemoryStream(byteArray); XmlReaderSettings ss = new XmlReaderSettings(); ss.IgnoreWhitespace = true; ss.IgnoreComments = false; //XmlException.XmlExceptionErrorCode. XmlReader xmlr = XmlReader.Create(rms,ss); while (!xmlr.EOF) { xmlr.Read(); switch (xmlr.NodeType) { case XmlNodeType.Element: Debug.Print(\"element: \" + xmlr.Name); break; case XmlNodeType.Text: Debug.Print(\"text: \" + xmlr.Value); break; case XmlNodeType.XmlDeclaration: Debug.Print(\"decl: \" + xmlr.Name + \", \" + xmlr.Value); break; case XmlNodeType.Comment: Debug.Print(\"comment \" +xmlr.Value); break; case XmlNodeType.EndElement: Debug.Print(\"end element\"); break; case XmlNodeType.Whitespace: Debug.Print(\"white space\"); break; case XmlNodeType.None: Debug.Print(\"none\"); break; default: Debug.Print(xmlr.NodeType.ToString()); break; } } } }"
  },
  "software/netmf/tutorials/watchdog.html": {
    "href": "software/netmf/tutorials/watchdog.html",
    "title": "Watchdog",
    "keywords": "Watchdog Introduction In the embedded system world, devices are usually always running and with no user interaction. So if something went wrong, it would be very beneficial if we have an automatic reset button. Watchdog is your reset button! Assume you are making a smart vending machine that reports its inventory over the network. If your code raises an exception that wasn't handled properly then your program will end. Program ended means the vending machine will no longer work. Someone will have to drive to the vending machine to reset it! The alternative is to use the watchdog. When watchdog is enabled, it is given a timeout where it will reset the system if the time reached without resetting the timeout. This is like saying \"reset the system in 5 seconds\" then the program goes on to do something. The program needs to come back and reset the time and say \"reset in 5 seconds\". If the program keeps doing this, the system will never reset. But if the program got stuck somewhere, the 5 seconds will end causing the system to reset. Tip GHI does not use the NETMF's built in services for watchdog, but uses its own. Use the GHI.Hardware assembly when using watchdog. Warning Do NOT set the Watchdog reset time too short during the debug phase. If it is shorter than the time taken to deploy your code then your device will reboot and the new code never gets loaded. The only way to get out of the problem is to erase the device and reflash the firmware. We advice not to use watchdog during development and debugging. Max Timeouts The following lists shows the max timeout value for watchdog on our various devices in milliseconds. Do note that for G120 and EMX, there is roughly a 30% margin of error around the max value where the device may still reset. G400: 15,995 G120: 134,217 EMX: 4,294,967 Cerberus: 32768 Five Second Watchdog This example shows how to set the watchdog to 5 seconds timeout and create a thread to clear the watchdog every 3 seconds. Should anything go wrong and the thread that clears the watchdog isn't able the run due to another thread using all of the available resources, the device will reset in 5 seconds. Tip Once you enable the Watchdog, it cannot be disabled. So you have to keep resetting the timeout. This is done to assure that no system corruption will disable watchdog accidentally. using System; using System.Threading; using GHI.Processor; public class Program { public static void Main() { // Timeout 5 seconds int timeout = 1000 * 5; // Enable Watchdog Watchdog.Enable(timeout); // Start a time counter reset thread WDTCounterReset = new Thread(WDTCounterResetLoop); WDTCounterReset.Start(); // .... // your program starts here // If we exit the program, // the thread will stop working and the system will reset! Thread.Sleep(Timeout.Infinite); } static Thread WDTCounterReset; static void WDTCounterResetLoop() { while (true) { // reset time counter every 3 seconds Thread.Sleep(3000); Watchdog.ResetCounter(); } } } You may be thinking, if the software locked up then how would the code that handles watchdog ever run? It works because the watchdog is supported in hardware not software. This means that the counter and the reset mechanism are done inside the processor, without the need for any software. Detecting Watchdog In some cases, you need to know if the system did reset because of a watchdog to log this info or run some recovery procedures. This is how it works using System; using System.Threading; using Microsoft.SPOT; using GHI.Processor; public class Program { public static void Main() { // Normally, you can read this flag ***ONLY ONCE*** on power up if (Watchdog.LastResetCause == Watchdog.ResetCause.Watchdog) { Debug.Print(\"Watchdog did Reset\"); } else { Debug.Print(\"Reset switch or system power\"); } } }"
  },
  "software/netmf/tutorials/spi.html": {
    "href": "software/netmf/tutorials/spi.html",
    "title": "SPI",
    "keywords": "SPI SPI uses three, sometimes four, wires for transferring data. The bus on SPI consists of one master and one or more slaves. The master will send clock to the salves along with data and will read back using the same clock. This clock is used to determine how fast the data is moved. If you know electronics, this is a shift register. So, the master will transmit a clock on a SCK (serial clock) pin and will simultaneously transmit the data on MOSI (Master Out Slave In) pin. The slave will read the clock on SCK pin and simultaneously read the data from MOSI pin. So far, this is a one way communication. While data is transmitted in one direction using MOSI another set of data is sent back on MISO (Master In Slave Out) pin. Other data sizes are possible but bytes are most common. NETMF supports 8-bit (byte) and 16-bit (short) data transfers. Because of this master/slave scheme, we can add multiple slaves on the same bus where the master selects which slave it will swap the data with. Note I am using the word swap because you can never send or receive but you always send and receive (swap) data. The master selects one of the slaves using SSEL (Slave Select) pin. This pin can be called CS (Chip Select) as well. In theory, the master can have unlimited slaves but it can only select one of them at any given time. The master will only need 3 wires (SCK, MISO, MOSI) to connect to all slaves on the bus but then it needs a separate SSEL pin for each one of the slaves. Some SPI devices (slaves) can have more than one select pin, like VS1053 MP3 decoder chip that uses one pin for data and one pin for commands but both share the 3 data transfer pins (SCK, MOSI, MISO). SPI needs more wires than other similar buses but it can transfer data very fast. A 50Mhz clock is possible on SPI, that is 50 million bits in one second. Note that NETMF devices are always SPI masters, not slaves. Before creating a SPI object, we would need a SPI configuration object. The configuration object is used to set the states of the SPI pins and some timing parameters. In most cases, you need the clock to be idle low (false) with clocking on rising edge (true) and with zero for select setup and hold time. The only thing you would need to set is the clock frequency. Some devices may accept high frequencies but others do not. Setting the clock to 1000Khz (1Mhz) should be okay for a starter Getting Started This example is sending/receiving 10 bytes of data on SPI channel 1. Note: NETMF start numbering SPI channels (module) from 1, but on processors the channels start from 0 typically. So, using SPI1 in code is actually using SPI0 on the processor. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { SPI.Configuration MyConfig = new SPI.Configuration(Cpu.Pin.GPIO_Pin1, false, 0, 0, false, true, 1000, SPI.SPI_module.SPI1); SPI MySPI = new SPI(MyConfig); byte[] tx_data = new byte[10]; byte[] rx_data = new byte[10]; MySPI.WriteRead(tx_data, rx_data); Thread.Sleep(100); } } Accessing Multiple Devices The SPI object on NETMF is a representation of the \"bus\" and not the \"device\", so you can't construct multiple SPI objects, unless it uses a different SPI bus. To access multiple SPI devices you need to have multiple configurations and then when accessing device \"A\" we need to use configuration \"A\" and when accessing device \"B\" we need to use configuration \"B\". using Microsoft.SPOT.Hardware; public class Program { public static void Main() { SPI.Configuration ConfigDeviceA = new SPI.Configuration(Cpu.Pin.GPIO_Pin1, false, 0, 0, false, true, 1000, SPI.SPI_module.SPI1); SPI.Configuration ConfigDeviceB = new SPI.Configuration(Cpu.Pin.GPIO_Pin4, false, 0, 0, false, true, 1000, SPI.SPI_module.SPI1); SPI MySPI = new SPI(ConfigDeviceA); byte[] tx_data = new byte[10]; byte[] rx_data = new byte[10]; // accessing device A MySPI.Config = ConfigDeviceA; MySPI.WriteRead(tx_data, rx_data); // accessing device B MySPI.Config = ConfigDeviceB; MySPI.WriteRead(tx_data, rx_data); } }"
  },
  "software/netmf/tutorials/signal-generator.html": {
    "href": "software/netmf/tutorials/signal-generator.html",
    "title": "Signal Generator",
    "keywords": "Signal Generator Introduction SignalGenerator is non-blocking digital waveform generator. SignalGenerator works by comparing an internal counter to an array of time values, one by one; when the value of the argument matches the counter, the output pin is changed. The values are in microseconds. SignalGenerator can also be used to generate PWM; unlike the PWM class, SignalGenerator can be used to generate PWM on any available output pins; however, it uses a processor time, the higher the frequency the more processing it uses. SignalGenerator can operate in two modes: non-blocking: runs in the background using system interrupts, and blocking: which does block (while it is running, it does not yield time to other code). This mode has higher accuracy (used, for example, to generate carrier frequencies for infrared signals). Blinking LED This example uses an array of toggle times to turn the LED on and off. The state of the the pin controlled by SignalGenerator will change after waiting for the durations specified in an array. Onces all the elements have been used; SignalGenerator will, optionally, start over at the beginning of the array. using Microsoft.SPOT.Hardware; using GHI.IO; public class Program { public static void Main() { uint[] time = new uint[] { 500 * 1000, 500 * 1000 }; SignalGenerator LED = new SignalGenerator(Cpu.Pin.GPIO_Pin1, false); // args: initial value, // array of times, // array start offset, // length of array, // repeat -- if true ==> repeat LED.Set(false, time, 0, 2, true);//start the waveform //... do more code here and the LED will continue to work. //... because the default running mode is non-blocking. } }"
  },
  "software/netmf/tutorials/pwm.html": {
    "href": "software/netmf/tutorials/pwm.html",
    "title": "PWM",
    "keywords": "PWM PWM is used to control of the ratio of a pin's high and low state, the \"duty cycle.\" This can be done using software or using built-in PWM pins on the processor. PWM pins have the advantage over Software PWM because the toggling is independent of the CPU. Software PWM is performed using the SignalGenerator class. PWM objects are constructed with the period and duration of the pulse. The duration is how long the pin is high or active while the period is the time between one duration and the next. \"Duty Cycle\" is the ratio of the duration and the period -- as a convenience, a scale can be set. The scale is applied to the numbers assigned to the PWM's properties. A pin with duty cycle 0.5 will be high half the time and low the other half. Some common uses of PWM: control the intensity of lights and the speed of motors by changing the duty-cycle. generate audio tones by keeping the duty-cycle at 50% and changing the frequency. positioning of a servo by using a pulse with a specific duration or width. .NET Micro Framework PWM Channels In NETMF, the PWM pins are defined in the \"Cpu.PWMChannel\" enumeration. As the enumeration has a limited number of members, the number of PWM pins may exceed the members. Casting can be used for those extra PWMs. // Using the enumeration PWM MyServo = new PWM(Cpu.PWMChannel.PWM_3, 2175, 175, PWM.ScaleFactor.Microseconds, false); // Lots of PWMs on processor, use a cast to access an extra PWM PWM LED = new PWM((Cpu.PWMChannel)9, 10000, 0.10, false); > [!Tip] > The examples shown below require the Microsoft.SPOT.Hardware.PWM assembly; > [!Warning] > Some or all PWM pins share the same timers internally. This means the changing frequency on one pin will also effect the others. However, the duty cycle can be different on all pins. Users needing to determine which pins share the same timer have two options. Either use trial and error on all PWM pins or check the processor manual. ## Controlling LEDs Brightness This example starts the LED at 0% intensity then slowly steps up to full intensity, after which it reverts to 0% and starts over. ```cs using System.Threading; using Microsoft.SPOT.Hardware; public class Program { static PWM MyFader = new PWM(Cpu.PWMChannel.PWM_0, 10000, 0.1, false); public static void Main() { double i = 0.0; while (true) { MyFader.DutyCycle = i; /* DutyCycle is not dynamic so make a call to * Start() to refresh the object */ MyFader.Start(); if ((i += 0.1) >= 1.0) { i = 0.0; } Thread.Sleep(10); } } } Musical Tones Music notes have specific frequencies, for example C is about 261Hz. Plugging these numbers into an array and knowing the length of each tone is all that is needed to play some simple music. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { const int NOTE_C = 261; const int NOTE_D = 294; const int NOTE_E = 330; const int NOTE_F = 349; const int NOTE_G = 392; const int WHOLE_DURATION = 1000; const int EIGHTH = WHOLE_DURATION / 8; const int QUARTER = WHOLE_DURATION / 4; const int QUARTERDOT = WHOLE_DURATION / 3; const int HALF = WHOLE_DURATION / 2; const int WHOLE = WHOLE_DURATION; //make sure the two below arrays match in length. each duration element corresponds to //one note element. static int[] note = { NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_E, NOTE_D, NOTE_D, NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_D, NOTE_C, NOTE_C}; static int[] duration = { QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, HALF, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, WHOLE}; public static void Main() { PWM MyPWM = new PWM(Cpu.PWMChannel.PWM_3, 261, 0.50, false); while (true) { for (int i = 0; i < note.Length; i++) { MyPWM.Stop(); MyPWM.Frequency = note[i]; MyPWM.Start(); Thread.Sleep(duration[i]); } Thread.Sleep(100); } } } Servos For the servo in this example, if the pulse width is about 1.25ms then the servo is at 0 degrees. Increasing the pulse width to 1.50ms will move the servo to 90 degrees (neutral). A wider pulse of 1.75ms will move the servo to 180 degrees. Servos expect a pulse every 20ms to 30ms. It is important for the high pulse to be between 1.25ms and 1.75ms so that the servo's position is set properly. The code below will move the position of the servo to 180 degrees (using a pulse of 1.75ms). It uses a pause time between pulses of 20ms. So the period is 21.75ms and a duration of 1.75ms. Note the use of \"scale\". using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { PWM MyServo = new PWM(Cpu.PWMChannel.PWM_3, 2175, 1750, PWM.ScaleFactor.Microseconds, false); while (true) { // 0 degrees. 20ms period and 1.25ms high pulse MyServo.Duration = 1250; MyServo.Period = 20000; MyServo.Start(); Thread.Sleep(1000); // 90 degrees. 20ms period and 1.50ms high pulse MyServo.Duration = 1500; MyServo.Period = 20000; MyServo.Start(); Thread.Sleep(1000); // 180 degrees. 20ms period and 1.75ms high pulse MyServo.Duration = 1750; MyServo.Period = 20000; MyServo.Start(); Thread.Sleep(1000); } } }"
  },
  "software/netmf/tutorials/pulse-feedback.html": {
    "href": "software/netmf/tutorials/pulse-feedback.html",
    "title": "Pulse Feedback",
    "keywords": "Pulse Feedback Introduction The PulseFeedback class can be found in the GHI.Hardware assembly and can be used in three different modes. The first mode is EchoDuration. This mode sends a pulse of a given length and state over the provided pin. It then waits for an echo on the other specified pin and measures how long in microseconds that echo pulse was. The echo and pulse pin can be the same if required. The next mode is DurationUntilEcho. It is very similar to EchoDuration, though instead of sending a pulse and measuring the length of the resulting echo, it measures how long it takes until that echo is received. The below example illustrates sending a pulse of 10us and reading an echo on the same pin where both the pulse and echo are high. A constructor overload is available that allows you to specify a different echo pin and state. using GHI.IO; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; using System.Threading; public class Program { public static void Main() { var pulse = new PulseFeedback(PulseFeedback.Mode.EchoDuration, true, 10, Cpu.Pin.GPIO_NONE); while (true) { Debug.Print(pulse.Read().ToString()); Thread.Sleep(250); } } } Measuring Capacitance The final mode is DrainDuration. This mode is often used in capacitive touch. When calling Read, the pulse line will be held in the specified state for the specified length and then is set to an input. When a resistor and capacitor are connected to this pin and ground, the pin will fall to ground after a short period of time dependent on the capacitance on the pin. The below image shows a sample circuit. Do note that this mode can only be used with a single pin. The exact values of the capacitor and resistor will depend on your setup. Generally a resistor in the megaohm range and a capacitor in the low picofarads in acceptable. Pin Example This image shows an example pin capture for each of the modes. It is not drawn to scale. The area marked by the arrows is the time measured for each mode. Remember that the pulse and echo may be on separate pins. Timeouts A call to Read will block until the expected pin state has occurred or the timeout has expired. In the latter case, -1 will be returned. The ReadTimeout property controls this."
  },
  "software/netmf/tutorials/digital-inputs.html": {
    "href": "software/netmf/tutorials/digital-inputs.html",
    "title": "Digital Inputs",
    "keywords": "Digital Inputs Digital inputs sense if the state of its pin is high or low based on the voltage. Every pin has a maximum & minimum supported voltages. For example, the typical minimum voltage on most pins is 0 volts -- a negative voltage may damage the pin or the processor. Also, the maximum that can be supplied to most pins must be less than the processor power source voltage. Since most processors run on 3.3V, the highest voltage a pin should see is 3.3V; however, some processors that are powered by 3.3V are 5V tolerant and are capable of accepting up to 5V on their inputs. Check the product's or the processor's manual for the tolerance level. Warning 5V-tolerant doesn't mean the processor can be powered by 5V. Only the input pins can tolerate 5V. InputPort An InputPort object is used to handle digital input pins. Most pins on the processor can be input or output. Unconnected input pins are \"floating\". When a pin is an input and is not connected, it is open for any surrounding noise, which can make the pin high or low. To take care of this issue, modern processors include internal weak pull-down or pull-up resistors, that are usually controlled by software. Enabling the pull-up resistor will pull the pin high. Note that the pull-up resistor doesn't make a pin high but it pulls it high. If nothing is connected then the pin is high by default. External resistors can be added as well. In this example, a button is connected between ground and the input pin. We will also enable the pull-up resistor. This means that the pin will be high (pull-up) when button is not pressed and low (connected to ground) when the button is pressed. We will read the status of the button and pass its state to the LED. Note that the pin is high when the button is not pressed (pulled-high) and it is low when the button is pressed. This means the LED will turn off when the button is pressed. The following code requires the Microsoft.SPOT.Hardware assembly. Consult the device schematics or manuals for the proper pin numbers. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { OutputPort LED; InputPort Button; LED = new OutputPort(Cpu.Pin.GPIO_Pin1, true); Button = new InputPort(Cpu.Pin.GPIO_Pin2, false, Port.ResistorMode.PullUp); while (true) { LED.Write(Button.Read()); Thread.Sleep(10); } } } Interrupt Port In the previous example, the program just looped, and looped, and looped -- each time checking the status of the pin attached to the button. The pin is checked maybe a million times before/after the button is pressed! Interrupt ports allows us to set a method that will be executed when the button is pressed (when pin is low for example). We can set the interrupt to fire (call the method) on many state changes on the pin: when a pin is low or maybe when it is high. The most common use is the \"on change.\" The change from low to high or high to low creates a signal edge. The rising edge occurs when the signal rises from low to high. The falling edge happen when the signal falls from high to low. For a more in-depth understanding of the difference between the \"change\" interrupt versus a \"level\" interrupt, use wikipedia -- the two articles of relevance are found by searching for \"Interrupt Port\" and \"edge level transition.\" In the example below, we are using the low edge to detect a button press. \"IntButton_OnInterrupt\" will automatically run when button is pressed. The following code requires the Microsoft.SPOT.Hardware assembly. Consult the device schematic or manual for pin numbers. using Microsoft.SPOT; using Microsoft.SPOT.Hardware; using System; using System.Threading; public class Program { public static void Main() { InterruptPort IntButton = new InterruptPort(Cpu.Pin.GPIO_Pin1, false, Port.ResistorMode.PullUp, Port.InterruptMode.InterruptEdgeLow); IntButton.OnInterrupt += new NativeEventHandler(IntButton_OnInterrupt); // Other code can be added here // ... // We are just going to sleep in this example! Thread.Sleep(Timeout.Infinite); } static void IntButton_OnInterrupt(uint port, uint state, DateTime time) { Debug.Print(\"Button Pressed\"); } } When creating the new InterruptPort object, the second argument indicates whether the glitch filter is enabled (true) or disabled (false). This is typically needed when using the interrupt feature to debounce the button. Not enabling this feature may cause the button to trigger more than one event, even though the button is pressed once. Tip In the event handler, like the one above : ...OnInterrupt(uint port, uint state..., the state argument is the state of the Pin after the edge transition. I.e. on a low to high edge, state will be high (true); likewise for high to low transitions. Tristate Port If we want a pin to be an input and output, what can we do? A pin can never be in and out simultaneously but we can make it output to set something and then make it input to read a response back. One way is to \"Dispose\" of the pin. We make an output port, use it and then dispose it; then we can make the pin input and read it. NETMF supports a better option called a Tristate port. Tristate means three states -- input, output low and output high. One minor issue about tristate pins is that if a pin is set to output and then you set it to output again an exception will occur. One common work-around for this is to check the direction of the pin before changing it. The direction of the pin is in its property \"Active\" where false means input and true is output. The code below requires the Microsoft.SPOT.Hardware assembly. Tip Due to internal design, TristatePorts will only work with interrupt capable digital pins. Warning Be careful not to have the pin connected to a switch then set the pin to output. using System.Threading; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; public class Program { static void MakePinOutput(TristatePort port) { if (port.Active == false) port.Active = true; } static void MakePinInput(TristatePort port) { if (port.Active == true) port.Active = false; } public static void Main() { TristatePort TriPin = new TristatePort(Cpu.Pin.GPIO_Pin6, false, false, Port.ResistorMode.PullUp); MakePinOutput(TriPin); TriPin.Write(true); Debug.Print(\"Write to output pin completed.\"); Debug.Print(\"Changing to input pin\"); MakePinInput(TriPin); Debug.Print(\"The input pin state is: \" + TriPin.Read().ToString()); Thread.Sleep(Timeout.Infinite); } }"
  },
  "software/tinyclr/tutorials/networking/intro.html": {
    "href": "software/tinyclr/tutorials/networking/intro.html",
    "title": "Networking",
    "keywords": "Networking TinyCLR OS Networking support provides socket and HTTP APIs that should be familiar to any .NET developer. Take a look at the .NET docs for samples. The implementation can be found in the GHIElectronics.TinyCLR.Networking and GHIElectronics.TinyCLR.Networking.Http libraries. A low-level hardware-specific driver needs to be implemented. STMicroelectronics SPWF045x A reference implementation is available today for STMicroelectronics SPWF04Sx secure WiFi module. See the SPWF04Sx page for details. Espressif ESP32 and ESP8266 These low-cost WiFi modules have AT command firmware option. The SPWF045x driver can be used as a reference for developing drivers. Ethernet Supporting built-in Ethernet or the use of SPI-based ENC28J60 require TinyCLR to host is own TCP/IP and TLS stacks. This is currently still in development. Another option is to use a C# TCP/IP implementation, such us mIP . Or use a chip with built in TCP/IP, like Wiznet W5500 . Mobile Modems Most mobile modems expose AT serial commands for an easy network access. They simply become a serial-to-mobile gateway. Some modems expose AT commands for socket handling, which can be used in an interface driver for TinyCLR networking support, similar to the SPWF045x drivers. Redpine RS9110 Customers coming from older NETMF designs may have utilized Redpine RS9110 WiFi modules. Redpine has discontinued this product and we do not have plans to supporting it in TinyCLR. Also, due to an NDA with Redpine, we are unable to provide an open driver for it."
  },
  "software/tinyclr/tutorials/signal-generator.html": {
    "href": "software/tinyclr/tutorials/signal-generator.html",
    "title": "Signal Generator",
    "keywords": "Signal Generator SignalGenerator is a digital waveform generator. SignalGenerator works by comparing an internal counter to an array of time values, one by one. When the value of the argument matches the counter, the output pin is changed. The time values are in microseconds. SignalGenerator can also be used to generate PWM. Unlike the PWM class, SignalGenerator can be used to generate PWM on any available output pin. It does use processor time -- the higher the frequency the more processor time it uses. At this time, SignalGenerator only operates in blocking mode. While SingnalGenerator is running it will not yield any processor time to other code. The following sample code will blink LED1 on the FEZ four times (for one second each time) every five seconds. using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Devices.Signals; using GHIElectronics.TinyCLR.Pins; using System; using System.Threading; public static class Program { public static void Main() { var gen = new SignalGenerator(FEZ.GpioPin.Led1); var buffer = new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), }; gen.DisableInterrupts = false; gen.IdleValue = GpioPinValue.Low; while (true) { gen.Write(buffer); Thread.Sleep(5000); } } }"
  },
  "software/tinyclr/tutorials/signal-capture.html": {
    "href": "software/tinyclr/tutorials/signal-capture.html",
    "title": "Signal Capture",
    "keywords": "Signal Capture The SignalCapture class monitors a pin and records any changes (high-low or low-high transitions) of the pin into an array. It is a digital waveform recorder. Each array element is the number of microseconds between each signal change. When calling Read, it blocks other code from executing until it either fills the input buffer or it has captured the number of transitions specified by the count argument. If your signal is shorter than that, the call will never return. Make sure to request only what you plan to capture. The following sample code captures the signal generated by pressing BTN1 on the FEZ. It will attempt to capture 100 transitions, waiting no more than 10 seconds. It will also enable the pull-up resistor on the pin. It will return the initial state of the pin when it started capturing and how many transitions it captured. Note that the signal capture may record button bounces, resulting in a number of transitions in rapid succession. using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Devices.Signals; using GHIElectronics.TinyCLR.Pins; using System; using System.Threading; public static class Program { public static void Main() { var cap = new SignalCapture(FEZ.GpioPin.Btn1); var buffer = new TimeSpan[100]; cap.DisableInterrupts = false; cap.Timeout = TimeSpan.FromSeconds(10); cap.DriveMode = GpioPinDriveMode.InputPullUp; while (true) { var count = cap.Read(out var init, buffer); Thread.Sleep(100); } } }"
  },
  "software/tinyclr/tutorials/intro.html": {
    "href": "software/tinyclr/tutorials/intro.html",
    "title": "TinyCLR Tutorials",
    "keywords": "TinyCLR Tutorials Here you will find programming tutorials and code examples for our TinyCLR OS. We try to keep the documents as hardware generic as possible but changes may be required to get the sample code to run on your target device. Topics GPIO UART I2C SPI PWM ADC DAC CAN Graphics File System Time Timer Signal Generator Signal Capture Pulse Feedback Memory Management Resources Graphics Networking"
  },
  "software/tinyclr/tutorials/can.html": {
    "href": "software/tinyclr/tutorials/can.html",
    "title": "CAN",
    "keywords": "CAN Controller Area Network (CAN) bus is a two wire serial communication protocol which was originally released at the 1986 Society of Automotive Engineers (SAE) congress in Detroit. The first vehicle to use CAN reduced the weight of its wiring by over 100 pounds. While CAN was originally designed for use in cars to reduce the amount of wiring, the use of CAN has expanded and it can now be found in avionics, hospitals, assembly lines, and even some bicycles and prosthetic limbs. Some features that make CAN so popular include: High speed (up to 1 megabit/second) serial communication over inexpensive twisted pair wiring. High noise immunity due to balanced differential signaling. Built in message priority which allows higher priority messages to automatically suppress messages of lower priority without any delay in transmission of the higher priority message. Guaranteed latency time for high priority messages. Automatic synchronization of nodes without a clock signal. Communication from 40 meters at 1 megabit per second up to 5 kilometers at 10 kilobits per second (distances will vary depending on bus characteristics). Automatic bus arbitration and collision detection and correction. Automatic error detection and re-transmission. The ability to work even when different nodes have different ground potentials. Only two required processor pins (Transmit Data (TD) and Receive Data (RD)). Low cost. CAN bus is generally a two wire bus, but sometimes additional power and ground lines are included requiring four wires. High speed CAN is set up as a linear bus of 120 ohm nominal twisted pair wiring with two or more nodes. Termination resistors are used at each end of the bus as shown below. Tip Some CAN devices including our own development boards have built in termination resistors. If you are using more than two nodes on a high speed CAN bus you must disable the termination resistors on all nodes except for the two end nodes. Low speed or fault tolerant CAN uses a linear bus, star bus, or multiple star buses. Fault tolerant CAN buses are terminated differently than linear CAN buses and require a termination resistor at each node. The value of these resistors depends on the network but should equal about 100 ohms per CAN line in total. The TinyCLR CAN Interface The TinyCLR CAN API provides several methods for configuring the CAN bus and sending and receiving CAN messages. Configuring the Bus CAN bit timing is a complex topic that requires considerable knowledge of the CAN protocol. If you can obtain timing parameters for a device you are connecting to, use them. All nodes on a CAN network must use the same baud rate. Sample bit timing settings are given on each product's documentation page to help you get started. Please note that the given maximum oscillator tolerance and maximum cable length are theoretical maximums based only on the bit timing. These values do not take into account the number of nodes on the network, the type of cabling and termination, and the resistance of the cable, all of which may reduce the maximum bus length. It is up to you to test the network to ensure reliability. Before you can communicate over the CAN bus, the processor needs to know the characteristics of the bus so all nodes can communicate properly. SetBitTiming() defines the CAN bus timing using the arguments listed below. Due to the complexity of CAN bus timing, CAN bit rate calculators are available online which you may find helpful. Please refer to the processor datasheet for more information about the following parameters. The propagation argument is used to compensate for the physical delay times of the network and includes the input comparator delay, the output driver delay and the propagation delay of the bus itself (which is affected by the length and type of cable used). Propagation uses time quanta as a unit of measurement. The phase1 argument defines the length in time quanta of the phase one segment. The phase one segment can be automatically lengthened during re-synchronization. The phase2 argument defines the length in time quanta of the phase two segment. The phase two segment can be automatically shortened during re-synchronization. The baudratePrescaler argument determines the speed of the CAN system clock. The synchronizationJumpWidth defines the maximum amount of time quanta a bit period may be lengthened or shortened during each re-synchronization. When true, useMultiBitSampling will cause the bus to be sampled three times for each bit. Its use is recommended for low to medium speed buses to filter noise on the bus line. For high speed buses it is recommended to set this to false . In the sample code below, the CAN bus is communicating at one Megabit per second over a short bus. Sending CAN Messages WriteMessage() WriteMessage() writes a single CAN message. Each CAN message is defined by eight data bytes, an arbitration ID, the length (number of bytes to send), and two Boolean arguments which specify if the transmission is a remote transmission request and whether the message uses an extended arbitration ID. Extended arbitration IDs are 29 bits long, standard IDs are 11 bits long. WriteMessages() The WriteMessages() method is used to send an array of CAN messages. The arguments for this function are the array of CAN messages followed by an offset and count integer values. The offset is the array subscript of the first message to send, while count specifies how many messages to send. Receiving CAN Messages ReadMessage() ReadMessage() receives a CAN message and includes the ArbitrationId , IsExtendedId , IsRemoteTransmissionRequest , TimeStamp and Data properties. Filtering Incoming CAN Messages SetGroupFilters() SetGroupFilters() takes two arrays as arguments to set ranges of arbitration IDs that will be accepted. The first array defines the lower bounds of accepted arbitration IDs, while the second array specifies the upper bounds. Both arrays must be the same size. In the sample code below, the group filters will accept messages with arbitration IDs ranging from 0x12 to 0x20 and also between 0x500 and 0x1000 inclusive. SetExplicitFilters() SetExplicitFilter() takes an array argument which specifies individual arbitration IDs that will be accepted regardless of the group filter settings. In the sample code below, CAN messages with arbitration IDs of 0x11 and 0x5678 will be accepted, in addition to the arbitration IDs specified by the group filters. Sample Code The following sample code is written for our G120E Dev Board. It requires installation of the GHIElectronics.TinyCLR.Core , GHIElectronics.TinyCLR.Devices and GHIElectronics.TinyCLR.Pins Nuget packages. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Can; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { private static void Main() { var downButton = GpioController.GetDefault().OpenPin(G120E.GpioPin.P0_22); downButton.SetDriveMode(GpioPinDriveMode.InputPullUp); var can = CanController.FromName(G120E.CanBus.Can1); var propagation = 1; var phase1 = 12; var phase2 = 2; var baudratePrescaler = 4; var synchronizationJumpWidth = 1; var useMultiBitSampling = false; can.SetBitTiming(new CanBitTiming(propagation, phase1, phase2, baudratePrescaler, synchronizationJumpWidth, useMultiBitSampling)); can.Enable(); var message = new CanMessage() { Data = new byte[] { 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x2E, 0x20, 0x20 }, ArbitrationId = 0x11, Length = 6, IsRemoteTransmissionRequest = false, IsExtendedId = false }; var lowerBounds = new int[] { 0x12, 0x500 }; var upperBounds = new int[] { 0x20, 0x1000 }; can.SetGroupFilters(lowerBounds, upperBounds); var explicitFilter = new int[] { 0x11, 0x5678 }; can.SetExplicitFilters(explicitFilter); can.MessageReceived += Can_MessageReceived; can.ErrorReceived += Can_ErrorReceived; while (true) { if (downButton.Read() == GpioPinValue.Low) can.WriteMessage(message); Thread.Sleep(100); } } private static void Can_MessageReceived(CanController sender, MessageReceivedEventArgs e) { sender.ReadMessage(out var message); Debug.WriteLine(\"Arbitration ID: 0x\" + message.ArbitrationId.ToString(\"X8\")); Debug.WriteLine(\"Is extended ID: \" + message.IsExtendedId.ToString()); Debug.WriteLine(\"Is remote transmission request: \" + message.IsRemoteTransmissionRequest.ToString()); Debug.WriteLine(\"Time stamp: \" + message.TimeStamp.ToString()); var data = \"\"; for (var i = 0; i < message.Length; i++) data += Convert.ToChar(message.Data[i]); Debug.WriteLine(\"Data: \" + data); } private static void Can_ErrorReceived(CanController sender, ErrorReceivedEventArgs e) => Debug.WriteLine(\"Error \" + e.ToString()); }"
  },
  "software/tinyclr/native/apis.html": {
    "href": "software/tinyclr/native/apis.html",
    "title": "Native APIs in TinyCLR",
    "keywords": "Native APIs in TinyCLR The TinyCLR runtime provides several built in APIs for you to use and allows you to register APIs of your own that other parts of the system can later use. These APIs are also exposed to managed code to query and use. Looking inside the TinyCLR.h file provided in the porting repo, you'll see several types defined under TinyCLR_Api_Type . Each of those types has an associated provider somewhere else in the file that defines its API. The GPIO API for example allows you to read and write a pin that that provider has. APIs can also be set as the default API for a given type. This makes it easier for managed code to get access to a resource without knowing the exact name. Notice also that APIs are all defined as a struct with a field to access the owning API and a number of function pointers that provide the API. Most function pointers in avaialble APIs take a pointer to the owning struct as a this reference, since one is not implicitly provided because they're not traditional classes with instance members. Ports will register various providers to expose some functionality to other parts of the system, including native code. Our GHIElectronics.TinyCLR.Devices library allows you to specify which native provider you want to use and will automatically acquire and interface with it. It also uses the default API functionality to power the various GetDefault methods. All access to APIs is handled by the TinyCLR_Api_Manager type that is passed to the TinyCLR_Startup_SoftResetHandler you register. You can also find a reference to it on the TinyCLR_Interop_MethodData that gets passed to interops. The base function to find APIs is Find . You provide it an API name and the type that API should be and then it returns a TinyCLR_Api_Info type if it is found, or nullptr otherwise. The info struct contains information on the API like name, author, version, and type. It may also provide zero or one implementations. When providing zero implementations, Implementation is nullptr . When providing one, Implementation points direcetly to the an instance of the corresponding API struct. The functions SetDefaultName and GetDefaultName allow you to set and get the default name used for a given API type. FindDefault finds the API with the name registered as the default for the type if present and returns the API implementation it corresponds to. You can also add your own API using the Add function. Just provide it with a pointer to a TinyCLR_Api_Info struct that is properly constructed and it can later be found by calls to Find . You can add APIs from within native interops or your own native code if you're building your own firmware. The below code shows you how to find and interact with the default GPIO provider in the system. It assumes one is present and that the the function is an interop and thus has access to the method data. TinyCLR_Result Interop_Interop_SomeClass::SomeFunc___STATIC___VOID(TinyCLR_Interop_MethodData md) { auto apiManager = md.ApiManager; auto gpioController = reinterpret_cast<const TinyCLR_Gpio_Provider*>(apiManager->FindDefault(apiManager, TinyCLR_Api_Type::GpioController)); auto pin = 0U; if (gpioController != nullptr) { gpioController->Acquire(gpioController); gpioController->OpenPin(gpioController, pin); gpioController->SetDriveMode(gpioController, pin, TinyCLR_Gpio_PinDriveMode::Output); gpioController->WritePin(gpioController, pin, TinyCLR_Gpio_PinValue::High); gpioController->ClosePin(gpioController, pin); gpioController->Release(gpioController); } return TinyCLR_Result::Success; }"
  },
  "software/netmf/tutorials/graphics.html": {
    "href": "software/netmf/tutorials/graphics.html",
    "title": "Graphics",
    "keywords": "Graphics Introduction NETMF provides excellent support for graphics through the Bitmap class (that we also supplement with our Glide library). It can draw various shapes, text, and images from BMPs, JPGs, and GIFs -- which can be obtained from the file system, network, or resources. When drawing on a bitmap, everything is rendered on an in-memory object that can be quite large depending on your screen size. To transfer a bitmap object from memory to the screen, we need to call Flush on the bitmap object. Flush will only work if the size of the bitmap is exactly the size of the screen. If it is any other size, no image will be displayed. Non-Native Support Some smaller devices do not have a built in LCD controller. As a result, they can only use displays through a different type of bus, often SPI. Depending on your exact display, you may need to call a display specific function in its driver to draw on the scree. However, some SPI displays do support the Flush method on bitmaps, so be sure to consult your display documentation. Display Configuration In order to use a display, you must configure it. You can select the display type from FEZ Config on the LCD Configuration tab or you can execute the below code (make sure to select your actual display). After you set the configuration, the device must reboot for it to take effect. The Save method returns whether or not a reboot is needed. If you are using a display that is not present under GHIDisplay, you will need to configure the properties on the Display object instead of calling the Populate method. using GHI.Processor; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { Display.Populate(Display.GHIDisplay.DisplayCP7); if (Display.Save()) PowerState.RebootDevice(false); //Display is now configured. } } Drawing The following example draws a line and an ellipse on the screen. The assemblies Microsoft.SPOT.Graphics and Microsoft.SPOT.TinyCore are required. using Microsoft.SPOT; using Microsoft.SPOT.Presentation; using Microsoft.SPOT.Presentation.Media; public class Program { public static void Main() { Bitmap lcd = new Bitmap(SystemMetrics.ScreenWidth, SystemMetrics.ScreenHeight); lcd.DrawLine(Colors.Green, 1, 20, 20, 40, 40); lcd.DrawEllipse(Colors.Blue, 5, 5, 5, 5); lcd.Flush(); } } Text The following code shows how to display text using NETMF. Since resources depend on your project's default namespace, make sure that you change the namespace in this example to match your namespace. If you do not currently have a font resource in your project, NETMF ships with two default fonts that you can add as a resource found in C:\\Program Files (x86)\\Microsoft .NET Micro Framework\\v4.3\\Fonts. You can find the NinaB font that we use below in that folder. using Microsoft.SPOT; using Microsoft.SPOT.Presentation; using Microsoft.SPOT.Presentation.Media; namespace your_namespace { public class Program { public static void Main() { Font font = Resources.GetFont(Resources.FontResources.NinaB); Bitmap lcd = new Bitmap(SystemMetrics.ScreenWidth, SystemMetrics.ScreenHeight); lcd.DrawText(\"Hello, World!\", font, Colors.White, 0, 0); lcd.Flush(); } } } Adding new fonts to your application is very easy. TTL fonts can be converted to the simple font format used in NETMF using the TinyFont tool SPI Displays If you are using a G80 or Cerb based device and a SPI display, you can configure the device so that when you call Flush on a bitmap, it is automatically sent to the display. If the ControlPin is provided, the draw window will automatically be set, the data byte will be sent, and the ControlPin will be set high for you when you call Flush. The display will also be initialized on the first call to Flush. Additionally, the backlight pin will automatically be set high if provided on the first call to Flush. Lastly, if ResetPin is provided, it will be toggled before initialization. If your device does not have enough memory to create a bitmap for the entire screen, you can create a smaller one and only draw to a subset of the display. You can set the draw window on the display to match that new size and pick which position it is drawn at. Doing this multiple times allows you to draw the entire screen by moving the draw window around and redrawing the bitmap. The below example shows how to do this on the FEZ Cerberus and requires the GHI.Hardware, Microsoft.SPOT.Graphics, and Microsoft.SPOT.Hardware assemblies. Make sure you properly set any pins other configuration below for your actual device bearing in mind the above considerations. If you are not using the DisplayN18, you must configure the display before first use and set the draw window before you call Flush every time. using GHI.Pins; using GHI.Processor; using GHI.Utilities; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; using Microsoft.SPOT.Presentation.Media; public class Program { public static void Main() { Display.Width = 128; Display.Height = 160; Display.Type = Display.DisplayType.Spi; Display.CurrentRotation = Display.Rotation.Normal; Display.BitmapFormat = Bitmaps.Format.Bpp16BgrLe; Display.SpiModule = FEZCerberus.Socket5.SpiModule; Display.ChipSelectPin = FEZCerberus.Socket5.Pin6; Display.ResetPin = FEZCerberus.Socket5.Pin3; Display.BacklightPin = FEZCerberus.Socket5.Pin4; Display.ControlPin = FEZCerberus.Socket5.Pin5; Display.Save(); var bmp = new Bitmap(Display.Width, Display.Height); bmp.DrawEllipse(Colors.Red, 5, 5, 5, 5); bmp.DrawEllipse(Colors.Green, 15, 5, 5, 5); bmp.DrawEllipse(Colors.Blue, 25, 5, 5, 5); } } Gadgeteer When using Gadgeteer display modules, the SimpleGraphics interface is provided for you. It provides an API that is a bit easier to use than regular NETMF bitmaps. It is available as the SimpleGraphics property on every display. The below example shows how to display an ellipse, line, and some text. Make sure that you change the namespace to match yours. Gadgeteer programs automatically add the NinaB font to your project so you do not need to worry about adding it yourself. using GT = Gadgeteer; namespace your_namespace { public partial class Program { void ProgramStarted() { this.displayCP7.SimpleGraphics.DisplayEllipse(GT.Color.Red, 1, GT.Color.Red, 5, 5, 5, 5); this.displayCP7.SimpleGraphics.DisplayLine(GT.Color.Blue, 1, 20, 20, 40, 40); this.displayCP7.SimpleGraphics.DisplayText(\"Hello, World!\", Resources.GetFont(Resources.FontResources.NinaB), GT.Color.Green, 60, 60); } } }"
  },
  "software/netmf/tutorials/analog-out.html": {
    "href": "software/netmf/tutorials/analog-out.html",
    "title": "Analog Outputs",
    "keywords": "Analog Outputs An analog output sets the voltage on its pin anywhere between 0 and the supplied voltage (maximum voltage) which is typically 3.3 volts. The output voltage is only a signal, not meant to drive any loads. An op-amp or similar circuit can be added to drive loads, such as a speaker. The analog out on a micro has \"precision:\" the precision of a particular processor is in its manual or datasheet; consequentially, actual output values on the pin are an approximation. For example, a micro with an 8-bit (256 steps) analog out has a step precision of 3.3V/256. In NETMF, the voltage to be output is specified as a percentage called the \"level.\" So, on a processor with a maximum output of 3.3V, a level of 0.5 (50%) would output around 1.65V. NETMF has two properties for the AnalogOutput class: Scale and Offset. The final voltage on the output pin will be: Final voltage = maximum output * ( (level*Scale) + Offset)) Final voltages are clipped to fit in the range 0V to maximum pin voltage. Example The processor in this example has a maximum output of 3.3 volts. The 50% voltage (level == 0.5) by default would generate 1.65V. Because of Scale, the actual percent will be 10 (0.5 * 0.2), which results in an output voltage of about 0.33V (3.3V * 0.1). The following code requires the Microsoft.SPOT.Hardware assembly. using Microsoft.SPOT.Hardware; public class Program { public static void Main() { //Setup Analog on the first analog output channel AnalogOutput output = new AnalogOutput( Cpu.AnalogOutputChannel.ANALOG_OUTPUT_0); output.Scale = 0.2; output.Write(0.5); //output approx. 0.33V } }"
  },
  "software/netmf/intro.html": {
    "href": "software/netmf/intro.html",
    "title": ".NET Micro Framework",
    "keywords": ".NET Micro Framework .NET Micro Framework (NETMF) is a subset of the full Microsoft .NET Framework used to make Windows applications. NETMF initially started by Microsoft for use in SPOT watches and then later was open sourced. The latest version of Visual Studio working with our NETMF products is VS2013. General Resources .NET Micro Framework for Beginners (ebook PDF) Gadgeteer mainboards and moudle driver Source code Our .NET Micro Framework Discussion Forum Getting Started Deploy your first NETMF program. Learn more... Tutorials Learn NETMF embedded programming. Learn more... Downloads Visual Studio and device downloads. Learn more... Tip We discourage the use of NETMF on our products in favor of TinyCLR OS . Learn more about using NETMF devices with TinyCLR OS ."
  },
  "hardware/ucm/intro.html": {
    "href": "hardware/ucm/intro.html",
    "title": "Universal Compute Modules",
    "keywords": "Universal Compute Modules Universal Compute Modules are based on a 200 pin SO-DIMM form factor. All models follow a standard pin out making it easy to change modules to fit the needs of your product. A variety of tools and software options are available. Check the individual product documentation for details. The UCM Standard Description, peripherals and pinouts of the standard. Learn more... UC2550 ARM Cortex-M4 based UCM with optional Wi-Fi. Learn more... UC5500 ARM Cortex-M7 based UCM with optional Wi-Fi. Learn more... G400D Based on a 400 MHz Atmel ARM 926. Learn more... UCM Development Options Development boards, breakout boards, displays. Learn more... Learn more about The UCM Standard and check out the UCM Development Options to quickly prototype your project. You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/tinyclr/tutorials/graphics/user-interface.html": {
    "href": "software/tinyclr/tutorials/graphics/user-interface.html",
    "title": "User Interface",
    "keywords": "User Interface You can use the GHIElectronics.TinyCLR.UI library to create user interfaces for your application. It is inspired by WPF on the desktop. Application Management There is no special requirements when simply drawing . However, the user interface has internal management requirements, that is handled by the application class. Your starting point will look like the following code. Do not forget to add the GHIElectronics.TinyCLR.UI NuGet package. using GHIElectronics.TinyCLR.UI; using GHIElectronics.TinyCLR.Devices.Display; namespace UserInterfaceExample { class Program : Application { public Program(DisplayController d) : base(d) { } static void Main() { var disp = DisplayController.GetDefault(); disp.SetConfiguration(new ParallelDisplayControllerSettings { //Your display configuration }); disp.Enable(); var app = new Program(disp); app.Run(Program.CreateWindow(disp)); } private static Window CreateWindow(DisplayController disp) { var window = ... return window; } } } Windows You can have multiple windows in your application but you will at least need one. Here is a complete example that shows a window with a gradient brush background. The code is for UCM Dev board with 4.3 display and UC5550 UCM. using GHIElectronics.TinyCLR.UI; using GHIElectronics.TinyCLR.Devices.Display; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; using GHIElectronics.TinyCLR.UI.Media; namespace UserInterfaceExample { class Program : Application { public Program(DisplayController d) : base(d) { } static void Main() { var disp = DisplayController.GetDefault(); disp.SetConfiguration(new ParallelDisplayControllerSettings { //Your display configuration Width = 480, Height = 272, DataFormat = DisplayDataFormat.Rgb565, HorizontalBackPorch = 46, HorizontalFrontPorch = 16, HorizontalSyncPolarity = false, HorizontalSyncPulseWidth = 1, DataEnableIsFixed = false, DataEnablePolarity = false, PixelClockRate = 12_000_000, PixelPolarity = false, VerticalBackPorch = 23, VerticalFrontPorch = 7, VerticalSyncPolarity = false, VerticalSyncPulseWidth = 1 }); disp.Enable(); UCMStandard.SetModel(UCMModel.UC5550); var gpioController = GpioController.GetDefault(); var backlight = gpioController.OpenPin(UCMStandard.GpioPin.A); backlight.SetDriveMode(GpioPinDriveMode.Output); backlight.Write(GpioPinValue.High); var app = new Program(disp); app.Run(Program.CreateWindow(disp)); } private static Window CreateWindow(DisplayController disp) { var window = new Window { Height = (int)disp.ActiveConfiguration.Height, Width = (int)disp.ActiveConfiguration.Width }; window.Background = new LinearGradientBrush(Colors.Blue, Colors.Teal, 0, 0, window.Width, window.Height); window.Visibility = Visibility.Visible; return window; } } } Elements A window is not very useful without some elements (controls). There are several built in elements and you can also custom make your own. All elements descend from the UIElement class. Explore the GHIElectronics.TinyCLR.UI.Controls namespace for available options. For the sake of simplifying the rest of this tutorial, we will add private static UIElement Elements() method that creates and returns the elements. This is then assigned to the Child of our Window . You will need to add window.Child = Elements(); right before returning from CreateWindow . Tip This example needs a font . private static UIElement Elements() { var txt = new TextBox { Font = font, Text = \"Hello World!\", HorizontalAlignment = HorizontalAlignment.Center, VerticalAlignment = VerticalAlignment.Center }; return txt; } Text and TextBox These 2 elements are very basic and very useful. They are used in many of the examples throught this tutorial. Panel A Window can carry only a single Child , that is a single element. This is not a concern because the single element can be a container, like a Panel , which holds multiple elements. You can even have panels within panels and each has its own elements. This example will introduce shapes found in the GHIElectronics.TinyCLR.UI.Shapes namespace. It also shows an example of the TextBox element. We will also set margins for a better look. private static UIElement Elements() { var panel = new Panel(); var txt1 = new TextBox() { HorizontalAlignment = HorizontalAlignment.Left, VerticalAlignment = VerticalAlignment.Top, }; txt1.Font = font; txt1.SetMargin(20); txt1.Text = \"Hello World!\"; var txt2 = new Text(font, \"TinyCLR is Great!\") { ForeColor = Colors.White, HorizontalAlignment = HorizontalAlignment.Right, }; txt2.SetMargin(20); var rect = new Rectangle(200, 10) { Fill = new SolidColorBrush(Colors.Green), HorizontalAlignment = HorizontalAlignment.Center, }; panel.Children.Add(txt1); panel.Children.Add(txt2); panel.Children.Add(rect); return panel; } StackPanel There are also two types of elements that descend from panels, Canvas and StackPanel . The canvas allows elements to be added anywhere. Stack panels, on the other had, places elements in order. We will modify the previous example to use vertical stack. The elements will stack and be arrange to the right and the left. Note that setting vertical alignment will be ignored as the vertical stack does overrides how elements are stacked vertically. private static UIElement Elements() { var panel = new StackPanel(Orientation.Vertical); var txt1 = new TextBox() { HorizontalAlignment = HorizontalAlignment.Left, VerticalAlignment = VerticalAlignment.Top, }; txt1.Font = font; txt1.SetMargin(20); txt1.Text = \"Hello World!\"; var txt2 = new Text(font, \"TinyCLR is Great!\") { ForeColor = Colors.White, HorizontalAlignment = HorizontalAlignment.Right, }; txt2.SetMargin(20); var rect = new Rectangle(200, 10) { Fill = new SolidColorBrush(Colors.Green), HorizontalAlignment = HorizontalAlignment.Center, }; panel.Children.Add(txt1); panel.Children.Add(txt2); panel.Children.Add(rect); return panel; } Canvas The canvas provides pixel level control over where element go on the screen. However, like all other components, canvas is aware of the window size and things are aligned from it sides. private static UIElement Elements() { var canvas = new Canvas(); var txt = new Text(font, \"TinyCLR is Great!\") { ForeColor = Colors.White, }; var rect = new Rectangle(150, 30) { Fill = new SolidColorBrush(Colors.Green), HorizontalAlignment = HorizontalAlignment.Center, }; Canvas.SetLeft(rect, 20); Canvas.SetBottom(rect, 20); canvas.Children.Add(rect); Canvas.SetLeft(txt, 30); Canvas.SetBottom(txt, 25); canvas.Children.Add(txt); return canvas; } Border This element allows a border to be added. The border starts from the parent element and then the child is constrained to the border's thickness. This example will demonstrate how. The border is this example i set to 10, meaning the window (the parent) will grow inwards the border's thickness and then the child element(s) will fill in. If the children do not fill in the entire space then the border will fill in more than the assigned thickness. Uncomment the 2 alignment lines to see undesired effect of how borders work. private static UIElement Elements() { var border = new Border(); border.SetBorderThickness(10); border.BorderBrush = new SolidColorBrush(Colors.Red) var txt = new TextBox() { //HorizontalAlignment = HorizontalAlignment.Center, //VerticalAlignment= VerticalAlignment.Center, }; txt.Font = font; txt.Text = \"TinyCLR is Great!\"; border.Child = txt; return border; } The fix around this is to add a container and then the container will have a border. In this example, the parent of the border is the canvas instead of the window. private static UIElement Elements() { var canvas = new Canvas(); var border = new Border(); border.SetBorderThickness(10); border.BorderBrush = new SolidColorBrush(Colors.Red); Canvas.SetLeft(border, 20); Canvas.SetTop(border, 20); var txt = new TextBox(); txt.Font = font; txt.Text = \"TinyCLR is Great!\"; border.Child = txt; canvas.Children.Add(border); return canvas; } Button Buttons are a good place for user input. The button needs a child, typically text. Buttons also have Click event to handle the user input. private static UIElement Elements() { var txt = new Text(font, \"Push me!\") { VerticalAlignment = VerticalAlignment.Center, HorizontalAlignment = HorizontalAlignment.Center, }; var button = new Button() { Child = txt, Width = 100, Height = 40, }; button.Click += Button_Click; return button; } private static void Button_Click(object sender, RoutedEventArgs e) { // Add your code here... } TextFlow This element helps in adding text on multi-line and with different colors and sizes. private static UIElement Elements() { var textFlow = new TextFlow(); textFlow.TextRuns.Add(\"Hello \", font, Colors.Red); textFlow.TextRuns.Add(\"World!\", font, Colors.Purple); textFlow.TextRuns.Add(TextRun.EndOfLine); textFlow.TextRuns.Add(\"TinyCLR is Great!\", font, Colors.Yellow); return textFlow; } ListBox This element provides a list of options for users to select from. private static UIElement Elements() { var listBox = new ListBox(); listBox.Items.Add(new Text(font, \"Item 1\")); listBox.Items.Add(new Text(font, \"Item 2\")); listBox.Items.Add(new Text(font, \"Item 3\")); listBox.Items.Add(new Text(font, \"Item 4\")); return listBox; } It is also possible to add a separator between items, simply by using a rectangle. This item will be set to be not selectable. private static UIElement Elements() { var rect = new Rectangle() { Height = 1, Width=30, Stroke = new Pen(Colors.Black), }; var separator = new ListBoxItem() { Child = rect, IsSelectable = false, }; separator.SetMargin(2); var listBox = new ListBox(); listBox.Items.Add(new Text(font, \"Item 1\")); listBox.Items.Add(new Text(font, \"Item 2\")); listBox.Items.Add(separator); listBox.Items.Add(new Text(font, \"Item 3\")); listBox.Items.Add(new Text(font, \"Item 4\")); return listBox; } ScrollViewer The scroll viewer allows for viewing content that are larger than the viewing area. The user input can then be used to shift the content within the viewing area. The Dispatcher The User Interface libraries rely on a dispatcher internally to handle system events and updates the invalidated elements. Any changes to any of the elements needs to happen from within the dispatcher. In this example, we will show time on the screen. The time will be in a text box that is updated every second using a Timer . Since timers run in their own thread, a dispatcher invoke is needed. static void Counter(object o) { Application.Current.Dispatcher.Invoke(TimeSpan.FromMilliseconds(1), _ => { Text txt = (Text)o; txt.TextContent = DateTime.Now.ToString(); txt.Invalidate(); return null; }, null); } private static UIElement Elements() { var txt = new Text(font, \"Hello World!\") { ForeColor = Colors.White, VerticalAlignment = VerticalAlignment.Center, HorizontalAlignment = HorizontalAlignment.Center, }; Timer timer = new Timer(Counter, txt, 2000, 1000); return txt; } User Input A user can feed in input to the graphical interface through touch or button input. app.InputProvider.RaiseTouch(x, y, touchState, DateTime.UtcNow); app.InputProvider.RaiseButton(btn, btnState, DateTime.UtcNow); The touch tutorial has further details."
  },
  "software/tinyclr/tutorials/graphics/touch.html": {
    "href": "software/tinyclr/tutorials/graphics/touch.html",
    "title": "Touch",
    "keywords": "Touch Introduction Displays may optionally include a touch sensitive screen to detect user touch input. Touch Screens can be resistive or capacitive. Resistive Touch A resistive touch screen measures the resistance across X and Y to determine the touch position. While it is possible to use GPIO and ADC, it is better to use dedicated chips. The only advantage of resistive touch over capacitive is that they work through pressure, meaning you can use it while wearing gloves. But, resistive touch is not very accurate and requires calibration. Unless you have specific reason to use resistive touch, capacitive touch should be used. This is a simple example showing how to read a resistive display. A better approach would be to use a resistive touch controller chip that works over SPI/I2C. private void TouchReader() { var adc = AdcController.GetDefault(); var gpio = GpioController.GetDefault(); int x, y; while (this.active) { // Read X { var XR = gpio.OpenPin(this.PinXR); XR.SetDriveMode(GpioPinDriveMode.Output); XR.Write(GpioPinValue.High); var XL = gpio.OpenPin(this.PinXL); XL.SetDriveMode(GpioPinDriveMode.Output); XL.Write(GpioPinValue.Low); var YD = gpio.OpenPin(this.PinYD); YD.SetDriveMode(GpioPinDriveMode.Input); var YU = adc.OpenChannel(this.ChannelYUA); x = (int)(YU.ReadRatio()*1000); XR.Dispose(); XL.Dispose(); YU.Dispose(); YD.Dispose(); } // Read Y { var YD = gpio.OpenPin(this.PinYD); YD.SetDriveMode(GpioPinDriveMode.Output); YD.Write(GpioPinValue.High); var YU = gpio.OpenPin(this.PinYU); YU.SetDriveMode(GpioPinDriveMode.Output); YU.Write(GpioPinValue.Low); var XR = gpio.OpenPin(this.PinXR); XR.SetDriveMode(GpioPinDriveMode.Input); var XL = adc.OpenChannel(this.ChannelXLA); y = (int)(XL.ReadRatio()*1000); XR.Dispose(); XL.Dispose(); YU.Dispose(); YD.Dispose(); } if (x > 50 && y > 50) { var sx = this.Scale(x, 50, 830, 0, 320); var sy = this.Scale(y, 150, 830, 0, 240); this.TouchMove?.Invoke(this, new TouchEventArgs(sx, sy)); } Thread.Sleep(20); } } Capacitive Touch Capacitive touch screens are used on most modern devices, including phones. They are very accurate and capable of detecting multiple simultaneous touches. A special capacitive controller chip must be used to control the touch panel. This chip is usually mounted right on the flat cable going to the touch panel. These chips are usually I2C or SPI, with I2C being more common. The capacitive displays used in our development options use a controller from FocalTech. We provide the GHIElectronics.TinyCLR.Drivers.FocalTech.FT5xx6 NuGet package to interact with the touch screens. The constructor simply needs to know which I2C bus and reset pin are being used. The event fires with exact position matching the display resolution, no need for any scaling or calibration. The driver source code is found on the TinyCLR Drivers repo . This basics example will draw a dot on touch move using GHIElectronics.TinyCLR.Drivers.FocalTech.FT5xx6; var touch = new FT5xx6Controller(i2cController.GetDevice(FT5xx6Controller.GetConnectionSettings()), gpioController.OpenPin(UCMStandard.GpioPin.B)); touch.TouchMove += (_, e) => { screen.FillEllipse(brush, e.X, e.Y, 5, 5); screen.Flush(); };"
  },
  "software/tinyclr/tutorials/graphics/intro.html": {
    "href": "software/tinyclr/tutorials/graphics/intro.html",
    "title": "Graphics",
    "keywords": "Graphics TinyCLR OS includes a complete and comprehensive graphics support. Starting with the specific display drivers to drawing shapes and images, with complete font support. Creating User Interfaces can be accomplished with ease through a WPF-inspired libraries with support for touch panels."
  },
  "software/tinyclr/tutorials/graphics/font.html": {
    "href": "software/tinyclr/tutorials/graphics/font.html",
    "title": "Fonts",
    "keywords": "Fonts Fonts can be included in your TinyCLR application by adding them as a resource . Any TrueType font can be used after being converted to the .tcfnt format with the FontConverter tool. The Font Converter tool (found under downloads is a command line utility which does just that. var screen = Graphics.FromHdc(displayController.Hdc); var font = Resource.GetFont(Resource.FontResources.NinaB); var greenPen = new Pen(Color.Green); screen.DrawString(\"Hello World!\", font, greenPen.Brush, 10, 100); screen.Flush(); Built-in fonts When using systems with managed SPI display drivers, the font support is handled though an internal built-in font. This is done to reduce memory requirements. var teal = new SolidBrush(Color.Teal); var font = new Font(\"GHIMono8x5\", 8); screen.DrawString(\"Hello World!\", font, teal, 40, 10); screen.Flush(); Font Conversion To convert a font you must first make a .fntdef file which is a text file describing the font to convert as well as a number of other parameters. This file contains one option on each line. A minimal .fntdef file may look like this to have the standard ASCII characters. SelectFont \"FN:Arial,WE:400,HE:12,IT:0\" ImportRange 32 126 Tip This third-party tool can be handy for generating compatible fonts. Font Defenition The .fntdef file options are as follows: Note The order of statements in the .fntdef file matters. For example, properties such as AntiAlias must be specified before the InputRange property. AddFontToProcess path Path is the path to the TrueType font you want to convert. If the path contains spaces, you must enclose it in quotes and escape any backslashes. Example: AddFontToProcess C:\\Windows\\Fonts\\Arial.ttf SelectFont \"selection string\" \"Selection string\" is a quoted string containing comma delimited fields indicating the characteristics of the font to convert. ConvertFont searches the TrueType fonts installed on your computer, as well as any fonts in the AddFontToProcess argument, for a font matching the characteristics in the selection string argument. The first match is converted. Using spaces around the commas or colons in selection string will result in errors. Field types are as follows: HE: Height in logical units. Use zero for default height, a positive number for cell height and a negative number for character height. WI: Width. Average width of characters in logical units. Set to zero for closest match based on aspect ratio. ES: Escapement angle in tenths of a degree. Negative numbers rotate clockwise, positive numbers rotate counterclockwise. WE: Weight of font in range of 0 to 1000. 400 is normal, 700 is bold. Set to zero for default weight. IT: Italic if set to 1 (IT:1). FN: Face name. Name of the typeface. FullName: Full name. The unique name of the font. For example: \"Monotype:Arial Regular (Microsoft).\" For example, SelectFont \"HE:12,WE:400,FN:Arial\" will look for a regular-weight font of height 12 with a face name of \"Arial.\" AdjustAscent adjustment Adjustment is integer number of EM units to adjust ascent. Can be positive or negative. Can only be used once per .fntdef file. If it is used more than once, only the last occurrence will be used. AdjustDescent adjustment Adjustment is integer number of EM units to adjust descent. Can be positive or negative. Can only be used once per .fntdef file. If it is used more than once, only the last occurrence will be used. AdjustExternalLeading adjustment Adjustment is integer number of EM units to adjust the external leading. Can be positive or negative. Can only be used once per .fntdef file. If it is used more than once, only the last occurrence will be used. AdjustInternalLeading adjustment Adjustment is integer number of EM units to adjust the internal leading. Can be positive or negative. Can only be used once per .fntdef file. If it is used more than once, only the last occurrence will be used. AdjustLeftMargin adjustment Adjustment is integer number of device units to add to the left margin. Can be positive or negative. Applies to the characters specified by the ImportRange statement that most closely follows this option. AdjustRightMargin adjustment Adjustment is integer number of EM units to add to the right margin. Can be positive or negative. Applies to the characters specified by the ImportRange statement that most closely follows this statement. AntiAlias level Level can be 1, 2, 4, or 8. Font bitmaps will contain 2, 5, 17, or 65 levels of gray respectively. Must come after the SelectFont statement specifying the font to which this statement applies. May be applied to a range of characters defined by the ImportRange option. ImportRange start end Start and end are Unicode character codes indicating the beginning and end of the range of characters to convert (inclusive). Can be applied multiple times to convert a non-contiguous range of characters. Must come after the SelectFont statement specifying the font to which this statement applies. Both arguments are required. To specify a single character, make start and end the same number. ImportRangeAndMap start end offset Specifies range of characters to convert starting with Unicode character start + offset and ending with character end + offset , inclusive. Can be applied multiple times to convert a non-contiguous range of characters. Must come after the SelectFont statement specifying the font to which this statement applies. NoDefaultCharacter Specifies that no default character will be substituted for characters not converted. Must come after the SelectFont statement specifying the font to which this statement applies. OffsetX adjustment Adjustment is an integer describing the number of EM units to shift character position left or right. Positive numbers shift to the left, and negative numbers shift to the right. Applies to characters specified by any ImportRange, ImportRangeAndMap, or SetAsDefaultCharacter statements that follow it in the .fntdef file. Subsequent OffsetX statements supersede all previous OffxetX statements in the same .fntdef file. OffsetY adjustment Adjustment is an integer describing the number of EM units to shift character position up or down. Positive numbers shift down, and negative numbers shift up. Applies to characters specified by any ImportRange, ImportRangeAndMap, or SetAsDefaultCharacter statements that follow it in the .fntdef file. Subsequent OffsetX statements supersede all previous OffxetX statements in the same .fntdef file. SetAsDefaultcharacter charcode \"Charcode is the Unicode character code for the default character to substitute for characters that weren't converted. SetDefaultcharacter Indicates that the default character of the currently selected TrueType font will be substituted for characters that weren't converted. Verbosity level Note Not currently supported, set to 0. Level can be 0, 1, or 2. Level 0 displays no details, level 1 displays font properties, and level 2 displays font and character properties and a diagram of each character. # Comments You can add comments to your .fntdef file by starting the comment line with the \"#\" character. Syntax for running FontConverter is GHIElectronics.TinyCLR.FontConverter.exe input-font output-font . For example GHIElectronics.TinyCLR.FontConverter.exe Arial.fntdef Arial.tcfnt ."
  },
  "software/tinyclr/tutorials/i2c.html": {
    "href": "software/tinyclr/tutorials/i2c.html",
    "title": "I2C",
    "keywords": "I2C I2C (pronounced eye-squared-sea, or eye-two-sea) was originally developed by Phillips as a protocol for synchronous serial communication between integrated circuits. It has a master and one or more slaves sharing the same data bus. Instead of selecting the slaves by using a dedicated chip select signal like SPI, I2C uses an addressing mechanism to communicate with the selected device. This addressing method saves one I/O pin per slave. Before data is transferred, the master transmits the 7-bit address of the slave device it wants to communicate with. It also sends one bit indicating whether it wants to send data to the slave or receive data from the slave. When a slave sees its address on the bus, it will acknowledge its presence. At this point, the master can send or receive data. The master will start data transfers with a \"start condition\" before sending an address or data. The master ends the data transfer with a \"stop condition.\" The two wires for I2C communication are called the SDA and SCL lines. SDA stands for Serial Data, and SCL is Serial Clock. This is a partial demo showing the use of I2C. using GHIElectronics.TinyCLR.Devices.I2c; using GHIElectronics.TinyCLR.Pins; class Program { private static void Main() { var settings = new I2cConnectionSettings(0x1C); //The slave's address. settings.BusSpeed = I2cBusSpeed.FastMode; var controller = I2cController.FromName(FEZ.I2cBus.I2c1); var device = controller.GetDevice(settings); device.Write(new byte[] { 1, 2 }); //Write something device.WriteRead(...); //This is good for reading registers. } } Software I2C The I2C bus is relatively simple and can be \"bit banged\" using software. The advantage is that any two GPIO pins can be used. However, software I2C requires more system resources and runs slower. This example initializes a software I2C driver. Once initialized, it's used the same as hardware I2C. using GHIElectronics.TinyCLR.Devices.I2c; using GHIElectronics.TinyCLR.Devices.I2c.Provider; using GHIElectronics.TinyCLR.Pins; class Program { private static void Main() { var provider = new I2cControllerSoftwareProvider(FEZ.GpioPin.A0, FEZ.GpioPin.A1, false); var controller = I2cController.FromProvider(provider); var device = controller.GetDevice(new I2cConnectionSettings(0x1C) { AddressFormat = I2cAddressFormat.SevenBit, BusSpeed = I2cBusSpeed.StandardMode }); //Device address } }"
  },
  "software/tinyclr/tutorials/gpio.html": {
    "href": "software/tinyclr/tutorials/gpio.html",
    "title": "General Purpose Input Output (GPIO)",
    "keywords": "General Purpose Input Output (GPIO) Microcontrollers include pins that can be controlled through software. They can be inputs or outputs, hence the name \"general purpose input/output,\" or GPIO for short. Tip GPIO is handled by using GHIElectronics.TinyCLR.Devices.Gpio through the NuGet Devices package. Digital Outputs A digital output pin can be set to either high or low. There are different ways of describing these two states. High can also be called \"true\" or \"one;\" low can be called \"false\" or \"zero\". If the processor is powered from 3.3V, then the state high means that there is 3.3V on the output pin. It is not going to be exactly 3.3V but very close. When the pin is set to low, it's voltage will be very close to zero. Warning Never connect two output pins together. If they are connected and one is high and the other is low, the entire processor can be damaged. Warning Digital pins on microcontrollers are weak. They can only be used to control small LEDs or transistors. Those transistors can, in turn, control devices with high power needs like a motor. This example will blink an LED on the FEZ. using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; class Program { private static void Main() { var led = GpioController.GetDefault().OpenPin( GHIElectronics.TinyCLR.Pins.FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); while (true) { led.Write(GpioPinValue.High); Thread.Sleep(100); led.Write(GpioPinValue.Low); Thread.Sleep(100); } } } The previous example uses the FEZ pins class that enumerates all pins available on the FEZ. To blink an LED on hardware that does not have a pins class, you must use the GPIO pin's number to refer to it. This example can work on any STM32 chip. As every port has 16 pins, we calculate the pin number as shown. using System; using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { private static void Main() { var led = GpioController.GetDefault().OpenPin( //PinNumber('E', 2)); //Buggy bot right flash //PinNumber('C', 4)); //Buggy bot left flash //PinNumber('C', 12)); //mini M4 //PinNumber('B', 2)); //Cerbuino //PinNumber('A', 1)); //clicker //PinNumber('E', 12)); //clicker2 //PinNumber('E', 15)); //Quail //PinNumber('A', 10)); //netduino 3 //PinNumber('D', 5)); //411 red Discovery //PinNumber('D', 15)); //411 blue Discovery PinNumber('B', 9)); //FEZ LED1 (same as below) //STM32F4.GpioPin.PB9); //FEZ LED1 led.SetDriveMode(GpioPinDriveMode.Output); while (true) { led.Write(GpioPinValue.High); Thread.Sleep(100); led.Write(GpioPinValue.Low); Thread.Sleep(100); } } private static int PinNumber(char port, byte pin) { if (port < 'A' || port > 'E') throw new ArgumentException(); return ((port - 'A') * 16) + pin; } } Digital Inputs Digital inputs sense the state of an input pin based on its voltage. The pin can be high or low. Every pin has a maximum and minimum supported voltage. For example, the typical minimum voltage on most pins is 0 volts; a negative voltage may damage the pin or the processor. Also, the maximum that can be applied to most pins must be less than or equal to the processor's power supply voltage. Since most processors run on 3.3V, the highest voltage a pin should see is 3.3V. However, some processors that are powered by 3.3V are 5V tolerant -- they can withstand up to 5V on their inputs. The FEZ is 5V tolerant. Warning 5V tolerant doesn't mean the processor can be powered by 5V, only that the input pins can tolerate 5V. Unconnected input pins are called \"floating.\" They are in a high impedance state and are susceptible to surrounding noise which can make the pin read high or low. A resistor can be added to pull the pin high or low. Modern processors include internal pull-down or pull-up resistors that are controlled by software. Note that a pull-up resistor doesn't necessarily make a pin high -- something connected to the pin can still pull it low. In this example, a button is connected between ground and an input pin. We will enable the pull-up resistor making that pin high when the button is not pressed. When the button is pressed it will overpower the pull-up and make the input low. We will read the status of the button and pass its state to an LED. Tip Never use an infinite loop without giving the system time to think. Add a short sleep to the loop or use events instead. using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { private static void Main() { var gpio = GpioController.GetDefault(); var led = gpio.OpenPin(FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); var button = gpio.OpenPin(FEZ.GpioPin.Btn1); button.SetDriveMode(GpioPinDriveMode.InputPullUp); while (true) { if (button.Read() == GpioPinValue.Low) { //Button is pressed. led.Write(GpioPinValue.Low); } else { led.Write(GpioPinValue.High); } Thread.Sleep(10); //Always give the system time to think! } } } Tip if you are not using a FEZ, see the Output Port example above to see how to determine the pin number. Digital Input Events In the previous example the program looped forever. The input attached to the button was checked during each iteration of the loop. The pin may be checked millions of times before the button is pressed! This method of checking inputs is called \"polled input.\" Using events to check an input instead of polling the input is often preferred. Once an event is set up it will automatically check the input on its own, freeing up the program to do other things. Also, it is possible to miss a change in input if you don't check (or poll) the input often enough. Events use interrupts to check inputs so you don't have to worry about missing anything. When an event occurs, the program stops what it is doing and control is transferred to an event handler. An event handler is code you write that responds to the event. Let's use event driven programming to respond to a button and turn an LED on and off. We will raise an event when the value on the button's input pin changes because the button is pressed or released. You will see a reference to a \"falling edge\" in the following code. A falling edge occurs when the state of a pin goes from high to low. A rising edge is just the opposite -- it occurs when a pin goes from low to high. This is a button controlled LED using events. using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { private static GpioPin led; private static void Main() { var gpio = GpioController.GetDefault(); led = gpio.OpenPin(FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); var button = gpio.OpenPin(FEZ.GpioPin.Btn1); button.SetDriveMode(GpioPinDriveMode.InputPullUp); button.ValueChanged += Button_ValueChanged; Thread.Sleep(-1); //Sleep to reduce power use and allow system to do other tasks. } private static void Button_ValueChanged(GpioPin sender, GpioPinValueChangedEventArgs e) { if (e.Edge == GpioPinEdge.FallingEdge) led.Write(GpioPinValue.Low); else led.Write(GpioPinValue.High); } } Tip Once you type += after the event, hit the tab key and Visual Studio will automatically create the event for you. UCM Standard Pins The UCM Standard provides a consistent mapping of pins to enable easily swapping out the underlying SoM. While the standard assigns a consistent name to each pin, the underlying pin on the processor is different, so it is helpful to use the UCMStandard class available in the GHIElectronics.TinyCLR.Pins.UCM library. Once you specify the device model to use, it will map the pins for you automatically. For example: using GHIElectronics.TinyCLR.Pins; using GHIElectronics.TinyCLR.Devices.Gpio; class Program { private static void Main() { UCMStandard.SetModel(UCMModel.UC5550); var controller = GpioController.GetDefault(); var pin = controller.OpenPin(UCMStandard.GpioPin.A); } }"
  }
}