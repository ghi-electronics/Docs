{
  "tinyclr/accessories/mikroe_arduino_uno_click_shield.html": {
    "href": "tinyclr/accessories/mikroe_arduino_uno_click_shield.html",
    "title": "MikroElektronika Arduino UNO Click Shield",
    "keywords": "MikroElektronika Arduino UNO Click Shield Through Mikro Electronica's mikroBUS standard , hundreds of Mikro's Click boards can be easily connected to your board. The BrainPad , Clicker , and Quail boards all have sockets for plugging click boards. This video talks about the technology behind SPI bus, shift registers, and serial-parallel data. It uses the LED ring click on the BrainPad. The source code is found here . You can use these click boards with FEZ , or any other Arduino-pinout compatible board, through the Arduino UNO click shield . The same code used above with the BrainPad can be used with FEZ and the Arduino UNO click shield. Simply, change the pins from BrainPad to FEZ. The pins are labeled right on the shield. For example, the CS pin on socket 1 is labeled CS/D10 . The complete project is found here"
  },
  "tinyclr/boards/clicker.html": {
    "href": "tinyclr/boards/clicker.html",
    "title": "Clicker",
    "keywords": "Clicker The Clicker board from Mikro Elekronika, and other similar products listed on this page, all run TinyCLR OS. You will be loading TinyCLR OS on these boards using the Mikro bootloader . Tip The loader will wait for a few seconds on every power up before it runs TinyCLR OS. If this delay is not desirable, use an ST-Link programmer to flash the firmware onto the board directly, overwriting the bootloader. Mikro Elekronika's STM32 M4 Clicker board includes a single mikroBUS socket, for quickly adding one of many available click modules . The TinyCLR OS Clicker firmware (coming soon!) Warning Clicker and Clicker 2 boards use different processors and different system clock. Each board has its own TinyCLR OS firmware. Clicker 2 Mikro Elekronika's clicker 2 for STM32 board includes dual mikroBUS socket, for quickly adding one of many available click modules . The TinyCLR OS Clicker 2 firmware (coming soon!) Warning Clicker and Clicker 2 boards use different processors and different system clock. Each board has its own TinyCLR OS firmware. MINI-M4 for STM32 The MINI-M4 for STM32 uses the same processor and system clock as the Clicker board (not Clicker 2). Buggy Buggy is a robot rover platform that is expandable through the click modules . The Clicker 2 is used to drive this rover, making it a TinyCLR OS rover!"
  },
  "tinyclr/accessories/seeed_grove_starter_kit.html": {
    "href": "tinyclr/accessories/seeed_grove_starter_kit.html",
    "title": "Seeed Grove Starter Kit",
    "keywords": "Seeed Grove Starter Kit Grove is a modular electronic platform for quick prototyping. Every module has one function, such as touch sensing, creating audio effect and so on. Just plug the modules you need to the base shield, then you are ready to test your idea buds. We have picked the Seeed Grove Starter Kit for Arduino as starting base but you can add additional Grove modules as well. The included Grove modules plug into the included arduino shield. This shield works with any arduio-pinout compatible board, like the FEZ . Plug the shield on top of your board, and get the drivers . This example that makes some noise! Buzzer buzz = new Buzzer(FEZ.GpioPin.D4); buzz.Beep(); Thread.Sleep(5000); buzz.TurnOn(); Thread.Sleep(1000); buzz.TurnOff(); while(true) { buzz.Beep(); Thread.Sleep(1000); } This example will read the temperature TemperatureSensor temp = new TemperatureSensor(FEZ.AdcChannel.A1); while(true) { Debug.WriteLine(\"-> \" + temp.ReadTemperature()); Thread.Sleep(1000); } This example will show some text on the character display LcdRgbBacklight lcd = new LcdRgbBacklight(); lcd.Clear(); lcd.SetBacklightRGB(100, 100, 0); lcd.BlinkBacklight(true); lcd.BlinkBacklight(false); lcd.Write(\"*** TinyCLR ***\"); Thread.Sleep(1000); lcd.SetCursor(0, 1); lcd.Write(\"Count:\"); int count = 0; while (true) { lcd.SetCursor(7, 1); lcd.Write(count.ToString()); count++; lcd.SetBacklightRGB(100, 100, (byte)count); Thread.Sleep(100); } Warning Pay attention to the 3.3V-5V switch on the shield. The rotary and temperature sensors only work with 3.3V but the RGB character display only works with 5V. Since the character display connects to I2C and only works with 5V. We have modified one of the I2C sockets to be always 5V. This allows us to keep the switch at 3.3V, leaving all other sockets at 3.3V. Warning These steps require some experience and will void your warranty! Start by cutting the power trace going to the last socket. (image) Now, add a wire from the socket directly to 5V. (image)"
  },
  "brainpad/expandability.html": {
    "href": "brainpad/expandability.html",
    "title": "Expandability",
    "keywords": "Expandability Additional functionality can be added to the BrainPad through its expansion headers. This can be done though a plug-and-play click modules or by direct wiring. Plug-and-play Click Modules This is an easy option as these modules simply plug in. There are hundreds of available options https://shop.mikroe.com/click This page covers further details on the click modules Advanced users can add any of the available modules. However, there are courses that cover specific modules and include all the needed drivers. Direct Wiring This option is only recommended for advanced users with electronics background. As a demo, we built this robot with a chassis we ordered from Amazon http://a.co/dwzywoI The continuous servo motors simply plug in. Pay attention to wires, where the orange wire should be connected to the pin labeled with ~. We then used a breadboard with an ultrasonic distance sensor. This will be used to detect objects, to back up the robot. BrainPad.ServoMotors.ServoOne.ConfigureAsContinuous(false); BrainPad.ServoMotors.ServoTwo.ConfigureAsContinuous(true); BrainPad.Display.DrawSmallTextAndShowOnScreen(0, 20, \"Press Left\"); while (BrainPad.Buttons.IsLeftPressed() == false) { // Beep BrainPad.Buzzer.Beep(); BrainPad.Wait.Seconds(0.3); } BrainPad.Display.ClearScreen(); BrainPad.Display.DrawSmallTextAndShowOnScreen(40, 20, \"Go!\"); //BrainPad.ServoMotorsIsServoTwoInverted(true); bool dirrection = true; BrainPad.ServoMotors.ServoOne.Set(50); BrainPad.Display.DrawSmallTextAndShowOnScreen(40, 20, \"Reflect\"); // using reflector bool use_builtin = true; if (use_builtin) { GpioPulseReaderWriter echolen = new GpioPulseReaderWriter( GpioPulseReaderWriter.Mode.EchoDuration, true, 10, BrainPad.Expansion.GpioPin.Mosi, true, BrainPad.Expansion.GpioPin.Miso); Move(100, 60); //dance! while (true) { double l = echolen.Read(); BrainPad.Display.DrawSmallTextAndShowOnScreen(0, 0, l.ToString()); if (l < 600) { Move(-100, -100); BrainPad.Wait.Seconds(1); Move(-100, 100); BrainPad.Wait.Seconds(0.5); Move(100, 60); } BrainPad.Wait.Seconds(0.3); } } This other demo video talk about stepper motors and uses the BrainPad."
  },
  "tinyclr/boards/quail.html": {
    "href": "tinyclr/boards/quail.html",
    "title": "Quail",
    "keywords": "Quail Originally a .NET Micro Framework product, Quail board brings the option of using hundreds of plug-and-play sensors and control modules, thanks to Mikro's click modules . Learn more about Quail at: https://www.mikrobusnet.org/ and https://shop.mikroe.com/quail The Quail firmware is located here . Follow the instructions at the STM32 bootloader page to generate and load a DFU firmware file. When done, your PC should detect a TinyCLR device. You are now ready to start coding Tip The region set aside for RLI is 0x2002F000 - 0x2002FFF8."
  },
  "tinyclr/porting/native_apis.html": {
    "href": "tinyclr/porting/native_apis.html",
    "title": "Native APIs in TinyCLR",
    "keywords": "Native APIs in TinyCLR The TinyCLR runtime provides several built in APIs for you to use and allows you to register APIs of your own that other parts of the system can later use. These APIs are also exposed to managed code to query and use. Looking inside the TinyCLR.h file provided in the porting repo, you'll see several types defined under TinyCLR_Api_Type . Each of those types has an associated provider somewhere else in the file that defines its API. The GPIO API for example allows you to read and write a pin that that provider has. APIs can also be set as the default API for a given type. This makes it easier for managed code to get access to a resource without knowing the exact name. Notice also that APIs are all defined as a struct with a field to access the owning API and a number of function pointers that provide the API. Most function pointers in avaialble APIs take a pointer to the owning struct as a this reference, since one is not implicitly provided because they're not traditional classes with instance members. Ports will register various providers to expose some functionality to other parts of the system, including native code. Our GHIElectronics.TinyCLR.Devices library allows you to specify which native provider you want to use and will automatically acquire and interface with it. It also uses the default API functionality to power the various GetDefault methods. All access to APIs is handled by the TinyCLR_Api_Provider type that is passed to the TinyCLR_Startup_SoftResetHandler you register. The base function to find APIs is Find . You provide it an API name and the type that API should be and then it returns a TinyCLR_Api_Info type if it is found, or nullptr otherwise. The info struct contains information on the API like name, author, version, and type. It may also provide zero or more implementations specified by the Count field. When providing zero implementations, Implementation is nullptr . When providing one, Implementation points direcetly to the an instance of the corresponding API struct. If providing more than one, it points to an array of pointers, each of which its a pointer to an instance of the corresponding API struct. The functions SetDefaultSelector and GetDefaultSelector allow you to set and get the default selector used for a given API type. A selector takes the form \"{API name}{API index}\" (excluding the braces). This selector can be used by the FindBySelector method. It'll look for an API with the given name and then find the implementation with the given index, making sure not to go out of bounds for the specified API. FindByIndex does the same thing except you manually provide it with the name and index. FindByDefault finds the default selector for the type if present and returns the API implementation it corresponds to. You can also add your own API using the Add function. Just provide it with a pointer to a TinyCLR_Api_Info struct that is properly constructed and it can later be found by calls to Find . You can add APIs from within native interops or your own native code if you're building your own firmware. The below code shows you how to find and interact with the default GPIO provider in the system. It assumes one is present and that the API provider is available as a global variable in your code. void gpioTest() { auto gpioProvider = (const TinyCLR_Gpio_Provider*)apiProvider->FindDefault(apiProvider, TinyCLR_Api_Type::GpioProvider); if (gpioProvider != nullptr) { gpioProvider->AcquirePin(gpioProvider, 0); gpioProvider->WritePin(gpioProvider, 0, TinyCLR_Gpio_PinValue::High); gpioProvider->ReleasePin(gpioProvider, 0); } }"
  },
  "tinyclr/tutorials/spi.html": {
    "href": "tinyclr/tutorials/spi.html",
    "title": "SPI",
    "keywords": "SPI SPI uses three, sometimes four, wires for transferring data. The bus on SPI consists of a single master and one or more slaves. The master will send clock to the salves over the SCK pin. It will also send date over MOSI pin, while reading incoming data on the MISO pin. The SCK clock is used to determine how fast the data is moved. If you know electronics, this is simply a shift register. The master selects which slave it will swap the data with using the SSEL pin, sometimes called CS. In its simplest terms, the master will swap data between itself and the slave. You cannot write data without reading at the same time. However, a lot of time you need to write data and you do not care about the incoming data. For that, there is a Write method. But keep in mind that the Write method is also reading, and discarding, whatever the slave is sending. Tip Some SPI devices (slaves) can have more than one select-pin, like the VS1053 MP3 decoder chip that uses one select pin for data and other for commands. Both share the 3 data transfer pins (SCK, >MOSI, MISO). Tip SPI needs more wires than other similar buses but it can transfer data very fast. A 50Mhz clock is possible on SPI, that is 50 million bits in one second. Tip Note that a board running TinyCLR OS is always a SPI masters, not slaves. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Spi; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var settings = new SpiConnectionSettings(0x1C)// the slave's select pin { Mode = SpiMode.Mode1, ClockFrequency = 4* 1000 * 1000,//4Mhz DataBitLength = 8, }; var device = SpiDevice.FromId(FEZ.SpiBus.Spi1, settings); device.Write(new byte[] { 1, 2 });// write something device.TransferSequential(...)// this is good for reading registers device.TransferFullDuplex(...)// this is the only one that trully represents how SPI works } }"
  },
  "tinyclr/tutorials/uart.html": {
    "href": "tinyclr/tutorials/uart.html",
    "title": "UART",
    "keywords": "UART Serial data ports, called UART, transfers data between two pins TXD (transmit) and RXD (receive). There is no clock between the two sides so they both need to agree on the data slow rate, called baudrate. Tip the TXD on one end (output) goes to the RXD on the other side (input) and vice versa. The easiest way to test UART is by wiring TXD to RXD and then any data transmitted is also received. This demo will send a number every half a second and wait for it on the receive end. Tip Serial uses Storage Streams to handle the data. Add the Storage NuGet package. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Storage.Streams; using GHIElectronics.TinyCLR.Devices.SerialCommunication; using GHIElectronics.TinyCLR.Pins; class Program { static DataReader serReader; static DataWriter serWriter; static void Sender() { byte b = 0; while(true) { serWriter.WriteByte(b++); serWriter.Store(); Debug.WriteLine(\"Sent: \" + b); Thread.Sleep(500); } } static void Main() { SerialDevice ser = SerialDevice.FromId(FEZ.SerialPort.Com1); ser.BaudRate = 115200; ser.ReadTimeout = TimeSpan.Zero; serReader = new DataReader(ser.InputStream); serWriter = new DataWriter(ser.OutputStream); Thread SenderT = new Thread(Sender); SenderT.Start(); while (true) { var i = serReader.Load(1); if(i>0) { byte b = serReader.ReadByte(); Debug.WriteLine(\"Recieved: \" + b); } Thread.Sleep(10);// always give the system time to think! } } } RS232 UART uses the processor's voltage levels for transferring data, called TTL voltage levels. Systems from back in the 80s needed a way to transfer data over long distances and so the UART levels changed to be -12V to +12V instead of TTL 0V to 3.3V on FEZ for example. This standard is called RS232. Some PCs still include serial porta till this day but those are RS232 serial ports. A level shifter chip is needed to convert the voltages properly. Warning connecting your circuit to RS232 port without proper level shifter wil damage your circuit."
  },
  "hardware/legacy_products/gadgeteering.html": {
    "href": "hardware/legacy_products/gadgeteering.html",
    "title": "Gadgeteering",
    "keywords": "Gadgeteering Gadgeteering was meant to extend Gadgeteer beyond NETMF. We are making our hardware and software available for reference only. All material is found at this github repository"
  },
  "tinyclr/tutorials/display.html": {
    "href": "tinyclr/tutorials/display.html",
    "title": "Display",
    "keywords": "Display Displays works in the current release. Documentation is coming soon."
  },
  "brainpad/courses/programming/csharp/variables_and_nested_statements.html": {
    "href": "brainpad/courses/programming/csharp/variables_and_nested_statements.html",
    "title": "Variables and Nested Statements",
    "keywords": "Variables and Nested Statements"
  },
  "brainpad/courses/intro.html": {
    "href": "brainpad/courses/intro.html",
    "title": "Courses Intro",
    "keywords": "Courses Intro Here you will find course to cover many topics, for every level or experience. Are you a teacher? We want to hear from you. Please contact us directly or through our community forum . BrainPad for non-programmers One of the strongest values of the BrainPad is that is is programmed easilly using world-class developer tools. The same tools use by millions of professional developers. But the use of the BrainPad goes beyond to teach non-programming classes. For example, this video doesn't tech programming but it uses the BrainPad to run a stepper motor controller."
  },
  "brainpad/courses/programming/intro.html": {
    "href": "brainpad/courses/programming/intro.html",
    "title": "Programming Intro",
    "keywords": "Programming Intro Coming soon."
  },
  "brainpad/courses/programming/vb/threading_and_events.html": {
    "href": "brainpad/courses/programming/vb/threading_and_events.html",
    "title": "Threading and Events",
    "keywords": "Threading and Events"
  },
  "hardware/legacy_products/filesystem.html": {
    "href": "hardware/legacy_products/filesystem.html",
    "title": "File System",
    "keywords": "File System Since 2003, GHI Electronics has made several industry-first file system chipsets. F40 Originally called ALFAT. Datasheet ALFAT-SD Schematic ALFAT-OEM Schematic Firmware 1.08 Firmware 2.00 (the file name needs changing) F20 Datasheet Firmware v103 F20-uSD Schematic uALFAT User Manual"
  },
  "tinyclr/tutorials/gpiochangereader.html": {
    "href": "tinyclr/tutorials/gpiochangereader.html",
    "title": "Gpio Change Reader",
    "keywords": "Gpio Change Reader Gpio Change Reader works in the current release. Documentation is coming soon. GpioChangeReader g = new GpioChangeReader(FEZ.GpioPin.A1, GpioPinDriveMode.InputPullUp); See this for now https://www.ghielectronics.com/docs/106/signal-capture"
  },
  "hardware/products/brainpad.html": {
    "href": "hardware/products/brainpad.html",
    "title": "BrainPad",
    "keywords": "BrainPad The BrainPad is an educational STEM & STEAM targeted board. Courses and learning materials are found under the BrainPad section. This page has info for advanced users. Resources: The BrainPad's main website: http://brainpad.com Schematic The Original BrainPad Resources: Schematic Software Options While TinyCLR OS is the official supported system for the BrainPad, there are many other options (The BrainPad and the FEZ share the same core). Interested in a FREE BrainPad to test it with one of other options? We want to hear from you directly or on our community forums ."
  },
  "hardware/products/fez.html": {
    "href": "hardware/products/fez.html",
    "title": "FEZ",
    "keywords": "FEZ FEZ (fast and easy) is the official board for TinyCLR OS. This low-cost, WiFi IoT-ready, Arduino-pinout compatible, and TinyCLR-OS-ready board is everything a developer needs to evaluate TinyCLR OS and to build modern IoT applications. We have also handpicked some 3rd-party accessories to help you get going even faster. TinyCLR OS TinyCLR OS allows tiny systems to run .NET applications with rich debugging capabilities though Visual Studio 2017. TinyCLR OS Website TinyCLR on FEZ TinyCLR Ports Repo Other Options TinyCLR OS is the official supported platform for FEZ; however, these are some other good options. GHI Electronics is not affiliated and does not provide support for any of these 3rd party options. Interested in a FREE FEZ to test it with one of these options? We want to hear from you directly or on our community forums . Arduino Arduino is simpified multi-platform IDE/C++ combo, with a community STM32 options. Arduino Wesbite Arduino STM32 forum eLua eLua is an embedded version of Lua, allowing small embedded systems to run and compile Lua programs. The STM32F4 is already one of available ports, making it easier to run MicroPython on FEZ. eLua Website GitHub Repo mbed mbed is an online compiler platform. There is nothing to install, just log in and start coding! One of the supported boards is Nucleo-F401RE, which uses the exact same microcontroller found on FEZ. Start with it to build and compile then follow the STM32 bootloader instructions on generating and loading DFU files. mbed Website Nucleo-F401RE MicroPython MicroPython allows tiny systems to run Python 3, with a small subset of the standard library. The STM32F4 is already one of available ports, making it easier to run MicroPython on FEZ. MicroPyho Website GitHub Repo Plain Coding! Of course you can just start coding everyting from scratch. You can use free open source GNU GCC tools to build your programs, which is what we use to build TinyCLR OS. An easier options is to use Keil comiler/IDE. It is free for 32KB or less program size (MDK-Lite). If you are not adding a SWD JTAG tool, like ST-Link, follow the STM32 bootloader instructions on generating and loading DFU files. Keil Website Keil ARM MDK tools"
  },
  "tinyclr/downloads.html": {
    "href": "tinyclr/downloads.html",
    "title": "Downloads",
    "keywords": "Downloads This page includes different download types for individual boards. See individual product pages for details on what to download. Software status legend: Status Meaning Production Ready to be used commercially. RC Release Candidate, stable and can be field tested. Beta No more major changes, use for development. Alpha Use for tying things out and provide feedback. Major changes to come. Extension The extension is what gets loaded on Visual Studio to allow it to communicate with a TinyCLR OS device. It also includes project templates. Extension Date Status MD5 TinyCLR 0.5.0 2017-07-07 Alpha 58542CEB7DAF6445AD10083ABA73D834 TinyCLR 0.4.0 2017-05-10 Alpha 4D463EA5991EA7698110B79EF4DB6B8B TinyCLR 0.3.0 2017-04-06 Alpha 6094565340EDF8F5445106C2A9B1441C TinyCLR 0.2.0 2017-03-07 Alpha A9CB8E88011AFF28AD88656E86C73A31 TinyCLR 0.1.0 2016-12-16 Alpha D93A8FF13900362FB4528F8036D46612 Libraries Libraries are hosted though a local NuGet feed for now as we are a lot of changes still. These libraries will be hosted on http://www.nuget.org/ in the future. Library Date Status MD5 Libraries 0.5.0 2017-07-07 Alpha C1768FF218AB1790BD902E52561C0CE5 Libraries 0.4.0 2017-05-10 Alpha 1A8B0E28431927FA4716B44B774FDF90 Libraries 0.3.0 2017-04-06 Alpha 21D3E9AD37285B231B1E6E605B7CA709 Libraries 0.2.0 2017-03-07 Alpha 7CDE2D7ADDD3E490344B1DA8DB342F8D Libraries 0.1.0 2016-12-16 Alpha 9E843638A8A4793814D76B522F8CBF1A TinyCLR Config TinyCLR Config is a tool used to update and configure your TinyCLR device. Library Date Status MD5 Config 0.6.0 2017-xx-xx Alpha x Firmware The Firmware is the TinyCLR OS that lives on your hardware. The firmware version loaded on the hardware must match the version number of the extension and the libraries. This will be easier managed once the libraries are hosted on http://www.nuget.org/ FEZCLR This is the reference firmware for TinyCLR OS and it runs on the FEZ and the BrainPad . Firmware Date Status MD5 FEZCLR 0.5.0 2017-07-07 Alpha 93094FF58D78DEB36D22FD9450737362 G30 Firmware Date Status MD5 G30 0.5.0 2017-07-07 Alpha 4A8479E0D431868ED047CB7C482511CE G30 0.4.0 2017-05-10 Alpha FCBACDAB7C02E1A855375BF776EEE2FB G30 0.3.0 2017-04-06 Alpha 59A994B1F4F60FB3AE6CD8F91AB01650 G30 0.2.0 2017-03-07 Alpha 6E5BB699634D78DD64FFFB69D547A58F G30 0.1.0 2016-12-16 Alpha 6347B73E93FF9BF7D52ECE142D9F2ECB G80 Firmware Date Status MD5 G80 0.5.0 2017-07-07 Alpha E9256BDB4A0FA61A30BF9B5294354618 G80 0.4.0 2017-05-10 Alpha E6EB8C753C4CE9A6197EC06F3C4CB848 G80 0.3.0 2017-04-06 Alpha EDB489B34BC8E249D47160EA3AFE466C G80 0.2.0 2017-03-07 Alpha 4EAA86216B6FFCDE937D1CCFD9558356 G80 0.1.0 2016-12-16 Alpha 5C93CCA961904F25BB56A9B9AD7C501A G120 Firmware Date Status MD5 G120 0.4.0 2017-05-10 Alpha 1C09A3C7D5305B03F0FF51884ACBD2F2 G120 0.3.0 2017-04-06 Alpha 57836246074A8E729EE3D6C6BCF76F55 G120 0.2.0 2017-03-07 Alpha 66EAA71A4A7D1B96AC9CD7C892DAA3CE G400 Firmware Date Status MD5 G400 0.4.0 2017-05-10 Alpha 03859F270F8B16CE4D40245918065E88 G400 0.3.0 2017-04-06 Alpha 8AA7E83ED7A62A94F0833569A6A12FEE EMX Firmware Date Status MD5 EMX 0.6.0 2017-xx-xx Alpha x USBizi Firmware Date Status MD5 UZBizi 0.6.0 2017-xx-xx Alpha x Cerb Firmware Date Status MD5 Cerb 0.5.0 2017-07-07 Alpha 4F8C039EC6D0206D7FC97083E8765EC7 Netduino3 Firmware Date Status MD5 Netduino3 0.5.0 2017-07-07 Alpha F6C51E2E7286262D4652D40CAAB1731A Quail Firmware Date Status MD5 Quail 0.5.0 2017-07-07 Alpha 714AD4715964A7B6CA3A23C67370A5EA"
  },
  "tinyclr/internetofthings.html": {
    "href": "tinyclr/internetofthings.html",
    "title": "Internet of Things",
    "keywords": "Internet of Things A modern system is not complete without support for the internet and the cloud. TinyCLR OS includes everything you need to be online. (details coming soon)"
  },
  "tinyclr/accessories/intro.html": {
    "href": "tinyclr/accessories/intro.html",
    "title": "TinyCLR OS Accessories",
    "keywords": "TinyCLR OS Accessories There are thousands of accessories that can be used with boards supported by TinyCLR OS, especially FEZ . However, we have hand picked a few of our favorites and then built the necessary drivers for them. Have a list of your own and want to contribute? Talk to us, directly on through the community forum ."
  },
  "tinyclr/boards/intro.html": {
    "href": "tinyclr/boards/intro.html",
    "title": "Boards Intro",
    "keywords": "Boards Intro While TinyCLR OS can be ported to other devices, we are providing a ready port for few popular boards. One of the ports is for FEZ, which is the official TinyCLR OS board. It will always have the latest and greatest and should be used as a reference for new ports. Firmware Update The firmware needs to be updated to match the assemblies loaded by Visual Studio. If you see an error message about a checksum error then your project's assemblies version does not match the veriosn loaded on the device. Each board will have details on how to load its firmware. Other Supported Devices Several of the GHI Electronics' products support TinyCLR OS. Check the individual hardware pages to see which devices support TinyCLR OS."
  },
  "tinyclr/porting/native_interops.html": {
    "href": "tinyclr/porting/native_interops.html",
    "title": "Native Interops in TinyCLR",
    "keywords": "Native Interops in TinyCLR Interops allow you to write a class in managed code that is partially or entirely implemented in native code. This is useful for time critical tasks, things that would take too long in managed code, or interacting with native functionality not exposed through managed code. Keep in mind that while native code executes, all managed threads are blocked and if you crash in native code, managed code also crashes. To get started, create a TinyCLR project called InteropTest . In the project properties window, go to the TinyCLR OS tab. Check both the Generate native stubs for internal methods and the Generate bare native stubs checkboxes. Next, define your native API. Any method that you plan to implement in native code must be declared extern and be decorated with the System.Runtime.CompilerServices.MethodImpl attribute that is constructed with MethodImplOptions.InternalCall . Static and instance functions, static and instance constructors, finalizers, and property set and get bodies can all be implemented native. They can have any visibility, can take any number or types of parameters, and can return any type. For example: class MyNativeClass { private int field = 5; [MethodImpl(MethodImplOptions.InternalCall)] public extern string MyNativeFunc(uint param1); public extern int MyNativeProperty { [MethodImpl(MethodImplOptions.InternalCall)] get; } } Once you have your native API defined, build your project. In the output folder, find and open pe and then Interop . In there are three files that let TinyCLR connect the managed methods to the native methods. There are two main files that have the same name as your project. These define the entire API. Importantly, there is an object that has the assembly name, its checksum, and an array of its methods. The remaining file contains function stubs for each native method you need to implement from the MyNativeClass class. Each function has a single parameter of type TinyCLR_Interop_MethodData that can be found in the TinyCLR.h file. This type has two memebers: an opaque stack type that you pass to other interop functions and the API provider that gives you access to the runtime. You can use this API provider to find the interop provider. The interop provider allows you to read and write object fields, read arguments passed to the function, write to reference arguments, set the return value, raise other events, and create new managed objects. The following code shows reading from a field and setting it as the return value of the property: TinyCLR_Result InteropTest_InteropTest_MyNativeClass::MyNativeProperty___I4(const TinyCLR_Interop_MethodData md) { auto ip = (const TinyCLR_Interop_Provider*)md.ApiProvider.FindDefault(&md.ApiProvider, TinyCLR_Api_Type::InteropProvider); TinyCLR_Interop_ManagedValue self; TinyCLR_Interop_ManagedValue ret; TinyCLR_Interop_ManagedValue field; ret.Type = TinyCLR_Interop_ManagedValueType::I4; ip->GetThisObject(ip, md.Stack, self); ip->GetField(ip, self, InteropTest_InteropTest_MyNativeClass::FIELD___field___I4, field); ip->GetReturn(ip, md.Stack, ret); ret.Data.Numeric->I4 = field.Data.Numeric->I4; return TinyCLR_Result::Success; } Now you need tp compile these files. If you don't have GCC yet, see the porting guide to find out how to install GCC. To compile using GCC, the easiest way is to use a makefile and a scatterfile. We've provided samples of each below. The makefile is setup to compile all cpp in the same directory it is and to do using for a Cortex M4 architecture. If you're not on CortexM4, change the MCU_FLAGS parameter accordingly. The output file is InteropTest.bin . You can change that with the OUTPUT_NAME property. OUTPUT_NAME = InteropTest LINKERSCRIPT_NAME = scatterfile MCU_FLAGS = -mcpu=cortex-m4 -mthumb INC_DIRS = -I. CC = arm-none-eabi-g++.exe LD = arm-none-eabi-g++.exe OC = arm-none-eabi-objcopy.exe CC_FLAGS = $(INC_DIRS) $(MCU_FLAGS) -Os -std=c++11 -xc++ -Wall -Wabi -w -mabi=aapcs -fPIC -fno-exceptions -fno-rtti -fno-use-cxa-atexit -fno-threadsafe-statics LD_FLAGS = $(MCU_FLAGS) -nostartfiles -lc -lgcc -T $(LINKERSCRIPT_NAME) -Wl,-Map,$(OUTPUT_NAME).map -Wl,--oformat -Wl,elf32-littlearm OC_FLAGS = -S -O binary SRC_FILES = $(wildcard *.cpp) OBJ_FILES = $(patsubst %.cpp, %.obj, $(SRC_FILES)) rebuild: clean build clean: del $(OBJ_FILES) $(OUTPUT_NAME).bin $(OUTPUT_NAME).elf $(OUTPUT_NAME).map build: $(OBJ_FILES) $(LD) $(LD_FLAGS) -o $(OUTPUT_NAME).elf $^ $(OC) $(OC_FLAGS) $(OUTPUT_NAME).elf $(OUTPUT_NAME).bin %.obj: %.cpp $(CC) -c $(CC_FLAGS) -o $@ $^ Because TinyCLR can't currently dynamically relocate your code, you'll need to provide the proper base and length values for the RLI region in the scatterfile by changing the RLI_BASE and RLI_LENGTH placeholders. You can find the RLI region for your device, if it has one, in the device's specifications. MEMORY { SDRAM (wx) : ORIGIN = RLI_BASE, LENGTH = RLI_LENGTH } SECTIONS { . = ALIGN(4); .text : { *(.text) } .rodata ALIGN(4): { *(.rodata ) } .data ALIGN(4): { *(.data) } .bss ALIGN(4): { *(.bss) } } Lastly, make sure that you place TinyCLR.h in the folder so that the interop files can see it. You need to use the file that corresponds to the release of the firmware you are running. To execute the makefile, you'll need to have make installed. You can get it from a toolkit like MinGW or, if you're on Windows 10, the Windows Subsystem for Linux. Once you have make installed, just navigate to the folder with the makefile and interop files in a shell and execute make build . Tip If you use the Windows Subsystem for Linux, you'll need to change del in the makefile to rm . Once you have a compiled image, look in the map file to find out where the interop definition variable Interop_InteropTest (if you're using the default names) got placed. You'll need to pass this address to the managed function that registers the interop. In managed code, add the compiled binary image as a resource and use the Marshal class to copy it into the correct location in memory. Then call System.Runtime.InteropServices.Interop.Add and pass it the address of the Interop_InteropTest object from the map file. You need to do this every time your program runs and before you call any of the native methods in your interop class. var interop = Resources.GetBytes(Resources.BinaryResources.InteropTest); Marshal.Copy(interop, 0, new IntPtr(0x20016000), interop.Length); Interop.Add(new IntPtr(0x2001607C)); var cls = new MyNativeClass(); var val = cls.MyNativeProperty;"
  },
  "tinyclr/tutorials/i2c.html": {
    "href": "tinyclr/tutorials/i2c.html",
    "title": "I2C",
    "keywords": "I2C I2C (pronounced eye-squared-sea, or eye-two-sea) was originally developed by Phillips to allow multiple chipsets to communicate on a 2-wire bus in home consumer devices. It has a master and one or more slaves sharing the same data bus. Instead of selecting the slaves using a digital pin like SPI, which consumes an additional I/O pin, I2C uses an addressing mechanism to communicate to a selected device. Before data is transferred, the master sends out a 7-bit address of the slave device it wants to communicate with. It also sends one bit indicating whether it wants to send data to the slave or receive data from the slave. When a slave sees its address on the bus, it will acknowledge its presence. At this point, the master can send or receive data. The master will start data transfers with a \"start condition\" before it sends any address or data and then end it with \"stop condition\". The two wires used to communicate between the I2C Master and the I2C salves are called SDA and SCL lines; SDA stands for Serial Data, and SCL is Serial Clock. This is a partial demo showing the use of I2C. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.I2c; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var settings = new I2cConnectionSettings(0x1C)// the slave's address { BusSpeed = I2cBusSpeed.FastMode }; var device = I2cDevice.FromId(FEZ.I2cBus.I2c1, settings); device.Write(new byte[] { 1, 2 });// write something device.WriteRead(...)// this is good for reading registers } }"
  },
  "tinyclr/tutorials/intro.html": {
    "href": "tinyclr/tutorials/intro.html",
    "title": "TinyCLR Tutorials",
    "keywords": "TinyCLR Tutorials Here you will find tutorials covering different features of the TinyCLR OS. We try to keep the documents hardware-generic as much as possible but when we can't, we use FEZ as a reference. System Setup Follow these steps to setup your development machine. Starting a New Project Open Visual Studio, select File > New Project . There should be a TinyCLR option under Visual C# Click the \"OK\" button a project and program are created. The project has only one C# file, called Program.cs . C# source files are listed in the Solution Explorer window. If the Solution Explorer is not opened, use the View > Solution Explorer menu. Adding NuGet Packages TinyCLR OS uses NuGet packages, all libraries will be downloaded through NuGet. Because of this, there will be no SDK to install or machines to lock to specific versions. Simply use NuGet to download any needed version of any needed library on a per-project basis. To manage your NuGet packages, right click on your Project in the Solution Explorer and select Manage NuGet Packages Local Hosting NuGet packages Since TinyCLR OS is still so new, we haven't yet uploaded any packages to NuGet, so make sure to download the available libraries, extract the archive, and place them in a local NuGet feed. To do this you'll have to point Visual Studio to that local NuGet feed. After selecting Manage NuGet Packages select the \"Package Source\" Setting icon. Next you'll click the \"+\" to add an new Package source. Then select the location where the NuGet packages are stored locally, by pressing the ... icon. After Selecting the local folder where the downloaded NuGet packages are. You can select the \"Installed\" Tab to view the NuGet Packages installed. Selecting the \"Browse\" Tab will show all the NuGet packages located in your local NuGet feed. Those installed are noted with a GREEN check mark in front of the name. To install one of the packages. The last thing to do is accept the licensing agreement. And, that's it! You're now ready to start programming using TinyCLR OS. Fit the F5 key to build and deploy your application. (add more images for build and deploy and see a message on the output window)"
  },
  "brainpad/courses/programming/vb/intro.html": {
    "href": "brainpad/courses/programming/vb/intro.html",
    "title": "Introduction to Visual Basic",
    "keywords": "Introduction to Visual Basic Visual Basic is a modern .NET programming language. It is as powerful as any of the other programmign languiages but its code is more englich-like, making it a student/teacher favorite. The courses are in the process of being created. Please bear with us. Overview Students will learn how to create projects in Visual Studio along with programming basics. Applications in this lesson will be limited to the BrainPad object, If statements, a While loop and the template functions. Guidelines Prerequisites: None Ages 12 and up PC setup with Visual Studio 2017, TinyCLR OS and Nuget packages installed. Supplies: BrainPad and microUSB cable. Install Visual Studio and Download .vsix file Install Visual Studio Community 2017. Select the Community download. Skip this step if you have Visual Studio 2017 installed. Visual Studio 2017 Download Starting a New Project Connect your BrainPad to your computer using a microUSB cable. Next Open Visual Studio select File>New>Project and under Other Languages select Visual Basic>TinyCLR and choose the BrainPad Application . Change the Location to C:\\Users\\<YourUsername>\\Desktop\\ then name the project BrainPad_Project. From Visual Studio, select File > New > Project. Creating the BrainPad_Project BrainPad TinyCLR Application. Once created, you'll be presented with a Program.vb tab. The Program.vb file and its contents are shown. This file contains the default code when you first create a project. The lines in green that begin with ' are called comments, and they generally describe what the code does. Take a moment to review them. Let's run the code to see these comments' descriptions come to life. Connect the BrainPad and press the F5 function key or the Start button. Press the Start button to run the Program. Visual Studio will now run the code, a few things will happen and the display will now have the text \"Hello, world!\" . The display shows \"Hello world\" What happened exactly? Our application began by calling the BrainPadSetup() function. This function is called one time, when the application starts, and is generally used to set things up. In this case, it executed the BrainPad.Display.DrawText line to instruct the display to show the text \"Hello, world!\" After BrainPadSetup() was finished, the application called BrainPadLoop() . Code placed inside this function is executed in an infinite loop. This is why the code that turns the LED on and then off again never stops. Exercise Change the text to make the program print your name on the display. Answer Change this line to your name instead of \"Hello World!\" BrainPad.Display.DrawText(0,0,\"YOUR NAME HERE\") The BrainPad Object The world around us is full of objects. Every person, table or circuit board is an object. If we were to ask a person to say \"hello,\" we'd be asking an object to perform a task. The same concept can be applied to code. Like in the previous application we ran, the BrainPad was asked to control the display and light bulb through the BrainPad object. The BrainPad object itself, is a piece of code that is contained in one file. This was developed by GHI Electronics to cover the internals of the BrainPad . This enables students like you, with an easy way to control the BrainPad circuit board. After typing BrainPad , press the period key to get a list of all available options for this object, like Display . Using IntelliSense we can see the options offered by the BrainPad object. Now we can use the arrow keys to go up and down in the list to find the Display , and then press the period key again to see what options are the available for the Display . Using IntelliSense we can see the options offered by the Display object. Visual Studio does a great deal of simplifying programming by automatically listing the available options for each object. Now that we know how to use the BrainPad object, let's learn about controlling the LED Light Bulb. The BrainPad LightBulb LED lights are used in many different electronic devices. Here we will test the LightBulb by turning it GREEN , then ON and OFF . Copy and paste the code from Example 1 into your project's BrainPadSetup() function. BrainPad.LightBulb.TurnOff() BrainPad.LightBulb.TurnGreen() BrainPad.LightBulb.TurnOff() BrainPad.LightBulb.TurnGreen() Put this code inside the BrainPadSetup() function. Now, press F5 to run the code and you'll see the LightBulb turn GREEN and stay on. This happens because our code is executed faster than we can see. Problem Solving Since applications execute extremely fast, we need to slow them down to figure out the problem. This way we can see what is happening or if the results are as expected. We will start by stepping in code to see what the application does at a slow speed. Stepping in Code Add a breakpoint at the first line of code inside of BrainPadSetup() by moving the cursor to that line and pressing the F9 We've added a breakpoint on line 5. Press F5 to run the application. The project will be built and deployed but then the execution will stop at the breakpoint. The program has executed up to the breakpoint. Press the F10 key to execute the current line, which turns the green light off. Now press the F10 key again, and the LightBulb will turn GREEN . The next steps will continue through the rest of the code. When you reach the closing curly bracket, press F5 to stop. Now that we know our code works (it's just happening too fast) we can add some delays so we can see the light turn on and then off. Delays in Code In order to see what's going on we need to add some delays in the code. This is done by telling the BrainPad to wait between tasks. BrainPad.LightBulb.TurnOff() BrainPad.Wait.Seconds(0.5) BrainPad.LightBulb.TurnGreen() BrainPad.Wait.Seconds(0.5) BrainPad.LightBulb.TurnOff() BrainPad.Wait.Seconds(0.5) BrainPad.LightBulb.TurnGreen() This code waits half a second (0.5) between turning the Lightbulb GREEN and OFF. Copy and paste the code from above into your project's BrainPadSetup() function. Run the code and observe the LightBulb again. You should now see the LightBulb turning GREEN and off every half a second. Exercise Create a Traffic Light simulation using the following logic and the LightBulb: Turn the light on GREEN Wait 5 seconds. Turn the LightBulb off. Turn the light on YELLOW Wait 2 seconds. Turn the LightBulb off. Turn the light on RED Wait 5 seconds. Answer BrainPad.LightBulb.TurnGreen() BrainPad.Wait.Seconds(5) BrainPad.LightBulb.TurnOff() BrainPad.LightBulb.TurnYellow() BrainPad.Wait.Seconds(2) BrainPad.LightBulb.TurnOff() BrainPad.LightBulb.TurnRed() BrainPad.Wait.Seconds(5) While Loop The previous exercise turned the LightBulb several colors but it only did it once. We could repeat the code over and over to make the traffic light run a few more times but what if we want this to run indefinitely? This is where While loops come in handy. While BrainPad.Looping 'Your code End While Code inside a while loop will be executed indefinitely. Code inside a while loop will be executed indefinitely as long as its condition is met. In our case, we'll use a constant value from the BrainPad object called Looping . This constant always returns true, which causes the loop's condition to always be met. While BrainPad.Looping BrainPad.LightBulb.TurnGreen() BrainPad.Wait.Seconds(0.5) BrainPad.LightBulb.TurnOff() BrainPad.Wait.Seconds(0.5) End While This code will blink the LightBulb GREEN on and off for half a second indefinitely. Let's keep things simple and blink the LightBulb GREEN every half a second. Copy and paste the code from above into your project's BrainPadSetup() function. Run the code and observe the LightBulb. Tip The BrainPadLoop() function does the same thing as our While loop behind the scenes, so you can use this function in your application to simplify things. Understanding The Loop To further understand what's going on, add a breakpoint by moving the cursor to the first line where we turn the light GREEN and press F9 . This will add a breakpoint and pause the application as soon as it reaches that line. block Add a breakpoint while the application is running Now use F10 to step through the code and when the program reaches the end of the While loop it will go back to the beginning. Stop the program execution by pressing the STOP button. The stop button will stop the application that's running. Now, reset the BrainPad and note how the green light is still blinking but this time without the need for Visual Studio. In fact, you can connect the BrainPad to any appropriate power source (such as a phone charger) and the LightBulb will turn on GREEN and will blink without the need for a PC. Exercise Make the LightBulb cycle through 3 different colors indefinitely. Answer Public Sub BrainPadSetup() While BrainPad.Looping BrainPad.LightBulb.TurnGreen() BrainPad.Wait.Seconds(0.5) BrainPad.LightBulb.TurnRed() BrainPad.Wait.Seconds(0.5) BrainPad.LightBulb.TurnYellow() BrainPad.Wait.Seconds(0.5) End While End Sub If Statement An If statement (or conditional statement) checks to see if a statement is TRUE or FALSE and then does one of two things depending on the result. Like if the DOWN button is pressed, turn the LightBulb GREEN . Public Sub BrainPadSetup() BrainPad.LightBulb.TurnGreen() If BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnOff() End If End Sub Pressing and hold the down button when running this program will turn the LightBulb GREEN. For the code above to work, you have to be holding the button down at the time the program is deployed. This is because once the If statement is reached, the program will continue executing until the program ends. To solve this hard to reach goal, we need to repeatedly check if the button is pressed, as seen in the above code. This is where a While loop comes in handy. Let's use the BrainPadLoop() function to simplify things per the tip earlier . Public Sub BrainPadSetup() BrainPad.LightBulb.TurnOff() End Sub Public Sub BrainPadLoop() If BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnOff() End If End Sub The above code makes sure the LightBulb is OFF and then it falls into an infinite loop. However, this program still has a bug. Run the program and test it. The LightBulb will be OFF when the program runs and then once the down button is pressed the the LightBulb turn GREEN . That is all good so far, but when the button is released, the LightBulb never turns OFF . Can you guess why? Try stepping in the code to see what happens when the button is pressed and when it is not pressed . Computers are strict on following orders. In previous examples, the LightBulb never turned OFF because we actually never told the program to turn the LightBulb OFF . This means we have to tell the program to turn the LightBulb ON when the button is pressed and we also have to tell it to turn the LightBulb OFF when the button is not pressed . Public Sub BrainPadSetup() BrainPad.LightBulb.TurnOff() End Sub Public Sub BrainPadLoop() If BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnGreen() End If If Not BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnOff() End If End Sub This code loops indefinitely checking if the down button is pressed. If it is pressed, the LightBulb will turn on GREEN The above code first makes sure the LightBulb is off and then it falls into an infinite loop. However, this program still has a bug. Run the program and test it. The LightBulb will be off when the program runs and then once the down button is pressed the the LightBulb turn GREEN . That is all good so far, but when the button is released, the LightBulb never turns off. Can you guess why? Try stepping in the code to see what happens when the button is pressed and when it is not pressed . Computers are strict on following orders. In previous examples, the LightBulb never turned off because we actually never told the program to turn the GREEN LightBulb off. This means we have to tell the program to turn the light on when the button is pressed and we also have to tell it to turn the LightBulb off when the button is not pressed as shown. Public Sub BrainPadSetup() BrainPad.LightBulb.TurnOff() End Sub Public Sub BrainPadLoop() If BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnGreen() End If If Not BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnOff() End If End Sub This code will turn the LightBulb GREEN when the down button is pressed, and off when the down button **is not pressed** the **LightBulb** will turn on While the BrainPad doesn't have a method called BrainPad.Button.IsDownNotPressed() we can continue to use BrainPad.Button.IsDownPressed() but with If Not before it to represent if the button is not pressed . Now when you run it, not pressing the button will turn/keep the LightBulb off. Exercise Turn the LightBulb GREEN when the up button is pressed . Turn the LightBulb off when the down button is pressed . Turn the LightBulb RED on when the left button is pressed and BLUE when right button is pressed Answer Public Sub BrainPadSetup() BrainPad.LightBulb.TurnOff() End Sub Public Sub BrainPadLoop() If BrainPad.Buttons.IsUpPressed() Then BrainPad.LightBulb.TurnGreen() End If If BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnOff() End If If BrainPad.Buttons.IsLeftPressed() Then BrainPad.LightBulb.TurnRed() End If If BrainPad.Buttons.IsRightPressed() Then BrainPad.LightBulb.TurnRed() End If End Sub Else Statement The Else statement is always used with the If statement and has a very useful purpose that would be perfect for the last example. Previously, we needed to check if the button is pressed and if the button is not pressed. We can simplify this by catching when an If statement isn't true using Else as shown in the code below. Public Sub BrainPadSetup() BrainPad.LightBulb.TurnOff() End Sub Public Sub BrainPadLoop() If BrainPad.Buttons.IsDownPressed() Then BrainPad.LightBulb.TurnGreen() Else BrainPad.LightBulb.TurnOff() End If End Sub This code uses an else statement to check if a button is pressed or not to turn the LightBulb green and off. Or & And Operators The most used logical operators are the Or and And operators. These are typically used within the If statement. In the example below, we want the buzzer to generate a 5,000 Hz sound when both the up and down buttons are pressed. This is accomplished by using an && operator between IsUpPressed() and IsDownPressed() . Public Sub BrainPadLoop() If BrainPad.Button.IsUpPressed() And BrainPad.Button.IsDownPressed() Then BrainPad.Buzzer.Start(5000) Else BrainPad.Buzzer.Stop() End If End Sub This code checks if both up and down are pressed, if so it plays a high pitch sound. Exercise Turn the LightBulb GREEN on and play the buzzer at 5,000 Hz whenever the up or down button is pressed. Pressing both or either one will have the same effect. Extra Credit Tip: Use nested statements such as an If statement inside another If statement."
  },
  "hardware/intro.html": {
    "href": "hardware/intro.html",
    "title": "Hardware Introduction",
    "keywords": "Hardware Introduction These pages provide specific details on each of our devices such as technical specifications, schematics, manuals, and datasheets. Tip Products may be grouped under a family, for example FEZ Panda II can be found under the USBizi. Use the search box in the top right corner it is a good tool for finding these products."
  },
  "brainpad/courses/programming/csharp/threading_and_events.html": {
    "href": "brainpad/courses/programming/csharp/threading_and_events.html",
    "title": "Threading and Events",
    "keywords": "Threading and Events"
  },
  "brainpad/courses/programming/vb/variables_and_nested_statements.html": {
    "href": "brainpad/courses/programming/vb/variables_and_nested_statements.html",
    "title": "Variables and Nested Statements",
    "keywords": "Variables and Nested Statements Overview Students will learn about variables, strings, while loops and nested statements. Guidelines Prerequisites: None Ages 12 and up PC setup with Visual Studio 2017, TinyCLR OS and Nuget packages installed. Supplies: BrainPad and Micro USB cable. Arguments Arguments are values passed on to methods. For example, to set the frequency of the buzzer, a value is passed on to that method. The 3000 is the arguments. BrainPad.Buzzer.Start(3000) Arguments are also used when adding delays. Here, the 0.2 is the argument. BrainPad.Wait.Seconds(0.2) Variables can be constants, like the numbers used above. They can also be variables, which will be explained in the coming sections. Also, arguments can also be something completely different! Class Program Public Sub BrainPadSetup() 'Declared but not used End Sub Public Sub BrainPadLoop() If BrainPad.Buttons.IsPressed(BrainPad.Buttons.Button.Up) Then BrainPad.WriteDebugMessage(\"Up button is pressed\") Else BrainPad.WriteDebugMessage(\"Up button is not pressed\") End If End Sub End Class What is that argument used with Button.IsPressed() ? In this case, the Button.IsPressed takes an argument to specify which button is to be checked. This code BrainPad.Buttons.IsPressed(BrainPad.Buttons.Button.Up) Is much clearer than: BrainPad.Button.IsPressed(4) What is button 4? In fact, internally the up button may be number 4 but remembering this will be difficult. Exercise Try to use the wrong argument type then build the project to observe the error messages. Integer Variables Variable is a location in memory that is reserved for us to use. Instead of knowing where the memory is and how it is located, the system gives us an access to that memory using a name we select. Dim count As Integer The above line instructs the system to reserve (Dim) a variable that is named count and the variable type is an Integer. The name can be use any letters from the alphabet and any numbers but it must not start with a number and it cant contain spaces. Here are few allowed name examples: Dim count123 As Integer Dim countMeIn As Integer Dim count2var As Integer Variables in small programs can use simply names. It can simply be just x . However, using a meaningful name is very important when writing any serious program, as there maybe tens, or hundreds, of variables. The variable now can store numbers. Note that the variable can be used in the equation and in the result as well. count = count + 2 The above code will add 2 to the count. Math can be used as well. count = 5 + result After selecting an appropriate name, an appropriate type is needed. The type tell the system how much memory to reserve for that one variable. The most widely used variable is an Integer, and can hold very large numbers, even negative numbers. We suggest the use for Integers for everything, except when fractions are needed. More on fractions later. Changing Tones Use the code below: Class Program Dim frequency As Integer Dim increment As Integer Public Sub BrainPadSetup() frequency = 0 increment = 0 End Sub Public Sub BrainPadLoop() If BrainPad.Button.IsUpPressed() Then increment = 100 End If If BrainPad.Button.IsDownPressed() Then increment = -100 End If If increment <> 0 Then frequency = frequency + increment increment = 0 BrainPad.Buzzer.Start(frequency) BrainPad.WriteDebugMessage(frequency.ToString()) BrainPad.Wait.Seconds(0.2) BrainPad.Buzzer.Stop() End If End Sub End Class The previous example loops 5 times every second and sets the buzzer to a frequency. The frequency is a variable, also named frequency in this example. The buttons will be checked and when the up button is pressed the frequency is incremented by 100 and when the down button is pressed the frequency is decremented by 100. The value held by the frequency variable is also printed using the Debug.Print statement. Can we now determine the highest frequency a person can hear? The if-statement with Variables The same way the if-statement was used to check if a button was pressed, it can be used with variables. If frequency is larger than 6000 then turn the red light off, else turn the red light off. Add this code inside the while-loop in the previous code example. If frequency > 6000 Then BrainPad.LightBulb.TurnRed() Else BrainPad. LightBulb.TurnOff() End If Exercise Add a variable that starts at 0 and then it is incremented by 1 in every loop. Once the variable reaches 1000, turn the LightBulb yellow. Print the variable value on the output window and make sure its incrementing, then verify the LightBulb turns yellow when the variable go over 1000. Inspecting Variables Printing the variable value worked well for small programs with a single variable. It is not practical to continuously print every variable out. Instead, we can use the debugger feature to pause the code and inspect variables. Class Program Dim count As Integer = 0 Dim increment As Integer = 0 Public Sub BrainPadSetup() End Sub Public Sub BrainPadLoop() count = count + 1 BrainPad.DebugPrint(count) BrainPad.Wait.Seconds(0.2) End Sub End Class Add a breakpoint in the loop in the previous program and step through code. Move the mouse over the count variable and wait a second. A pop up window will come up showing the value of the count variable. The watch windows can be used with important variables that need to be inspected regularly. Locate the watch window and type the variable name in the left sell. This will show the variable value and type. Exercise Run the previous program for few loops, then pause the program, or add a breakpoint. Inspect the value on the watch window. It should be something other than 0. Change the value manually to 0 and then re-run the program and observe how the output window now shows the variable going back counting from 0. Double Variable While an Integer can hold very large numbers, it cant hold fractions. For example, there is no way to set an integer to 0.5 or 123.8. The variable type Double should be used whenever fractions are needed. Why not use a Double variable since it can hold large numbers and fractions? You can, but it requires more memory and processing so it isn't as efficient. Class Program Dim frequency As Double Dim increment As Integer Public Sub BrainPadSetup() frequency = 0 increment = 0 End Sub Public Sub BrainPadLoop() If BrainPad.Button.IsUpPressed() Then increment = 100 End If If BrainPad.Button.IsDownPressed() Then increment = -100 End If If increment <> 0 Then frequency = frequency + increment increment = 0 BrainPad.Buzzer.Start(CType(frequency, Integer)) BrainPad.WriteMessageOnComputer(frequency) BrainPad.Wait.Seconds(0.2) BrainPad.Buzzer.Stop() End If End Sub End Class The previous example uses a Double instead of an Integer for the frequency. Since the Buzzer.Start() method expects an integer, the variable need to be converted using the CType(). This is demonstrating how using Double for everything is not desirable. Time to go back and have fun with our favorite green light! This example will turn the green light on for a specific time, set by a variable called delay. It then turns the light off for the same length of time. Pressing the up and down buttons control the delay variable, causing the light to be on and off for longer or shorter periods. The variable is also printed out using DebugOutput() . Class Program Dim delay As Double Public Sub BrainPadSetup() delay = 0.2 End Sub Public Sub BrainPadLoop() If BrainPad.Buttons.IsPressed(BrainPad.Buttons.Button.Up) Then delay = delay + 0.2 End If If BrainPad.Buttons.IsPressed(BrainPad.Buttons.Button.Down) Then delay = delay - 0.2 End If BrainPad.WriteDebugMessage(delay) BrainPad.LightBulb.TurnGreen() BrainPad.Wait.Seconds(delay) BrainPad.LightBulb.TurnOff() BrainPad.Wait.Seconds(delay) End Sub End Class Returned Values Some methods return a value, like when reading the light sensor. This value can be placed into a variable and then the variable can be used with if-statements. We have lights bulb and a light sensor on the BrainPad. Why not turn the light on when it is dark? This can be tested by turning the lights off inside the room or by placing a finger over the light sensor to block the light. Class Program Dim level As Double Public Sub BrainPadSetup() level = 0 End Sub Public Sub BrainPadLoop() level = BrainPad.LightSensor.ReadLightLevel() BrainPad.WriteDebugMessage(level) If level > 0.5 Then BrainPad.LightBulb.TurnOn() Else BrainPad.LightBulb.TurnOff() End If End Sub End Class How do we know what value to use as the threshold on when to turn the light bulb on? This is a perfect example on where inspecting variables is needed. Run the program and test by placing a finger over the light sensor to block the light. This may not work nicely and you need to adjust the threshold from 0.5 to something else. Take a look at the output window to see the light levels to determine what value work best for your needs. Then stop the program, change the threshold and then run the program again to test the results. Exercise Modify the last program to have a way to set the threshold using the up button. Hint, the threshold was a constant before but now it is going to be a variable that is set to whatever the light sensor returns when the button is pressed. Name the variable threshold and make sure it is type Double. Strings A string is a type of variable that holds text. BrainPad.WriteDebugMessage(\"Hello World!\") It is important to remember that the integer 2 and the string \"2\" are not the same thing. This maybe the same for us but internally in the system they are very different. Assuming x is an Integer, what value is in variable x? x = 2 + 2 The result is what you expect, 4. But now assume str is a string variable, what is the value of str? str = \"2\" + \"2\" The string is just text, not a number. When adding strings, the result is a string that combines the strings. The result from above is \"22\". This should make more sense if you try this example. str = \"Hello number \" + \"2\" The result is \"Hello number 2\". Note how even a space makes a difference in the last example. This code will generate an error since 2 is a number here not a string. str = \"Hello number \" + 2 ToString() One of the important built in method for variables is the ToString() method. This method will take the value from the variable and converts it into a string. Class Program Dim count As Integer=0 Public Sub BrainPadSetup() count = 0 End Sub Public Sub BrainPadLoop() count = count + 1 BrainPad.DebugOutput(\"Count: \" + count.ToString()) End Sub End Class The prior example uses a variable type integer that starts at zero and increments by one in every loop. It will then print the variable value in the Output Window. Exercise Show something like this in the output window: Finite while-loops The While loop and BrainPadLoop() have been used extensively so far. The While loop will run while something is true and since we have passed it the value True then it will loop forever. Is this statement true? 1 = 1 Yes 1 equals 1, that is true! So keeping that in mind, we can make a while-loop keep looping forever using this statement. Class Program Public Sub BrainPadSetup() Dim count As Integer count = 0 While 1 = 1 count = count + 1 BrainPad.WriteDebugMessage(\"Count: \" + count.ToString()) End While End Sub Public Sub BrainPadLoop() End Sub End Class Or True can simply be used. Class Program Public Sub BrainPadSetup() Dim count As Integer count = 0 While True count = count + 1 BrainPad.WriteDebugMessage(\"Count: \" + count.ToString()) End While End Sub Public Sub BrainPadLoop() End Sub End Class A While loop can also be finite, meaning will stop looping at some point. Class Program Public Sub BrainPadSetup() Dim count As Integer count = 0 While count < 10 count = count + 1 BrainPad.WriteDebugMessage(\"Count: \" + count.ToString()) End While End Sub Public Sub BrainPadLoop() End Sub End Class What did the last program do? It printed the count from 1 to 10. But count started at 0, not one. Shouldn't it print count 0? Time for debugging (troubleshooting). Start by setting a breakpoint at count = 0 and then step in the code to see what the value of count is (use watch window) and then see why the value 0 was never printed. Think about a fix before looking at the next code. The fix is very easy! Class Program Public Sub BrainPadSetup() Dim count As Integer count = 0 While count < 10 BrainPad.WriteDebugMessage(\"Count: \" + count.ToString()) count = count + 1 End While End Sub Public Sub BrainPadLoop() End Sub End Class What about the 10? Shouldn't the program print Count: 10? The answer is in the while-loop. In plain English, it says: run the following code as long as count is less than 10. Since 10 is not less than 10 then 10 will not be printed. The while-loop can be improved like this: While count <= 10 This new statement says run the loop as long as the count is less than or equals to 10. Exercise Write a program the prints all even numbers between 6 to 66. Nesting Some programs will have loops inside loops, or if-statements inside loops, maybe inside other if-statements and more loops! This is called nesting. While programmers should try to keep this simple to understand, nesting is sometimes required. How do we write a program that prints 1 to 10 repeatedly forever? This is accomplished by having two nested while-loops. One that counts 1 to 10, which goes inside another loop that loops infinitely. Class Program Public Sub BrainPadSetup() Dim count As Integer count = 1 While True While count < 10 BrainPad.WriteDebugMessage(\"Count: \" + count.ToString()) count = count + 1 End While End While End Sub Public Sub BrainPadLoop() End Sub End Class The above program will not work. It will print 1 to 10 one time only then the program will not end and it will not print anything after. Time again for debugging the code to determine what the issue is. Run the program and determine the cause of the error. The fix is simple but try to find it before peeking at the fixed code. Class Program Public Sub BrainPadSetup() Dim count As Integer count = 0 While True count = 1 While count < 10 BrainPad.WriteDebugMessage(\"Count: \" + count.ToString()) count = count + 1 End While End While End Sub Public Sub BrainPadLoop() End Sub End Class Exercise Write a program that prints 0 to 10 repeatedly when the up button is not pressed when it is bright. If it is dark the button doesnt do anything. Do not use And , instead nest the if-statements."
  },
  "hardware/legacy_products/mbuino.html": {
    "href": "hardware/legacy_products/mbuino.html",
    "title": "mBuino",
    "keywords": "mBuino The mBuino is a tiny keychain circuit. It is GHI Electronics contribution to the mbed community. Learn more here"
  },
  "hardware/legacy_products/gadgeteer/fez_hydra.html": {
    "href": "hardware/legacy_products/gadgeteer/fez_hydra.html",
    "title": "FEZ Hydra",
    "keywords": "FEZ Hydra FEZ Hydra is a .NET Gadgeteer product, that utilizes .NET Micro Frameworks (NETMF). Resources Schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading Bootloader v2 (coming soon!) Loading the Firmware (coming soon!)"
  },
  "hardware/legacy_products/netmf/chipworkx.html": {
    "href": "hardware/legacy_products/netmf/chipworkx.html",
    "title": "ChipworkX",
    "keywords": "ChipworkX ChipworkX is a NETMF System on Module. To use with NETMF, follow these setup instructions . Needs the NETMF 4.1 SDK. Resources User Manual"
  },
  "hardware/loaders/intro.html": {
    "href": "hardware/loaders/intro.html",
    "title": "Loaders Introduction",
    "keywords": "Loaders Introduction A loader is a small software that boots up the system and runs the firmware. It is also used to update the firmware. This section covers different loader features and usage details."
  },
  "tinyclr/release_notes.html": {
    "href": "tinyclr/release_notes.html",
    "title": "Alpha Release Notes",
    "keywords": "Alpha Release Notes 0.5.0 on 2017-07-07 Notes This release focuses on the public porting library and API -- though there are a few minor fixes and changes in other areas. As part of the new porting experience, we are also releasing a very early build of TinyCLR for the Netduino 3 and Quail mainboard! You can now port TinyCLR OS to run on your own system using the header file and library we provide -- as long as your architecture is supported. Currently, only Cortex M4 is available. Keep in mind the available API is still alpha and may change, especially USB client. See here for details. You can also create your own managed functions that can call into native code that you provide. These will be automatically wired into the system for a seamless experience. See here for details. To support this, we added a few more classes under System.Runtime.InteropServices . Most important is the Interop class. It allows you to add and remove interops from the system by providing it with the address in memory of the interop definition table. It expects you to load it into memory yourself using the Marshal class. You can use FindAll to get back a list of all interops registered in the system and RaiseEvent to trigger an event on the specified native event dispatcher. The NativeEventDispatcher class allows you to get an instance of the class to receive events that the specified dispatcher name receives (either from native code or Interop.RaiseEvent ). It has a single event that gets triggered whenever an event is received. There is only one instance per dispatcher name, so calls to GetDispatcher with the same name will return the same instance. Similar to Interop , Api can be used to add and remove native APIs from the system. It expects you to load the API into memory yourself and pass it the address of the API definition. You can query all registered APIs, find a specific API by name and type, and parse and creator selectors. Selectors are a string that represents an API name and index into its implementations of the form \"name\\index\". A default selector is set so that a specific API type can be returned without knowing the exact name, like the default GPIO controller on a system. The Api class is used internally by the devices library to talk to the native implementation via the implementation IntPtr provided for the given API name and index. In some cases you can use the GetDefault method on a given device provider to return the default registered API. If there is no default, like for PWM and others, you can pass the Id property in the specific pins class to the desired device provider. We added Marshal.GetDelegateForFunctionPointer to enable you to create a quick native interop for a specific address in memory that takes a single ref IntPtr parameter and returns nothing. DeviceInformation was also added to return the device name, manufacturer, and version set on the native side. After flashing the firmware for the first time on any device, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . Libraries Changes Added running device detection. Added listing, adding, and removing system interops. Added listing, adding, and removing system APIs. Added Marshal.GetDelegateForFunctionPointer . Added NativeEventDispatcher . Added provider IDs to pins. Added FEZ pinout. Added Expansion to BrainPad. Updated devices library to use the provider and native API model via a Provider class for each type. Core assembly was renamed to mscorlib . GetDeviceSelector and DeviceInformation.FindAll now throw an exception on use. Opening a non-existent UART now throws on construction. Changed DateTime.Ticks to use the same epoch as the desktop. Gpio write now fires ValueChanged . BrainPad accelerometer now uses the proper axes and scaling. BrainPad Image was renamed to Picture . BrainPad WriteOnComputer was renamed to WriteToComputer . BrainPad Servo SetMaxPulseWidth now has correct range in the exception message. Increased the duration and frequency of the BrainPad buzzer beep. Original BrainPad display now works. Replaced AutoShow flag on BrainPad with DrawTextAndShowOnScreen methods. Reworked BrainPad Servo API. Removed BrainPad Board class. Known Issues Software I2C can lock up the board if a slave device isn't connected or responds improperly. Formatting numbers that cross an assembly boundary can throw an exception. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. Device sharing modes are not respected. Partially transparent ellipses have weird artifacts. Pins are not currently reserved so you can create multiple objects on the same pin which behave incorrectly. Software I2C does not work. Firmware Changes Initial FEZ Cerberus, FEZ, Netduino 3, and Quail firmware release. All peripherals are now properly reset on startup. Gpio write values are stored when not in output model. Fixed PWM jittering. All frequencies now round down. Fixed gpio interrupts being slow and something getting missed. Known Issues Rapidly pressing the buttons on the BrainPad may corrupt the display. GpioChangeWriter generates an incorrect signal for periods above 50ms on G400. An 0xA2000000 error is sent over the debug transport when there is no deployment present. Many UART properties and events are not implemented. There is no firmware for G120 and G400 in this release. PWM on controller 8 and up does not work on the G80. Deploying over USB when out of memory crashes the board. Extension Changes Removed stray semicolon in BrainPad Visual Basic template. Changed BrainPad templates to have a BrainPad static class in them. Reduced the number of retries for connecting to device. Added namespace to C# BrainPad template. Known Issues The device may not load drivers on Windows 7 preventing Visual Studio from seeing it. Some uses of pattern matching may crash the C# compiler. Visual Basic resources page generates an incompatible resource file. Visual Basic resource files are wrapped in a second namespace. When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. Porting Changes Initial release of porting library and API. Known Issues Marshalling strings does not work. Marshalling DateTime and TimeSpan does not work. Creating and replacing managed objects does not work. CAN and USB host are missing. The USB client API is still very rough and will change. 0.4.0 on 2017-05-10 Notes This release primarily fixes several bugs; implements more of the serial API; adds DataReader , DataWriter , and Marshal classes; and reworks a lot of the BrainPad API. A new Storage library was added that moves some large members (like DataReader ) out of Devices that you may not always needed. There is more to be added to this library down the road. SignalGenerator , SignalCapture , and PulseFeedback were renamed to match the Windows 10 counterparts. Their API will be updated to match as well in a future release. The Marshal class under System.Runtime.InteropServices can be used like the old Register and AddressSpace classes to read and write memory. It also adds allocating and releasing unmanaged memory from the managed side that can be manipulated from the other members. You can see a quick example on using the new serial API here . You must use either the DataReader and DataWriter classes or use the WindowsRuntimeBufferExtensions to manipulate a Buffer since the internal array is no longer publicly accessible to match the UWP API. Pay attention to the Load and Store members. You can't read before calling Load and writes do not get flushed until you call Store . There has been no change to the G120 and G400 bootloaders in this release so you do not need to update them if you already have them on your device from the 0.3.0 release. After flashing the firmware for the first time on any device, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . Libraries Changes Fixed GpioPin.ValueChanged sender parameter type to be GpioPin. Fixed many of the Debug and Trace members not functioning properly. Fixed LowLevelDevicesController.DefaultProvider throwing an exception when null instead of falling back to the built-in providers. Fixed SerialDevice.Read not respecting the ReadTimeout value. Fixed SerialDevice.BytesReceived and IBuffer.Length not getting updated when reading. Fixed the exception that was thrown in BrainPad.Buttons when buttons are pressed. Fixed the exception that was thrown when using BrainPad.ServoMotor . Fixed PWM glicthing other pins on the same controller when changing one pin. Fixed Thread.Sleep not always sleeping for the proper amount of time. Fixed SerialDevice.ErrorReceived not being raised. Added EventArgs . Added WindowsRuntimeBufferExtensions . Added DataReader and DataWriter . Added various From methods to TimeSpan . Added InteropServices.Marshal . Added EditorBrowsable attribute to several members inherited from object to the BrainPad members. Added GHIElectronics.TinyCLR.Storage with WindowsRuntimeBufferExtensions , DataReader , and DataWriter in it. Updated the underlying value of the SerialError enum. Updated the BrainPad to be based around instance properties rather than static classes. Updated SerialDevice.Read to only support InputStreamOptions.Partial and InputStreamOptions.None . Moved InputStreamOptions , IInputStream , IOutputStream , IBuffer , and Buffer to the GHIElectronics.TinyCLR.Core assembly. Moved the BrainPad expansion pins to the pins library. Improved support for the original BrainPad in the driver. Improved many of the BrainPad APIs. Removed the members of Buffer that don't conform to the UWP API. Renamed SignalGenerator to GpioChangeWriter , SignalCapture to GpioChangeReader , and PulseFeedback to GpioPulseReaderWriter . Known Issues The original BrainPad display does not currently work with the GHIElectronics.TinyCLR.BrainPad library. Software I2C can lock up the board if a slave device isn't connected or responds improperly. ServoMotors.SetMaxPulseWidth has an invalid range in the exception message. Formatting numbers that cross an assembly boundary can throw an exception. Opening a non-existent UART will only throw when it is used. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. Firmware Changes Fixed the G30 sometimes getting stuck during deployment. Added another sector to the G30 deployment region. Known Issues Rapidly pressing the buttons on the BrainPad may corrupt the display. Gpio interrupts may be slow when Visual Studio is connected. Some frequencies may round up instead of down if the requested frequency cannot be met. An 0xA2000000 error is sent over the debug transport when there is no deployment present. GpioChangeWriter does not generate proper signals for periods above 50ms on G400. Extension Changes Added a flag on the TinyCLR OS property page to control stub generation style. Added the DebuggerNonUserCode attribute to the startup code in BrainPad templates. Removed the public modifier from the C# application template. Known Issues The Visual Basic BrainPad template has a semicolon in the startup file. The device may not load drivers on Windows 7 preventing Visual Studio from seeing it. Some uses of pattern matching may crash the C# compiler. Visual Basic resources page generates an incompatible resource file. Visual Basic resource files are wrapped in a second namespace. When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. 0.3.0 on 2017-04-06 Notes This release has several API additions. Some were added as features themselves (software SPI, SignalGenerator, etc) while others were added to support certain features (the VB runtime, string.Format, MemoryStream and IntPtr for Drawing, etc). We're working to align ourselves with the various .NET Reference Sources available. You'll also see many new icons throughout, application templates for the BrainPad, and common item templates. The NuGet packages that have dependencies (such as on Core), now require the major and minor versions to match. For example, the 0.3.0 Devices library depends on Core [0.3.0,0.4.0). This is to further our use of SemVer so that the native interop checksum only changes in major and minor versions. See the NuGet docs for more information. The biggest addition is the drawing library. It was designed to mirror System.Drawing from the desktop. The basic API is there but there is still more work to be done. To support this, a DisplayController was added to the devices library to configure the display. Since there is no config yet you need to configure the display every time your program starts. A notable change from NETMF is calling flush on a drawing surface the size of the display will no longer draw to the display. Only drawing surfaces created from the FromHdc method passing in the Hdc value from the DisplayController will flush to the display. At this time, only bmp images are supported. Make sure you add a reference to GHIElectronics.TinyCLR.Drawing if using bitmap or font resources. Since it's in NuGet now it isn't automatically added. Support for Visual Basic has also been reenabled. One important thing to keep in mind is that there is no longer a Microsoft.VisualBasic assembly. We are using the embedded runtime option provided by Roslyn. It relies on several APIs being present in the core library. We added several of the key APIs needed to enable common usage scenarios. If you find you're getting cryptic compile errors from locations not in your code, let us know so we can evaluate what additional APIs are required. Since the UWP API only supports a controller wide frequency, we had to rework PWM a little bit. There is no longer one controller like there is for GPIO, instead one controller exists for each frequency source. On devices like the G30 and G80, this is a timer. On devices like the G400, there are independent registers for each channel (so unfortunately there will be one controller per channel). The pins library has been updated to organize PwmPin around controllers. SignalGenerator, SignalCapture, and PulseFeedback have also been added, but their APIs will change in a future release to match the UWP style. You can also now change what gets returned by GetDefault calls on the various controllers by updating LowLevelDevicesController.DefaultProvider. The Diagnostics namespace now matches the desktop version more closely. WriteLineIf and Assert were added to Debug and Trace was added as well. All methods on Debug and Trace are marked with the Conditional attribute as expected using the DEBUG and TRACE constants respectively. There's also now a Listeners property on each. This is a collection that you can add to so you can receive whatever is written to Trace or Debug by registering a class derived from TraceListener. As on the desktop, both Trace and Debug share the same listener collection. By default, the collection is populated with a listener that prints to the debug transport which is now at Debugger.Log. Collect and GetTotalMemory were added to GC. Note that GetTotalMemory returns the amount of memory used, not free, to match the desktop. We're investigating APIs to return the amount free. The last notable change is that we implemented IntPtr and UIntPtr. For now, they're only used as the type of the Hdc property in drawing. We expect them to be used in more places going forward. Since these two types map to native int and native unsigned int in the CLR and the managed compilers emit those types when they encounter IntPtr or UIntPtr, we have also added initial support for those types in the interpreter and runtime as well. Let us know if you encounter any weird or hard to explain runtime issues. This release also includes the firmware for the G400. It requires an updated bootloader from the one provided on the G400 bootloader installation page . Simply download the bootloader installer from the installation page and replace Bootloader.bin with the bootloader provided in the TinyCLR download package (making sure to rename it to Bootloader.bin). This updated bootloader can still be used to install the NETMF G400 firmware. It will eventually replace the one provided on the installation page. After flashing the firmware for the first time on any device, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . You can see some examples of the new APIs added in this release here . Libraries Changes PWM now has one controller per frequency source (usually a hardware timer) allowing different frequencies for each controller. string.Format should now work in all cases. Formatting numbers (ToString(\"N2\"), etc) should now work in all cases. I2C read/write partial functions now return the proper result. Opening non-existent ports no longer crashes the firmware. CultureInfo, NumberFormatInfo, and DateTimeFormatInfo now implement IFormatProvider. Primitives (except Boolean), DateTime, TimeSpan, Guid, and Enum now implement IFormattable. Added the == and != operators to Guid. Added a drawing library and display configuration. Added Enum.GetUnderlyingType Added LowLevelDevicesController and the provider API model for SPI, I2C, GPIO. Added SignalGenerator, SignalCapture, and PulseFeedback. Added software providers for I2C and SPI. Added CompilerGenerated, SuppressMessage, and In attributes. Added class target to Conditional attribute. Added FormatException and OverflowException. Added InvariantCulture and CurrentCulture to CultureInfo. Added FormattableString and FormattableStringFactory. Added Collect and GetTotalMemory to GC. Added MemoryStream. Added parts of the CodeContracts namespace. Added implementations to IntPtr and UIntPtr. Added Debugger.Log. Added Trace. Added Assert and WriteLineIf to Debug. Added listeners collection to Trace and Debug and a default listener mapped to Debugger.Log. Added BrainPad. Known Issues The sender parameter in the ValueChanged event on GpioPin is an instance of IGpioPinProvider, not GpioPin. Opening a non-existent UART will only throw when it is used. SignalGenerator may fail for small durations. An exception is thrown in BrainPad.Buttons when buttons are pressed. An exception is thrown when using BrainPad.ServoMotor. Some frequencies may round up instead of down if the requested frequency cannot be met. In the Debug class, only WriteLine(string) functions correctly. Firmware Changes G30 should no longer get stuck at waiting for device to initialize. PWM no longer takes 40 seconds to start on the G30 and G80. GPIO interrupts now work on the G120E. Added support for native int and native unsigned int in runtime Added G400 firmware. Known Issues Deploying to the G30 sometimes fails when writing a sector. An 0xA2000000 error is sent over the debug transport when there is no deployment present. Extension Changes Assemblies larger than sector size can now be deployed. Added Visual Basic support. Added BrainPad Application templates Added common item templates. Added icons throughout. NuGet packages now have a better range dependency for dealing with assembly checksums. Known Issues Visual Basic resources page generates an incompatible resource file. Visual Basic resource files are wrapped in a second namespace. Support for the embedded Visual Basic runtime is incomplete and some uses may throw cryptic compile errors. When adding an image or font to a resx file a reference to the drawing assembly is not automatically added. 0.2.0 on 2017-03-07 Notes You cannot use projects you made for the 0.1.0 version. You must recreate them and re-add your code files because of the changes to the project templates to make them more closely align them with the desktop .NET templates -- you'll notice the only difference is a few properties which prevent inclusion of reference assemblies. The templates also use the .NET Framework 4.5.2 target framework. This is only for NuGet compatibility going forward and does not mean you can use other libraries targeting that framework. This was done in anticipation of broader project system support of the new PackageReference format currently used in .NET Core which fails with unknown target frameworks. The MSBuild package is no longer provided or required. The metadata processor tool has moved internally to the extension and is invoked during deployment to the device. This means that pe and pdbx files are no longer redistributed with their assemblies -- they appear in a pe folder under the output directory when you deploy. We have also rewritten how dependencies are detected for deployment. If you notice any weird failures around assembly resolution or deployment, let us know and send us the entire project as-is so we can diagnose it. The information displayed while deploying to the device has also been improved to show more information about what is going on and what stage the deployment is in. We've also reworked incremental deployment so that assemblies are deployed one to a flash sector (if space allows) to enable re-deploying only the assemblies that have changed on a sector by sector basis. This greatly increases deployment speed on devices which a large number of flash sectors allocated to deployment. This release also includes the firmware for the G120 and G120E. Because the current GHI bootloader on the G120 expects to load TinyBooter, we have provided a second stage bootloader with this preview that you must deploy using the existing GHI bootloader as if you were deploying TinyBooter. Once it is deployed and you restart the device, you'll notice that it starts our newer GHI bootloader 2.0 . You can then use this second bootloader to deploy the TinyCLR OS firmware. Asserting LDR0 will enter the second bootloader while asserting both LDR0 and LDR1 will enter the original bootloader and allow you to return to NETMF. After flashing the firmware the first time, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . Libraries Changes Formatting numbers works in more cases. The built in \"en\" culture has been removed. The dependency on GHIElectronics.TinyCLR.MsBuild has been removed. The pe and pdbx files are no longer included with the package. The package now targets the NET452 TFM. The duty cycle and polarity can now be set when the PWM pin is stopped. The frequency for the PWM controller can now be set at any time. PwmController.SetDesiredFrequency and PwmController.ActualFrequency now return the actual frequency the device was able to meet. The min and max frequency for PWM is now returned correctly. Removed analog input and output precision. Added G120, G120E, and FEZ Cobra III. CAN bus definitions now return a friendly name instead of an integer. Renamed Gpio to GpioPin, AnalogInput to AdcChannel, AnalogOutput to DacChannel, and PwmOutput to PwmPin. The pe and pdbx files are no longer included with the package. The package now targets the NET452 TFM. Known Issues Formatting numbers sometimes returns incorrect values. string.Format fails for non-trivial cases. There is only one PWM controller currently and since the Windows API has a controller-wide frequency, all PWM channels use the same frequency. Some frequencies may round up instead of down if the requested frequency cannot be met. Firmware Changes Added G120/G120E firmware. Flushing over USB is quicker. GPIO interrupts are now raised reliably. The maximum allocation is now 51,539,607,484 bytes. Known Issues PWM frequencies beyond 45MHz on G80 and 21MHz on G30 can fail. PWM may take up to a minute to start on G30 and G80. Extension Changes Breakpoints and the commands dependent on them now function properly. References no longer need a solution reload to deploy. The GHIElectronics.TinyCLR.MsBuild package has been removed. PDBX and PE files are now generated at deploy time. The deployment progress log shows more information. Incremental deployment is now better about deploying only what has changed. Debugging stops quicker after all threads in the application exit. The project templates now mirror the desktop templates much more closely. The Visual Studio projects now target .NET Framework v4.5.2. Known Issues Deploying an assembly larger than the flash sector size fails. An 0xA2000000 error will get sent over the debug transport whenever there is no app present. 0.1.0 on 2016-12-16 Known Issues After flashing the firmware the first time, Windows may still use the old NETMF USB IDs preventing the device from being seen by TinyCLR. Uninstall the device from the Device Manager and reinstall it to fix it. To update the firmware on pre-Windows 10 machines, you will need the bootloader drivers provided by our existing 2016 R1 NETMF SDK . Breakpoints and the commands dependent on them (run to cursor, others) do not work. As a work around, add a class library project called mscorlib to your solution and add a project reference to it or insert calls to System.Diagnostics.Debugger.Break. References can fail to deploy unless a solution close and open occurs after adding the reference. Re-deploying immediately after stopping debugging can fail. Try again to work around it. There is only one PWM controller currently and since the Windows API has a controller-wide frequency, all PWM channels use the same frequency. PwmController.SetDesiredFrequency must be called before any call to PwmController.OpenPin. PwmPin.SetActiveDutyCyclePercentage must be called after Start. GPIO interrupts do not always trigger. PWM may take up to a minute to start. Formatting numbers yields incorrect results in some cases. string.Format fails for non-trivial cases. Only Core, Devices, and Pins libraries are available. Only G30 and G80 are available. Packages are not uploaded to the NuGet public gallery. Additions TimeSpan.Total* {int/long/double/...}.TryParse(string source, out value) string.Format(string format, param object[] args) System.Diagnostics.WriteLine(string message)"
  },
  "tinyclr/roadmap.html": {
    "href": "tinyclr/roadmap.html",
    "title": "Roadmap",
    "keywords": "Roadmap Since TinyCLR OS is still in early alpha, we will be adding more libraries and functionality over time. Some of the things on our wish list in no particular order: USB host and client File system Graphics Secure networking Device updating Controller Area Network Runtime Loadable Procedures Generics .NET Standard The focus now is on making the core essentials available for many devices to prove the stability and portability of the core."
  },
  "tinyclr/accessories/sparkfun_ardumoto_shield_kit.html": {
    "href": "tinyclr/accessories/sparkfun_ardumoto_shield_kit.html",
    "title": "Sparkfun Ardumoto Shield Kit",
    "keywords": "Sparkfun Ardumoto Shield Kit The sparkfun Sparkfun Ardumoto Shield Kit is a low cost way of building a robot, somewhat quickly. Plug the shield on top of your FEZ , or any other Arduino-pinout compatible board. You are now ready for some serious dancing! public static void Main() { var GPIO = GpioController.GetDefault(); var DIRA = GPIO.OpenPin(FEZ.GpioPin.D2); var DIRB = GPIO.OpenPin(FEZ.GpioPin.D4); DIRA.SetDriveMode(GpioPinDriveMode.Output); DIRB.SetDriveMode(GpioPinDriveMode.Output); var PWM1 = PwmController.FromId(FEZ.PwmPin.Controller1.Id); var PWM3 = PwmController.FromId(FEZ.PwmPin.Controller3.Id); PWM1.SetDesiredFrequency(5000); PWM3.SetDesiredFrequency(5000); var PWMA = PWM1.OpenPin(FEZ.PwmPin.Controller1.D3); var PWMB = PWM3.OpenPin(FEZ.PwmPin.Controller3.D11); PWMA.Start(); PWMB.Start(); // reverse direction every one second! // Do not foget the shield needs power. Thsi can come from VIN, meaning plug a power pack into your *duino board. PWMB.SetActiveDutyCyclePercentage(0.9); while (true) { DIRA.Write(GpioPinValue.High); DIRB.Write(GpioPinValue.High); System.Threading.Thread.Sleep(1000); //change speed PWMA.SetActiveDutyCyclePercentage(0.9); DIRA.Write(GpioPinValue.Low); DIRB.Write(GpioPinValue.Low); System.Threading.Thread.Sleep(1000); //change speed PWMA.SetActiveDutyCyclePercentage(0.5); } }"
  },
  "tinyclr/porting/contributing.html": {
    "href": "tinyclr/porting/contributing.html",
    "title": "Contributing",
    "keywords": "Contributing We are taking contributions to the TinyCLR OS ports and documentation, but we don't have an established process just yet, so standard contributing practices apply. Create a fork of the repo, create a new branch from dev, work on your changes, then submit a PR. Make sure to follow the existing style for the project and keep your changes easily reviewable. Your changes will need to be licensed under Apache 2 and you need to sign a Contributor License Agreement with us before your PR can be accepted."
  },
  "tinyclr/tutorials/gpio.html": {
    "href": "tinyclr/tutorials/gpio.html",
    "title": "General Purpose Input Output (GPIO)",
    "keywords": "General Purpose Input Output (GPIO) Microcontrollers include pins that can be controlled through software. They can be inputs or outputs, hence the name general purpose input output, or GPIO for short. Tip GPIO is handled by using GHIElectronics.TinyCLR.Devices.Gpio through the Devices NuGet package. Digital Outputs A digital output pin can be set to either high or low. There are different ways of describing these two states. High can also be called \"true\" or \"one;\" low can be called \"false\" or \"zero\". If the processor is powered from 3.3V, then the state high means that there is 3.3V on the output pin. It is not going to be exactly 3.3V but very close. When the pin is set to low then it is voltage is very close to zero volts. Warning Never connect two output pins together. If they are connected and one is high and the other is low, the entire processor can be damaged. Warning Digital pins on microcontrollers are weak. They can only be used to control small LEDs or transistors. Those transistors can in turn control devices with high power needs, like a motor. This example will blink an LED on FEZ. using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; class Program { static void Main() { GpioPin led = GpioController.GetDefault().OpenPin( GHIElectronics.TinyCLR.Pins.FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); while (true) { led.Write(GpioPinValue.High); Thread.Sleep(100); led.Write(GpioPinValue.Low); Thread.Sleep(100); } } } The previous example use the FEZ pin class that includes enumerate all pins available on FEZ. To blink an LED on a different hardware that does not have pins class, you can calculate the pin number easily. This example can work on any STM32 chip. As every port has 16 pins, we can calculate the pin as shown. using System; using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; class Program { static int PinNumber(char port, byte pin) { if (port < 'A' || port > 'E') throw new ArgumentException(); return ((port - 'A')*16) + pin; } static void Main() { GpioPin led = GpioController.GetDefault().OpenPin( //PinNumber('B', 2));// Cerbuino //PinNumber('A', 10));//netduino 3 //PinNumber('D', 5));//411 red Discovery PinNumber('D', 15));//411 blue Discovery led.SetDriveMode(GpioPinDriveMode.Output); while(true) { led.Write(GpioPinValue.High); Thread.Sleep(100); led.Write(GpioPinValue.Low); Thread.Sleep(100); } } } Digital Inputs Digital inputs sense if the state of its pin is high or low based on the voltage. Every pin has a maximum & minimum supported voltage. For example, the typical minimum voltage on most pins is 0 volts; a negative voltage may damage the pin or the processor. Also, the maximum that can be supplied to most pins must be less than the processor power source voltage. Since most processors run on 3.3V, the highest voltage a pin should see is 3.3V; however, some processors that are powered by 3.3V are 5V tolerant; that is, they can accept up to 5V on their inputs. FEZ is 5V tolerant. Warning 5V-tolerant doesn't mean the processor can be powered by 5V. Only the input pins can tolerate 5V. Unconnected input pins are called \"floating\" as they are open for any surrounding noise, which can make the pin high or low. A resistor can be added to pull the pin high or low. Modern processors include internal pull-down or pull-up resistors, that are controlled by software. Note that the pull-up resistor doesn't make a pin high but it pulls it high. If nothing is connected then the pin is high by default. In this example, a button is connected between ground and the input pin. We will also enable the pull-up resistor, making that pin high when the button is not pressed, and low when the button is pressed. We will read the status of the button and pass its state to the LED. Tip Never use an infinite loop without giving the system time to think, use events or simply add a small sleep. using System; using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { GpioController GPIO = GpioController.GetDefault(); GpioPin led = GPIO.OpenPin(FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); GpioPin button = GPIO.OpenPin(FEZ.GpioPin.Btn1); button.SetDriveMode(GpioPinDriveMode.InputPullUp); while(true) { if(button.Read() == GpioPinValue.Low) { // button is pressed led.Write(GpioPinValue.High); } else { led.Write(GpioPinValue.Low); } Thread.Sleep(10);//always give the system time to think! } } } Tip if you are not using FEZ, see the Output Port example above to see how to determine the pin number. Digital Input Events In the previous example, the program just looped, and looped, and looped; each time checking the status of the pin attached to the button. The pin is checked maybe a million times before the button is pressed! Events solves this by invoking (calling) a method when an even occur. In this case the event is raised when the value on an input pin is changed. Meaning a button is pressed or released. A RisingEdge happen when the state of a pin changes from low to high, it \"rises\". This is the same button controlling LED example, but using events. using System; using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static GpioPin led; static void Main() { GpioController GPIO = GpioController.GetDefault(); led = GPIO.OpenPin(FEZ.GpioPin.Led1); led.SetDriveMode(GpioPinDriveMode.Output); GpioPin button = GPIO.OpenPin(FEZ.GpioPin.Btn1); button.SetDriveMode(GpioPinDriveMode.InputPullUp); button.ValueChanged += Button_ValueChanged; Thread.Sleep(-1);// sleep for low power, or do other tasks here! } private static void Button_ValueChanged(GpioPin sender, GpioPinValueChangedEventArgs e) { if (e.Edge == GpioPinEdge.FallingEdge) led.Write(GpioPinValue.Low); else led.Write(GpioPinValue.High); } } Warning Once you type += after the event, hit the tab key twice. Visual Studio will automatically create the event for you."
  },
  "brainpad/courses/programming/csharp/intro.html": {
    "href": "brainpad/courses/programming/csharp/intro.html",
    "title": "C Sharp (C#)",
    "keywords": "C Sharp (C#) It is not a secret that C and C++ are the most popular programing languages among professionals. This is more partically true for professionals that work with small digital systems. C# is the modern cousin of the C and C++ family. It syntax is very close to JAVA, another very popular programming language. The courses are in the process of being created. Please bear with us. Introduction to the BrainPad Overview Students will learn how to create projects in Visual Studio along with programming basics. Applications in this lesson will be limited to the BrainPad object, If statements, a While loop and the template functions. Guidelines Prerequisites: None Ages 12 and up PC setup with Visual Studio 2017, TinyCLR OS and Nuget packages installed. Supplies: BrainPad and microUSB cable. Install Visual Studio and Download .vsix file Install Visual Studio Community 2017. Select the Community download. Skip this step if you have Visual Studio 2017 installed. Visual Studio 2017 Download Starting a New Project Connect your BrainPad to your computer using a microUSB cable. Next Open Visual Studio select File > New > Project and under Other Languages select Visual C# > TinyCLR and choose the BrainPad Application . Change the Location to C:\\Users\\<YourUsername>\\Desktop\\ then name the project BrainPad_Project . From Visual Studio, select File > New > Project: Once created, you'll be presented with a Program.cs tab. This file contains the default code when you first create a project. The lines in green that begin with ' are called comments, and they generally describe what the code does. Take a moment to review them. Let's run the code to see these comments' descriptions come to life. Connect the BrainPad and press the F5 function key or the Start button. Visual Studio will now run the code, a few things will happen and the display will now have the text \"Hello, world!\" . This file contains the default code when you first create a project. The lines in green that begin with // are called comments, they generally describe what the code does. Take a moment to review them. You can create your own comments in the code by typing // before any notes you like to add. Comments don't affect how your program runs. Comments are a great place to keep notes about how a piece of code might work. They are helpful if another programmer looks at your code, or you return to look at your own code at a later date, to help you understand what the code is doing behind the scenes. The BrainPad Object The world around us is full of objects. Every person, table or circuit board is an object. If we were to ask a person to say \"hello,\" we'd be asking an object to perform a task. The same concept can be applied to code. Like in the previous application we ran, the BrainPad was asked to control the display through the BrainPad object. The BrainPad object itself, is a piece of code that is contained in one file. This was developed by GHI Electronics to cover the internals of the BrainPad. This enables students like you, with an easy way to control the BrainPad circuit board. After typing BrainPad, press the period key to get a list of all available options (Figure 3) for this object, like LightBulb. Now we can use the arrow keys to go up and down in the list to find the LightBulb, and then press the period key again to see what options (Figure 4) are the available for the LightBulb. Visual Studio does a great deal of simplifying the programming process by automatically listing available options for an object. They call this neat option built into Visual Studio, IntelliSense Now that we know how to use the BrainPad object, lets learn about controlling the LightBulb. The BrainPad LightBulb LED lights are used in many different electronic devices. Here we will test the LightBulb by turning it green, then on, then off. Copy and paste the code from Example 1 into your projects BrainPadSetup() , between its two curly braces { }. Tip Parentheses ( ) and curly braces { } are used differently, do not confuse them? BrainPad.LightBulb.TurnOff(); BrainPad.LightBulb.TurnGreen(); BrainPad.LightBulb.TurnOff(); BrainPad.LightBulb.TurnGreen(); Now, press F5 to run the code and youll see the LightBulb turn green come on and stay on. This happens because our code is executed faster than we can see. So we never see the LightBulb actually blink. Problem Solving Since applications execute extremely fast, we need to slow them down to figure out the problem. This way we can see what is happening or if the results are as expected. We will start by running the code one line at a time, this is called stepping in code to see what the application does at a slow speed. Stepping in Code Add a breakpoint (stop point) at the first line of code inside of BrainPadSetup() by moving the cursor to that line and pressing the F9 key as shown below. You can also click in the grey area where the breakpoints appear to either remove or create new breakpoints. Press F5 to run the application. The project will be built and deployed but then the execution will stop at the breakpoint as shown below. Adding Delays to Code In order to see what's going on we need to add some delays in the program code. This is done by telling the BrainPad to wait between tasks. Copy and paste the code from below into your project's BrainPadSetup() , between the two curly braces { } . BrainPad.LightBulb.TurnOff(); BrainPad.Wait.Seconds(1); BrainPad.LightBulb.TurnGreen(); BrainPad.Wait.Seconds(1); BrainPad.LightBulb.TurnOff(); BrainPad.Wait.Seconds(1); BrainPad.LightBulb.TurnGreen(); Run the code by pressing START and observe the LightBulb again. You should now see it turn green, then on and off twice. Change the LightBulb Color This works great if you only want the LightBulb green. But what if you want a different color? The LED inside the LightBulb is capable of showing more colors than just green. LED TV's use many tiny LEDS lined up in rows and columns to make up the picture you see. Like the LED lights in a TV they are capable of showing many different colors inside just one LED. First let's use code similar to the last example, only this time will change the LightBulb from green to red to blue, using built-in functions already created. Copy and paste the code from below into your project's BrainPadSetup() , between the two curly braces { } . BrainPad.LightBulb.TurnOff(); BrainPad.LightBulb.TurnGreen(); BrainPad.Wait.Seconds(1); BrainPad.LightBulb.TurnOff(); BrainPad.LightBulb.TurnRed(); BrainPad.Wait.Seconds(1); BrainPad.LightBulb.TurnOff(); BrainPad.LightBulb.TurnBlue(); BrainPad.Wait.Seconds(1); Even more LightBulb Colors. Under the BrainPad.LightBulb object you'll find the method BrainPad.LightBulb.SetRgbColor() . The SetRgbColor() method requires 3 values be passed into it. Each value represents the intensity of each of the RGB colors (Red, Green and Blue). From 0 (fully off) to 100 (fully on). In the example code below the LightBulb RGB values are all set to 100, resulting in a White colored LightBulb. You'll also notice these values go inside the parentheses and not inside the curly braces. BrainPad.LightBulb.SetRgbColor(100,100,100); We'll now redo the code above that turns the light from Green to Red to Blue. But this time we'll use the SetRgbColor() method to achieve the exact same results. Copy and paste the code from below into your project's BrainPadSetup() , between the two curly braces { } . You may have noticed that methods contain parentheses like the SetRgbColor() method. Sometimes we put values inside these parentheses. The first value represents Red, the second Green, and the third Blue. These values are called arguments. The arguments are passed in the method between its parentheses like this: BrainPad.LightBulb.SetRgbColor(0,100,0); Resulting in the Light Bulb turning Green."
  },
  "hardware/legacy_products/netmf/embedded_master.html": {
    "href": "hardware/legacy_products/netmf/embedded_master.html",
    "title": "Embedded Master",
    "keywords": "Embedded Master Embedded Master is a NETMF System on Module. To use with NETMF, follow these setup instructions . Needs the NETMF 4.1 SDK. Resources User Manual"
  },
  "hardware/loaders/mikro_bootloader.html": {
    "href": "hardware/loaders/mikro_bootloader.html",
    "title": "Mikro Bootloader",
    "keywords": "Mikro Bootloader Mikro Elektronika's bootloader is found on several products offered by them. Some of the TinyCLR OS supported boards are made by Mikro Electronica and include this loader by default. This page covers it in full details https://learn.mikroe.com/bootloaders/"
  },
  "tinyclr/intro.html": {
    "href": "tinyclr/intro.html",
    "title": "TinyCLR OS Introduction",
    "keywords": "TinyCLR OS Introduction TinyCLR OS is our path forward that started with the .NET Micro Framework to enable managed .NET development using Microsoft's Visual Studio on embedded devices -- including debugging features! All you need to get started is Visual Studio, a TinyCLR device, and a USB cable. Tip TinyCLR OS is still an alpha so there is still a lot more to come! TinyCLR OS is made for .NET developers. Threading, memory management, timers, event handlers, and many more exist in TinyCLR OS just like they do on full .NET. For interacting with hardware, TinyCLR OS has an API similar to the Windows 10 IoT Core Extensions API that you may already be familiar with. GPIO, UART, SPI, I2C, ADC, DAC, PWM, and more are all available for you to interact with the embedded world. Better yet, all libraries are available through NuGet. Because of this, there will be no SDK to install or machines to lock to specific versions. Simply use NuGet to download any needed version of any needed library on a per-project basis. To set a system to use TinyCLR OS: If you don't already have Visual Studio 2017, download and install the freely available Visual Studio Community 2017 . Make sure to select the .NET desktop development workload when installing Visual Studio. Download and install the newest TinyCLR OS Visual Studio extension . Connect your device to your PC using a USB cable. Don't have a TinyCLR OS device yet? There are many supported boards . Start Visual Studio and create a new TinyCLR Application under C# > TinyCLR . New to Visual Studio or C#? Take a look at the getting started guide from Microsoft . Add some code and press F5 to deploy and begin debugging your application! Since TinyCLR OS is still so new, we haven't yet uploaded any packages to NuGet, so make sure to download the newest libraries , extract the archive, and place them in a local NuGet feed . Do not forget to update the firmware on your board . You are now ready to get started with TinyCLR! Take a look at the tutorials to get going. Tip If you're an existing user of NETMF and still want to use it in addition to TinyCLR OS, don't worry. TinyCLR OS is completely independent of NETMF and works side-by-side with no issues. Take a look at the release notes to see what's new and the roadmap to see what we have planned. Interested in running TinyCLR OS on your own device? Take a look at the porting guide for information on how to get started."
  },
  "tinyclr/tinyclr_config.html": {
    "href": "tinyclr/tinyclr_config.html",
    "title": "TinyCLR Config",
    "keywords": "TinyCLR Config TinyCLR Config is a stand-alone tool to help managing TinyCLR OS devices. The tool is cloud-connected. It automatically finds and shows a list of available firmware versions. If desired, the tool can also use a locally hosted firmware, in case there is no internet connection. The TinyCLR Config tool is stil in development. Please stay tuned ."
  },
  "tinyclr/boards/stm32_boards.html": {
    "href": "tinyclr/boards/stm32_boards.html",
    "title": "STM32 Boards",
    "keywords": "STM32 Boards The market is full of STM32 boards, especially the ones from ST Microelectronics, who offers several evaluation boards for their STM32 product families. The STM32F4 is the most popular family and it is what the FEZCLR reference firmware use. STM32F4 Discovery The ST Microelectronics STM32F411 Discovery board board works with the FEZCLR firmware. Simply, follow the FEZ board instructions. STM32F4 Nucleo The ST Microelectronics Nucleo-F401RE board works with the FEZCLR firmware. Simply, follow the FEZ board instructions. Tip The Nucleo board doesn't include a USB connector by default but has the needed connections needed to add a USB connector. See this TinyCLR Fork started with the FEZCLR port to create a port for Nucleo-F411RE port. The docs include instructions on how to wire USB to the discovery board. Other STM32F4 boards All STM32F4 microcontrollers are very similar. Any board (Discovery, Nucleo and others) with an 8Mhz crystal should simply run the FEZCLR firmware. However, you can simply change the crystal clock in the port and recompile the firmware. Start porting TinyCLR OS now."
  },
  "tinyclr/tutorials/adc.html": {
    "href": "tinyclr/tutorials/adc.html",
    "title": "ADC",
    "keywords": "ADC Unlike digital input pins, which can only read high or low; analog pins can read a range of voltage levels. Microcontrollers based on 3.3V can typically read voltages anywhere between zero and 3.3V. Analog inputs connect internally to a Analog to Digital Converter (ADC) that converts the analog voltage level on the pin to a digital value. The resolution of the ADC determines its accuracy. An 8bit ADC has 256 steps to work with, 3.3V/256=0.013V. This means an increase of 0.013V will increase the value by one. In other words, a voltage change of less than 0.013V has no effect. The ADC on FEZ is 12bit and should fit most needs. Tip Note that the analog channel number is not the pin number. We have these easily enumerated for FEZ but you need to determine the channel number on a specific pin using your system's documentation. This example will read the ratio, that is 0 to 1, of an analog input. After running the program, connect a wire from the analog pin to ground and you should see a zero or something really close to zero. Connect to 3.3V and you will see 1 or something close, like 0.99. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { AdcController ADC = AdcController.GetDefault(); AdcChannel analog = ADC.OpenChannel(FEZ.AdcChannel.A0); while(true) { double d = analog.ReadRatio(); Debug.WriteLine(\"An-> \" + d.ToString(\"N2\")); Thread.Sleep(100); } } }"
  },
  "tinyclr/tutorials/dac.html": {
    "href": "tinyclr/tutorials/dac.html",
    "title": "DAC",
    "keywords": "DAC An analog output sets the voltage onitspin anywhere between 0 and the supplied voltage (maximum voltage)which istypically 3.3 volts. The output voltage is only a signal, not meant to drive any loads. An op-amp or similar circuits can be added to drive loads, such as a speaker. The analog out on a micro has \"precision:\" the precision of a particular processor is in its manual ordatasheet; consequentially,actual output values on the pinare an approximation. For example, a micro with an 8-bit (256 steps) analog outhas a step precision of 3.3V/256. This example will generate a triangular waveform. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Dac; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { DacController DAC = DacController.GetDefault(); DacChannel analog = DAC.OpenChannel(G120.DacChannel.P0_26); double d = 0.5; double dd = 0.01; while (true) { analog.WriteValue(d); d += dd; if (d <= 0 || d >= 1) dd *= -1;// inverse Thread.Sleep(10); } } } Tip Do not use analog outputs to control the power of an LED or a motor. Use PWM for that."
  },
  "hardware/legacy_products/intro.html": {
    "href": "hardware/legacy_products/intro.html",
    "title": "Legacy Products Introduction",
    "keywords": "Legacy Products Introduction This section covers some details on legacy products. These products are not recommended for new designs and are no longer covered by our free support. Please contact us directly for details on our paid support services. Tip Our community forums is a great place to get help from our engineers and from the thousands of community members. Producing Legacy Products GHI Electronics is the engineering and the manufacturing behind all its products. While some products have been made legacy and not recommended for new designs, they can still be produced. There may be a required minimum order quantity. We understand the seriousness of the need for a decent product longevity and availability. Please contact us directly to discuss ways to fulfill your immediate needs and also to discuss the upgrade options."
  },
  "hardware/legacy_products/gadgeteer/intro.html": {
    "href": "hardware/legacy_products/gadgeteer/intro.html",
    "title": ".NET Gadgeteer Intro",
    "keywords": ".NET Gadgeteer Intro .NET Gadgeteer that was initiated by Microsoft Research and taken to production by GHI Electronics in the year 2011. .NET Gadgeteer had a great few year run, where it was loved for its plug-and-play mainboard and modules. Tip We will refer to .NET Gadgeteer as Gadgeteer throughout the rest of the documentation. The core of .NET Gadgeteer is .NET Micro Framework (NETMF). Like Gadgeteer, NETMF is no longer evolved by Microsoft and left for the community. Learn more about NETMF Sadly, and after 5 years of building modules and mainboards, GHI Electronics had to announce the EOL for Gadgeteer; however, the Gadgeteer hardware can still be used with TinyCLR OS . External resources: Microsoft's .NET Gadgeteer website (down) http://www.gadgeteer.com/ Microsoft's NETMF website (outdated) http://www.netmf.com/ Most of the Gadgeteer ecosystem is open source: Microsoft's .NET Gadgeteer Core GHI Electronics' Software sources and Hardware design files The Gadgeteer graphical designer was never made available by Microsoft. Socket Map The magic of Gadgeteer is in its socket map (copy the map from here https://www.ghielectronics.com/docs/305/gadgeteer-sockets-quick-reference ) Using .NET Gadgeteer To use the .NET Gadgeteer legacy software, install: Visual Studio 20013 (community edition is also supported) Unzip and install netmfvs2013.vsix and MicroFramewrokSDK.msi from here Microsoft's Gadgeteer Core GHI Electronics' NETMF SDK . The latest is recommended. The Gadgeteer for Beginners guide is a good starting point. Tip You can only use Visual Studio 2013, not a newer edition, unless you are using your Gadgeteer hardware with TinyCLR OS . With TinyCLR OS All .NET Gadgeteer devices are still useable today, and with the latest technologies, thanks to efforts by GHI Electronics and the community. It all started in this video! This means you can still use all your beloved .NET Gadgeteer gear with TinyCLR OS . The first step needed to use TinyCLR OS is to load the GHI Bootloader v2 onto your mainboard, then use that to load the TinyCLR OS firmware. Each mainboard product page includes the needed instructions. Once those are loaded, you can start blinking the debug LED, detailed in the next section. Blinking the LED Tip If you have never used TinyCLR OS before, start here This example will blink the debug LED. You only need to add a power module to your mainboard. using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var led = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.DebugLed); led.SetDriveMode(GpioPinDriveMode.Output); while(true) { led.Write(GpioPinValue.High); Thread.Sleep(200); led.Write(GpioPinValue.Low); Thread.Sleep(200); } } } Tip The complete pin mapping is made available through GHIElectronics.TinyCLR.Pins . You should not need to use any schematics. Replace FEZSpider with your mainboard's name. Adding Gadgeteer Modules You are now ready to start adding modules ."
  },
  "hardware/legacy_products/netmf/canxtra.html": {
    "href": "hardware/legacy_products/netmf/canxtra.html",
    "title": "CANxtra",
    "keywords": "CANxtra CANxtra is a hand-held programmable OBD-II tool, that includes CAN, LIN and other vehicle busses. Resources below are provided for reference only. Please contact us for all of custom automotive needs. Resources Brochure Schematic"
  },
  "tinyclr/tutorials/pwm.html": {
    "href": "tinyclr/tutorials/pwm.html",
    "title": "PWM",
    "keywords": "PWM Pulse Width Modulation (PWM) is a very import feature found in most microcontrollers. PWM is a pulse that is repeated and generated by the internal hardware. The ratio of the pulse width and its frequency is called duty cycle. Through software, you can control the pulse's frequency and duty cycle. Tip we use usually use GetDefault() for most peripherals. For example, there is only one GPIO controller on most systems. This is not the case with PWM. Never use the Default controller and always> select the proper channel on the correspondent controller. Tip PWM2.3 is channel 3 on controller 2 Energy Level PWM is perfect for dimming an LED or slowing down a motor. This is done by turning power on and off, at a high speed. When power is on half the time and off half the time, only half the energy is transferred, to the LED or a motor. This demo will fade the LED in and out using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { PwmController Controller4 = PwmController.FromId(FEZ.PwmPin.Controller4.Id); PwmPin led = Controller4.OpenPin(FEZ.PwmPin.Controller4.Led1); Controller4.SetDesiredFrequency(10000); double duty = 0.5, speed = 0.01; led.Start(); while (true) { led.SetActiveDutyCyclePercentage(duty); duty += speed; if (duty <= 0 || duty >= 1) duty *= -1;//invert dirrection Thread.Sleep(10);// always give the system time to think! } } } Musical Tones Music notes have specific frequencies; C for example is about 261Hz. Plugging these numbers into an array and knowing the length of each tone is all that is needed to play some simple music. When playing notes by changing the frequency, keep thee duty cycle set to 0.5. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Pins; class Program { const int NOTE_C = 261; const int NOTE_D = 294; const int NOTE_E = 330; const int NOTE_F = 349; const int NOTE_G = 392; const int WHOLE_DURATION = 1000; const int EIGHTH = WHOLE_DURATION / 8; const int QUARTER = WHOLE_DURATION / 4; const int QUARTERDOT = WHOLE_DURATION / 3; const int HALF = WHOLE_DURATION / 2; const int WHOLE = WHOLE_DURATION; //make sure the two below arrays match in length. each duration element corresponds to //one note element. static int[] note = { NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_E, NOTE_D, NOTE_D, NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_D, NOTE_C, NOTE_C}; static int[] duration = { QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, HALF, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, WHOLE}; static void Main() { PwmController Controller1 = PwmController.FromId(FEZ.PwmPin.Controller1.Id); PwmPin tones = Controller1.OpenPin(FEZ.PwmPin.Controller1.D0); tones.SetActiveDutyCyclePercentage(0.5); tones.Start(); while (true) { for (int i = 0; i < note.Length; i++) { Controller1.SetDesiredFrequency( note[i]); Thread.Sleep(duration[i]); } Thread.Sleep(100); } } } Servo Motors Servo motors are controlled by a repeated pulse. The pulse is generated every 20ms. This pulse will have a width between 1ms and 2ms, for min and max. Positional servos will go to a psecific derction based on the pulse width. Full rotational servos can be controlled, speed and direction, through this pulse, where 1.5ms pulse will stop, 1ms is full speed and 1ms is reverse full speed. Tip most servos will have a 1.25ms min and 1.75max. using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { PwmController Controller1 = PwmController.FromId(FEZ.PwmPin.Controller1.Id); PwmPin servo = Controller1.OpenPin(FEZ.PwmPin.Controller1.D0); Controller1.SetDesiredFrequency(1 / 0.020);//a pulse every 20ms double maxPulseLength = 1.75; double minPulseLength = 1.25; double position = 90; double speed = 0.5; servo.Start(); while (true) { double duty = ((position / 180.0) * (maxPulseLength / 20 - minPulseLength / 20)) + minPulseLength / 20; servo.SetActiveDutyCyclePercentage(duty); position += speed; if (position <= 0 || position >= 180) duty *= -1;//reverse dirrection Thread.Sleep(10);// always give the system time to think! } } }"
  },
  "brainpad/courses/electronics/intro.html": {
    "href": "brainpad/courses/electronics/intro.html",
    "title": "Intro",
    "keywords": "Intro Electronics is in everything around us. What is surprising is that, in this modern age, we have more electronic devices but there is a lot less fixing of these electronic devices, when compared to the previous generations. Can we educate the next generation to understand electronics better? The BrainPad, without any additions, is enough to explain all the basics. Then it can also be used to explain digital electronics and processing. Further going into explain data transfers in digital system. This is all before even adding a single wire, but then the possibilities are endless with what sensors and circuits can be wired to the BrainPad. These are the outdated courses that are getting updated soon. Please bear with us. https://www.ghielectronics.com/downloads/BrainPad/BrainPad_EL_Introduction.pdf https://www.ghielectronics.com/downloads/BrainPad/BrainPad_EL_AnalogInputs.pdf https://www.ghielectronics.com/downloads/BrainPad/BrainPad_EL_PulseWidthModulation.pdf"
  },
  "hardware/legacy_products/imaging.html": {
    "href": "hardware/legacy_products/imaging.html",
    "title": "Imaging",
    "keywords": "Imaging ALCAM-OEM is a small yet powerful imaging hardware. It could capture stills and videos to SD card and able to fetch images using serial commands. It started in a successful Kickstarter campaign Resources: get them here We have worked on similar custom commercial designs with imaging needs but decided to proceed with a one-size-fits-all. Please contact us to discuss your imaging needs."
  },
  "hardware/legacy_products/raspberrypi_hats.html": {
    "href": "hardware/legacy_products/raspberrypi_hats.html",
    "title": "Raspberry Pi Hats",
    "keywords": "Raspberry Pi Hats Several HATs were made for the RPI. The software was focused on the use of Win10. This GitHub repo includes the software for all HATs. FEZ HAT Schematic FEZ ProtoPi Schematic FEZ Utility Schematic FEZ Cream This HAT was part of the Gadgeteering efforts. Schematic"
  },
  "hardware/legacy_products/gadgeteer/modules.html": {
    "href": "hardware/legacy_products/gadgeteer/modules.html",
    "title": ".NET Gadgeteer Modules",
    "keywords": ".NET Gadgeteer Modules This page lists all .NET Gadgeteer modules and how can they be used with TinyCLR OS . If you are planning on using the old NETMF/Gadgeteer software then read the .NET Gadgeteer Intro page. Tip We discourage writing specific drivers that can't be used outside gadgeteer. It should be easy to transition from a gadgeteer to a non-gadgeteer design. If a module is simple, then no driver at all is provided! Tip You can use Intellisense with the pin definition class to quickly determine where things go. For example: Typing FEZSpider.GpioPin.Socket3. lists the available GPIO pins on socket3 Another example: Typing FEZSpider.UartPort. lists all available UART sockets (that is U in the old Gadgeteer standard) Tip We will be using the original, and most popular, FEZ Spider as a base for this page but any other mainboard will work very similarly. Accel G248 The Accel G248 measures acceleration though I2C bus. Coming Soon! https://github.com/ghi-electronics/NETMF-Gadgeteer/blob/master/Modules/GHIElectronics/AccelG248/AccelG248_43/AccelG248_43.cs Barometer https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/Barometer Bluetooth https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/Bluetooth Breadboard X1 An easy breadboard option. Simply access the socket directly to wire whatever your heart desires! Breakout Simply a breakout of all signals. Breakout TB10 Simply a breakout of all signals, on a terminal block. Button The Button module is very simple, with a button connected to pin 3 and an LED connected to pin4. This example will blink the LED a different rate, depending on the button press. using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var LED = GpioController.GetDefault().OpenPin(FEZSpiderII.GpioPin.Socket1.Pin3); LED.SetDriveMode(GpioPinDriveMode.Output); var Button = GpioController.GetDefault().OpenPin(FEZSpiderII.GpioPin.Socket4.Pin4); Button.SetDriveMode(GpioPinDriveMode.InputPullUp); var speed = 200; while (true) { if (Button.Read() == GpioPinValue.High) speed = 200;// high = button is not pressed else speed = 500;// low = button is pressed // blink the LED LED.Write(GpioPinValue.High); Thread.Sleep(speed); LED.Write(GpioPinValue.Low); Thread.Sleep(speed); } } } Button S7 7 buttons on a single module, with LEDs that light up with button presses! Use the same code example provided for the Button Module. Buttons map: Left: Pin Right: Pin 8 Up: Pin 6 Down: Pin 7 Enter: Pin 3 Back: Pin 4 Forward: Pin 9 CAN DW CAN is not yet supported in TinyCLR OS, you can add it if you are up for a challenge! Camera USB Host is not supported in TinyCLR OS Cellular Radio Coming soon! https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/CellularRadio Character Display This is a standard and very common HD44780 display. Coming soon! https://github.com/ghi-electronics/NETMF-Gadgeteer/blob/master/Modules/GHIElectronics/CharacterDisplay/CharacterDisplay_43/CharacterDisplay_43.cs ColorSense A color sensor that uses software I2C, not yet supported in TinyCLR OS. Coming soon! https://github.com/ghi-electronics/NETMF-Gadgeteer/blob/master/Modules/GHIElectronics/ColorSense/ColorSense_43/ColorSense_43.cs Compass Coming soon! https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/Compass Current ACS712 This is a current sensor that uses ACS712, which simply outputs an analog voltage. add example that shows the conversion math https://github.com/ghi-electronics/NETMF-Gadgeteer/blob/master/Modules/GHIElectronics/CurrentACS712/CurrentACS712_43/CurrentACS712_43.cs Display CP7 Read more about the display support on TinyCLR OS. The configurations for the display: // these are the wrong values! Width = 480, Height = 272, PixelClockRate = 20000000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Display N18 This is an SPI display that can work on any system, even small ones without TFT display support. Coming soon! Use the old BrainPad driver. Display N7 Read more about the display support on TinyCLR OS. The configurations for the display: // these are the wrong values! Width = 480, Height = 272, PixelClockRate = 20000000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Display NHVN This allows the use of several displays offered by http://newhavendisplay.com/ Supported displays: 1 2 3 Display T35 Read more about the display support on TinyCLR OS. The configurations for the display: // these are the wrong values! Width = 480, Height = 272, PixelClockRate = 20000000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Display T43 Read more about the display support on TinyCLR OS. The configurations for the display: // these are the wrong values! Width = 480, Height = 272, PixelClockRate = 20000000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Display TE35 Read more about the display support on TinyCLR OS. The configurations for the display: // these are the wrong values! Width = 480, Height = 272, PixelClockRate = 20000000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Distance US3 A very common ultrasonic sensor that works by sending a pulse on the trig and measuring the response time on echo pin. I have the code in the robot example Ethernet ENC28 Requires an internal support in the TinyCLR OS port. Ethernet J11D Requires an internal support in the TinyCLR OS port. Extender No drivers are needed. FEZtive https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/FEZtive Flash Coming soon! https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/FLASH GPS Coming soon! https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/GPS GasSense This module can host several different air sensors, like Alcohol and CO2. The sensor has an internal heater that needs to be enabled and then it is a simple analog read. using System.Threading; using System.Diagnostics; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var Enable = GpioController.GetDefault().OpenPin(FEZSpiderII.GpioPin.Socket10.Pin4); Enable.SetDriveMode(GpioPinDriveMode.Output); Enable.Write(GpioPinValue.High);// Enable the internal heater var Ain = AdcController.GetDefault().OpenChannel(FEZSpiderII.AdcChannel.Socket10.Pin3); while (true) { Debug.WriteLine(\"Ain: \" + Ain.ReadRatio()); Thread.Sleep(500); } } } Gyro Coming soon! https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/Gyro HD44780 See the Character Display Module HubAP5 No hub support is currently planned. IO60P16 This module provide 60 IOs and 16 PWM pins. Will not be ported but you can port the original driver . IR Receiver Coming soon! https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/IRReceiver Joystick The Joystick module has two analog inputs for X and Y position. Pressing the knob also works like a button. using System.Threading; using System.Diagnostics; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var AinX = AdcController.GetDefault().OpenChannel(FEZSpiderII.AdcChannel.Socket10.Pin4); var AinY = AdcController.GetDefault().OpenChannel(FEZSpiderII.AdcChannel.Socket10.Pin5); var Button = GpioController.GetDefault().OpenPin(FEZSpiderII.GpioPin.Socket10.Pin3); Button.SetDriveMode(GpioPinDriveMode.InputPullUp); while (true) { Debug.WriteLine(\"PosX: \" + AinX.ReadRatio() + \"%\"+ \"PosY: \" + AinY.ReadRatio() + \"%\"); if (Button.Read() == GpioPinValue.Low) Debug.WriteLine(\"Pressed!\"); Thread.Sleep(500); } } } Keypad KP16 A numerical Keypad https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/KeypadKP16 LED 7C An LED that can be set to one of 7 colors, 8 if you count off! using System.Threading; using System.Diagnostics; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var GPIO = GpioController.GetDefault(); var Red = GPIO.OpenPin(FEZSpiderII.GpioPin.Socket8.Pin4); Red.SetDriveMode(GpioPinDriveMode.Output); var Green = GPIO.OpenPin(FEZSpiderII.GpioPin.Socket8.Pin4); Green.SetDriveMode(GpioPinDriveMode.Output); var Blue = GPIO.OpenPin(FEZSpiderII.GpioPin.Socket8.Pin4); Blue.SetDriveMode(GpioPinDriveMode.Output); while (true) { // Off Red.Write(GpioPinValue.Low); Green.Write(GpioPinValue.Low); Blue.Write(GpioPinValue.Low); Thread.Sleep(500); // Red Red.Write(GpioPinValue.High); Green.Write(GpioPinValue.Low); Blue.Write(GpioPinValue.Low); Thread.Sleep(500); // Green Red.Write(GpioPinValue.Low); Green.Write(GpioPinValue.High); Blue.Write(GpioPinValue.Low); Thread.Sleep(500); // Blue Red.Write(GpioPinValue.Low); Green.Write(GpioPinValue.Low); Blue.Write(GpioPinValue.High); Thread.Sleep(500); // White Red.Write(GpioPinValue.High); Green.Write(GpioPinValue.High); Blue.Write(GpioPinValue.High); Thread.Sleep(500); // Yellow Red.Write(GpioPinValue.High); Green.Write(GpioPinValue.High); Blue.Write(GpioPinValue.Low); Thread.Sleep(500); // Magenta Red.Write(GpioPinValue.High); Green.Write(GpioPinValue.Low); Blue.Write(GpioPinValue.High); Thread.Sleep(500); // Cyan Red.Write(GpioPinValue.Low); Green.Write(GpioPinValue.High); Blue.Write(GpioPinValue.High); Thread.Sleep(500); } } } LED 7R This is a ring of 6 LEDs and a 7th center LED. Reference the LED 7C module for using pins. Center LED: pin ?? LEDs in CW starting from the top: 1,2,3,4??? LED Strip A strip of 7 LEDs, connected to pins 3 through 9. Light Sense Simply using analog on pin 3. Use the same code as the potentiometer. Load Each one of the 7 GPIO pins are connected to a transistor to handle a load, like a motor. MaxO Shift registers used to take serial SPI data and put on parallel pins, perfect for driving tons of LEDs. Coming soon! https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/MaxO MicroSD Card No file system support yet. Moisture This is a simple analog input measuring the direct resistance (moisture). An enable pin needs to be activated. using System.Threading; using System.Diagnostics; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var Enable = GpioController.GetDefault().OpenPin(FEZSpiderII.GpioPin.Socket10.Pin6); Enable.SetDriveMode(GpioPinDriveMode.Output); Enable.Write(GpioPinValue.High);// Enable var Ain = AdcController.GetDefault().OpenChannel(FEZSpiderII.AdcChannel.Socket10.Pin3); while (true) { Debug.WriteLine(\"Ain: \" + Ain.ReadRatio()); Thread.Sleep(500); } } } Motor Driver The Motor Driver Module uses L298 H-bridge that can drive two motors up to 4A. Pin 6: Motor A Direction (GPIO) Pin 7: Motor A Speed (PWM) Pin 8: Motor B Direction (GPIO) Pin 9: Motor B Speed (PWM) Tip NETMF didn't handle PWM correctly. TinyCLR OS breaks PWM pins to individual channels. Read more about PWM . This example will setup both motors and then will make motor A go very slow forward then very fast backward, in a loop. using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { // Determine what PWM controller is used for specific pins, use the power of intellisense! // start typing FEZSpider.PwmPin. to navigate the options // >>>>>>>>>>>> Will this work if we have different controller? // Motor A var MotorDirA = GpioController.GetDefault().OpenPin(FEZSpiderII.GpioPin.Socket8.Pin6); MotorDirA.SetDriveMode(GpioPinDriveMode.Output); var ControllerA = PwmController.FromId(FEZSpiderII.PwmPin.Controller1.Id); ControllerA.SetDesiredFrequency(5000); var MotorSpeedA = ControllerA.OpenPin(FEZSpiderII.PwmPin.Controller1.Socket8.Pin7); // Motor B var MotorDirB = GpioController.GetDefault().OpenPin(FEZSpiderII.GpioPin.Socket8.Pin8); MotorDirB.SetDriveMode(GpioPinDriveMode.Output); var ControllerB = PwmController.FromId(FEZSpiderII.PwmPin.Controller1.Id); ControllerB.SetDesiredFrequency(5000); var MotorSpeedB = ControllerB.OpenPin(FEZSpiderII.PwmPin.Controller1.Socket8.Pin9); while (true) { MotorDirA.Write(GpioPinValue.High);// Forward MotorSpeedA.SetActiveDutyCyclePercentage(0.1);// slow 10% Thread.Sleep(500); MotorDirA.Write(GpioPinValue.Low);// Backwards MotorSpeedA.SetActiveDutyCyclePercentage(0.9);// fast 90% Thread.Sleep(500); } } } Multicolor LED This module used DaisyLink bus to chain some expensive LED! We will not support the DaisyLink bus. Music The Music Module uses the popular VS1053 decoder chip that decodes MP3, WMA, OGG, MIDI and WAV files. Original code is found at here and needs a volunteer to update. Null Modem No driver is needed. OBD II https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/OBDII OneWire X1 A breakout with a terminal block for easily connecting one wire devices, specifically the common temperature probes. one wire is not supported yet. https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/OneWireX1 PIR Motion detection. Simply pin 3 changes irs state when it detects motion. Parallel CNC Will not be supported. Potentiometer The Potentiometer module is simply a variable resistor connected to pin3. Rotating its knob will result in an analog value changing from min to max. using System.Threading; using System.Diagnostics; using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var Ain = AdcController.GetDefault().OpenChannel(FEZSpiderII.AdcChannel.Socket10.Pin3); while (true) { Debug.WriteLine(\"Pos: \" + Ain.ReadRatio() + \"%\"); Thread.Sleep(500); } } } Pulse Count https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/PulseCount Pulse InOut https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/PulseInOut Pulse Oximeter https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/PulseOximeter RFID Reader https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/RFIDReader RS232 Simply a serial port. RS485 Simply a serial port. Radio FM1 I have the code on click Reflector R3 https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/ReflectorR3 Relay ISOx16 An array of 16 relays. https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/RelayISOx16 Relay X1 Simply use set pin 3 high to activate the relay. Rotary H1 https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/RotaryH1 SD Card File system is not supported yet. S-Plus We will not support hubs and socket indirection. Serial Camera Aren't they both the same? https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/SerialCameraL1 https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/SerialCameraL2 Stepper L6470 https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/StepperL6470 TempHumidity https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/TempHumidity Thermocouple https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/Thermocouple Touch C8 https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/TouchC8 Touch L12 https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/TouchL12 Tunes The Tunes Module is a tiny speaker that is connected to pin 9. Use PWM to generate sounds This example will keep changing the frequency. using System.Threading; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var controller = PwmController.FromId(FEZSpiderII.PwmPin.Controller0.Id); var buzz = controller.OpenPin(FEZSpiderII.PwmPin.Controller0.Socket11.Pin9); controller.SetDesiredFrequency(500);// change the frequency for sounds buzz.SetActiveDutyCyclePercentage(0.5);// always use this for sounds buzz.Start(); while (true) { controller.SetDesiredFrequency(500); Thread.Sleep(500); controller.SetDesiredFrequency(200); Thread.Sleep(500); } } } UC Battery 4xAA No driver is needed. USB Client DP No driver is needed. USB Client SP No driver is needed. USB Host USB Host is not currently supported. USB Serial Simply, a serial port. USB Serial SP Simply, a serial port. VideoOut https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/VideoOut WiFi RN171 https://github.com/ghi-electronics/NETMF-Gadgeteer/tree/master/Modules/GHIElectronics/WiFiRN171 WiFi RS21 Will not be supported, NDA issues. XBee Adapter Simply, a serial port. From there a driver like https://xbee.codeplex.com/"
  },
  "hardware/loaders/stm32_bootloader.html": {
    "href": "hardware/loaders/stm32_bootloader.html",
    "title": "STM32 Bootloader",
    "keywords": "STM32 Bootloader The STM32 Bootloader lives on all STM32 chips. It is necessary to load files (loaders and/or firmware) onto the chip. Several TinyCLR OS supported boards will use this loader to load the software. These instructions apply to all STM32 chips with built in USB and DFU features. Creating DFU file TinyCLR OS build system will generate a bin file firmware that can be loaded using ST-Link for example. STM32 chips also include a USB bootloader that takes DFU files. To generate a DFU file, download the \"DfuSe USB device firmware upgrade STMicroelectronics extension\" software package Find and open \"Dfu file manager\" and select \"I want to generate a DFU file\". Click on \"S19 or Hex...\" button to select the hex file generated by the TinyCLR OS build system. Click \"Generate...\" You now have the DFU file! Uploading DFU Files To set the STM32 chip in DFU mode, BOOT1 pin (if available) needs to be low and and BOOT0 needs to be high when the system powers up. If your system has a BOOT1 button, just hold the button down while powering the system up. The device manager will see the device \"STM Device in DFU Mode\". Find and open \"Open DfuSe Demo\" (from the ST download higher in this page) Under \"Upgrade and Verify Action\", click the \"Chose...\" button and select the firmware DFU file you want to load. Click the \"Upgrade\" button. Click the \"Leave DFU mode\" button. Congratulations, your board is now running your firmware!"
  },
  "hardware/products/intro.html": {
    "href": "hardware/products/intro.html",
    "title": "Products Introduction",
    "keywords": "Products Introduction This section covers technical details on our products. You may contact us directly for further assistance or visit our community forums ."
  },
  "tinyclr/boards/netduino.html": {
    "href": "tinyclr/boards/netduino.html",
    "title": "netduino",
    "keywords": "netduino netduino 3 Originally a .NET Micro Framework product, netdunio 3 is available in three flavors: netduino 3 netduino 3 Ethernet netduino 3 WiFi The netduino3 firmware is located here . Use ST-Link to load or follow the instructions at the STM32 bootloader page to generate and load a DFU file. When done, your PC should detect a TinyCLR device. You are now ready to start coding Tip Currently the firmware is the same for all three devices and doesn't include any networking support. Tip The region set aside for RLI is 0x2002F000 - 0x2002FFF8. Pin Definitions This should help in getting to pins available on the netduino3 namespace GHIElectronics.TinyCLR.Pins { /// <summary>Board definition for the FEZCerbuinoNet.</summary> public static class Netduino3 { /// <summary>GPIO pin definitions.</summary> public static class GpioPin { /// <summary>Debug LED definition</summary> public const int Led = STM32F4.GpioPin.PA10; public const int PowerLed = STM32F4.GpioPin.PC13; /// <summary>SD Card Dectect definition</summary> public const int SdCardDetect = STM32F4.GpioPin.PB2; public const int SdCardPwrCtrl = STM32F4.GpioPin.PB1; /// <summary>GPIO pin.</summary> public const int D0 = STM32F4.GpioPin.PC7; /// <summary>GPIO pin.</summary> public const int D1 = STM32F4.GpioPin.PC6; /// <summary>GPIO pin.</summary> public const int D2 = STM32F4.GpioPin.PA3; /// <summary>GPIO pin.</summary> public const int D3 = STM32F4.GpioPin.PA2; /// <summary>GPIO pin.</summary> public const int D4 = STM32F4.GpioPin.PB12; /// <summary>GPIO pin.</summary> public const int D5 = STM32F4.GpioPin.PB8; /// <summary>GPIO pin.</summary> public const int D6 = STM32F4.GpioPin.PB9; /// <summary>GPIO pin.</summary> public const int D7 = STM32F4.GpioPin.PA1; /// <summary>GPIO pin.</summary> public const int D8 = STM32F4.GpioPin.PA0; /// <summary>GPIO pin.</summary> public const int D9 = STM32F4.GpioPin.PE5; /// <summary>GPIO pin.</summary> public const int D10 = STM32F4.GpioPin.PB10; /// <summary>GPIO pin.</summary> public const int D11 = STM32F4.GpioPin.PB15; /// <summary>GPIO pin.</summary> public const int D12 = STM32F4.GpioPin.PB14; /// <summary>GPIO pin.</summary> public const int D13 = STM32F4.GpioPin.PB13; /// <summary>GPIO pin.</summary> public const int A0 = STM32F4.GpioPin.PC0; /// <summary>GPIO pin.</summary> public const int A1 = STM32F4.GpioPin.PC1; /// <summary>GPIO pin.</summary> public const int A2 = STM32F4.GpioPin.PC2; /// <summary>GPIO pin.</summary> public const int A3 = STM32F4.GpioPin.PC3; /// <summary>GPIO pin.</summary> public const int A4 = STM32F4.GpioPin.PC4; /// <summary>GPIO pin.</summary> public const int A5 = STM32F4.GpioPin.PC5; /// <summary>Socket definition.</summary> public static class GoPort1 { /// <summary>Pin definition.</summary> public const int Pin3 = STM32F4.GpioPin.PD13; /// <summary>Pin definition.</summary> public const int Pin4 = STM32F4.GpioPin.PD8; /// <summary>Pin definition.</summary> public const int Pin5 = STM32F4.GpioPin.PD9; /// <summary>Pin definition.</summary> public const int Pin6 = STM32F4.GpioPin.PD0; /// <summary>LED definition.</summary> public const int Led = STM32F4.GpioPin.PE9; /// <summary>Power On definition.</summary> public const int PwrOn = STM32F4.GpioPin.PD7; } /// <summary>Socket definition.</summary> public static class GoPort2 { /// <summary>Pin definition.</summary> public const int Pin3 = STM32F4.GpioPin.PD14; /// <summary>Pin definition.</summary> public const int Pin4 = STM32F4.GpioPin.PE8; /// <summary>Pin definition.</summary> public const int Pin5 = STM32F4.GpioPin.PE7; /// <summary>Pin definition.</summary> public const int Pin6 = STM32F4.GpioPin.PD1; /// <summary>LED definition.</summary> public const int Led = STM32F4.GpioPin.PE11; /// <summary>Power On definition.</summary> public const int PwrOn = STM32F4.GpioPin.PD10; } /// <summary>Socket definition.</summary> public static class GoPort3 { /// <summary>Pin definition.</summary> public const int Pin3 = STM32F4.GpioPin.PD15; /// <summary>Pin definition.</summary> public const int Pin4 = STM32F4.GpioPin.PE1; /// <summary>Pin definition.</summary> public const int Pin5 = STM32F4.GpioPin.PE0; /// <summary>Pin definition.</summary> public const int Pin6 = STM32F4.GpioPin.PD2; /// <summary>LED definition.</summary> public const int Led = STM32F4.GpioPin.PB0; /// <summary>Power On definition.</summary> public const int PwrOn = STM32F4.GpioPin.PE14; } } /// <summary>Analog channel definition.</summary> public static class AdcChannel { /// <summary>Pin definition.</summary> public const int A0 = STM32F4.AdcChannel.Channel10; /// <summary>Pin definition.</summary> public const int A1 = STM32F4.AdcChannel.Channel11; /// <summary>Pin definition.</summary> public const int A2 = STM32F4.AdcChannel.Channel12; /// <summary>Pin definition.</summary> public const int A3 = STM32F4.AdcChannel.Channel13; /// <summary>Pin definition.</summary> public const int A4 = STM32F4.AdcChannel.Channel14; /// <summary>Pin definition.</summary> public const int A5 = STM32F4.AdcChannel.Channel15; } /// <summary>Uart port definition.</summary> public static class UartPort { /// <summary>Socket definition.</summary> public const string GoPort1 = STM32F4.UartPort.Usart3; /// <summary>Socket definition.</summary> public const string GoPort2 = STM32F4.UartPort.Uart7; /// <summary>Socket definition.</summary> public const string GoPort3 = STM32F4.UartPort.Uart8; /// <summary>UART D0 (RX) and D1 (TX).</summary> public const string Uart6 = STM32F4.UartPort.Uart6; } /// <summary>SPI Bus definition.</summary> public static class SpiBus { /// <summary>Socket definition.</summary> public const string GoPort1 = STM32F4.SpiBus.Spi4; public const string GoPort2 = STM32F4.SpiBus.Spi4; public const string GoPort3 = STM32F4.SpiBus.Spi4; public const string Spi2 = STM32F4.SpiBus.Spi2; } } } netduino 2 This board uses STM32F2, which is very similar to the STM32 F4 used on the netduino 3. Porting TinyCLR OS ro netduino 2 should not be very difficult. netduino 1 This board uses an Atmel micocontroller. The G400 uses an Atmel processor and can be a good starting point for posting TinyCLR OS."
  },
  "tinyclr/tutorials/gpiochangewriter.html": {
    "href": "tinyclr/tutorials/gpiochangewriter.html",
    "title": "Gpio Change Writer",
    "keywords": "Gpio Change Writer Gpio Change Writer works in the current release. Documentation is coming soon. GpioChangeWriter writer = new GpioChangeWriter(FEZ.GpioPin.A1, false); See this for now https://www.ghielectronics.com/docs/24/signal-generator"
  },
  "tinyclr/tutorials/gpiopulsereaderwriter.html": {
    "href": "tinyclr/tutorials/gpiopulsereaderwriter.html",
    "title": "Gpio Pulse Reader Writer",
    "keywords": "Gpio Pulse Reader Writer Gpio Pulse Reader Writer works in the current release. Documentation is coming soon. GpioPulseReaderWriter pulse = new GpioPulseReaderWriter(GpioPulseReaderWriter.Mode.DrainDuration, true, 100, FEZ.GpioPin.A1); See this for now https://www.ghielectronics.com/docs/326/pulse-feedback"
  },
  "README.html": {
    "href": "README.html",
    "title": "Docs",
    "keywords": "Docs This is the repository for all of our docs. To generate the docs locally: Clone/Fork the repo Open the command prompt in the documents' root folder (\"Run as Administrator\" may be necessary) Execute docfx --serve"
  },
  "hardware/loaders/ghi_bootloader.html": {
    "href": "hardware/loaders/ghi_bootloader.html",
    "title": "GHI Bootloader",
    "keywords": "GHI Bootloader The GHI Bootloader is used to update the firmware on our devices. It is the first program to run and unless the device specific LDR pins are set (see device documentation for details), it will execute the firmware on the device if present. The bootloader communicates over a USB virtual serial port or a regular serial port. The interface used is usually controlled by a MODE pin. See your device specifications for details on interface configuration and selection and for which version of the bootloader it runs. Tip If you are running Windows 7 or Windows 8, you must install drivers for the bootloader to appear in Windows. See the downloads section . Bootloader v2 All commands and results are terminated with CR and LF (\\r\\n). \"OK.\" will be sent after each successful command. On startup, a banner is sent that is terminated by \"OK.\". Once the banner is received, you are free to enter any of the case-insensitive single-character commands described below. Most commands require confirmation. Send Y or y followed by a new-line to proceed or anything else to cancel. V: returns the current version. N: returns the current device type. E: erases all user sectors of the device. R: runs the firmware if present. B: increases the baud rate in serial mode to 921,600. X: upload a ghi file to the device using 1K XMODEM. Only send *.ghi files meant for your device. U: upload a glb file to the device using 1K XMODEM. Only send *.glb files meant for your device. Loading the Firmware Using TinyCLR Config Coming soon. Use the manual steps instead. Manual Loading the Firmware TinyCLR Config tool should be used to update the firmware. As a backup, use these instructions: Set your board in the bootloader mode. Each product has a specific way to enter the boot loader. Open any terminal software, for example Tera Term . Select serial and pick the COM port associated with your board. (If unsure, check Device Manager) Press V and then enter. You will see back the boot loader version number (v2.x.x) Press U or X and then enter. Use X for firmware file type GHI and U for firmware file type GLB. Press Y to confirm then enter. You will now see CCCC ... Go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the firmware file. When the transfer is complete, reset your board. GLB File Format The glb files that are loaded onto devices have some additional metadata that help the bootloader function in addition to the raw data itself. The first 1,024 bytes of a glb file is the upload header. Starting from offset 0 are the below fields. The rest of the header is currently reserved. 32 bit signature number that is unique for each device. 32 bit unsigned address in flash that this image should be copied to. 32 bit unsigned length of the image to flash rounded to the nearest 1,024 bytes. 16 bit CRC-CCITT of the image. After the upload header is the actual image to flash. If its length is not divisible by 1,024 bytes, it is padded until it is. For images that are meant to be bootable, the address in the upload header should be set to the entry point defined for the specific device. Bootable images have an additional 1,024 byte header at the beginning of the image that is used to verify the image before booting it. The boot image is also padded to the nearest 1,024 bytes. Starting from offset 0 are the below fields. The rest of the header is currently reserved. 32 bit signature number that is unique for each device. 32 bit unsigned address in flash that is the entry point the bootloader will invoke. 32 bit unsigned length of the boot image rounded to the nearest 1,024 bytes. 16 bit CRC-CCITT of the boot image bounded by the specified address and length. Bootloader v1 Currently the USBizi, EMX, G120, and G120E ship with this version of the bootloader. All results are terminated with LF (\\n). Commands are executed as soon as they entered without waiting for a new-line. \"BL\" or \"Done.\" will be sent after each command. On startup, a banner is sent that is terminated by \"BL\". Once the banner is received, you are free to enter any of the case-sensitive single-character commands described below. V: returns the current version. E: erases all user sectors of the device (* is sent while erasing). R: runs the firmware if present. B: increases the baud rate in serial mode to 921,600. X: upload a file to the device using 1K XMODEM. Only send *.ghi files meant for your device. The firmware is automatically run after a successful upload. Tip The USB interface on Version 1.0 doesn't always work on Windows 7 and newer operating systems. Use the serial interface instead. Downloads Here you can find the various bootloaders available for the various products. FEZCLR Bootloader Date Status MD5 FEZCLR 2.0.4 2017-xx-xx Alpha x FEZCLR 2.0.3 2017-07-07 Alpha 056919694D6A5F06546F9B721AE141CE Cerb Bootloader Date Status MD5 Cerb 2.0.4 2017-xx-xx Alpha x Cerb 2.0.3 2017-07-07 Alpha 6505870259AC8E748FD09EBD00796E2E G120 Bootloader Date Status MD5 G120 2.0.3 2017-xx-xx Alpha x G120 2.0.2 2017-03-07 Alpha 00ECD55A24607336863B1D61B91C3D86 G400 Bootloader Date Status MD5 G400 2.0.3 2017-xx-xx Alpha x G400 2.0.2 2017-04-06 Alpha 81D45A8F078AA8E633C824C7BB3279DC EMX Bootloader Date Status MD5 EMX 2.0.3 2017-xx-xx Alpha x USBizi Bootloader Date Status MD5 USBizi 2.0.3 2017-xx-xx Alpha x USBizi 144 1.0.7 2015-05-05 Production 853557479D8797EAB650B98E3D333DCF USBizi 100 1.0.7 2015-05-05 Production 34D17AA5CA4E13D5447C80AB8094D064 USB Drivers Driver Date Status MD5 x64 0.6.0 2017-xx-xx Alpha x x86 0.6.0 2017-xx-xx Alpha x"
  },
  "hardware/legacy_products/gadgeteer/fez_spider_ii.html": {
    "href": "hardware/legacy_products/gadgeteer/fez_spider_ii.html",
    "title": "FEZ Spider II",
    "keywords": "FEZ Spider II FEZ Spider II is a .NET Gadgeteer product, that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Spider II is the G120E System on Module (SoM). Resources Schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading Bootloader v2 Download the bootloader file Set the board's configuration switches in boot mode. That is by setting switches #1 and #2 to the on position. Connect the FEZ Spider to a power module (red module) and then to a PC. The PC will now detect a virtual serial (COM) device. If you need drivers, they are in the NETMF SDK. Open any terminal software, we recommend Tera Term . Select serial and pick the COM port associated with your board. Enter E and you will see back \"Erase all memory! Are you sure?\" now enter Y . (The bootloader is case sensitive) Enter X and you will see CCCC ... showing on the terminal. Now go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the bootloader file you have downloaded above. You will see File Transfer Finished Successfully . Change the configuration switches back to the off position and reset the board. You are now running GHI Electronics bootloader v2! Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, set the configuration switch #1 to the on position and then reset your board. Make sure to set back ot off after loading the firmware. Download the G120 firmware and follow Loading the Firmware steps."
  },
  "hardware/products/g30.html": {
    "href": "hardware/products/g30.html",
    "title": "G30",
    "keywords": "G30 The G30 System on Chip (SoC) is a low-cost chipsets running the .NET Micro Framework. It is programmed using Microsoft's Visual Studio using C# or Visual Basic which allows developers to take advantage of the extensive built-in NETMF libraries and GHI Electronics added extensions. To use G30 SoC, follow the setup instructions on the NETMF intro page Datasheet Using the NETMF software We discourage the use of NETMF software on our products in favor for TinyCLR OS. Read more about the use of NETMF and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using NETMF devices with TinyCLR OS Loading Bootloader v2 The G30 SoC ships with the Bootloader loaded and locked. No further steps are necessary. Loading the Firmware To activate bootloader v2, LDR0 signal needs to be low while resetting the board. Download the G30 firmware and follow Loading the Firmware steps. G30 Based products G30 Development Board The development system used for evaluating the EMX SoM. Schematic G30 TH Module A though-hole version of G30. Schematic FEZ Lemur A Arduino-pinout compatible single board computer. Schematic"
  },
  "hardware/products/g400.html": {
    "href": "hardware/products/g400.html",
    "title": "G400",
    "keywords": "G400 G400S and G400D are .NET Micro Framework (NETMF) System on Modules. Datasheet Using the NETMF software We discourage the use of NETMF software on our products in favor for TinyCLR OS. Read more about the use of NETMF and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using NETMF devices with TinyCLR OS Loading Bootloader Version 2 Download the bootloader file . Download and install SAM-BA. We tested SAM-BA.2.12.exe but we should move to SAM-BA.2.16 for Windows Download and unzip the update scripts . You will have a folder called G400 Bootloader Installer . Rename the bootloader file, downloaded earlier, to bootloader.bin and move it to the G400 Bootloader Installer folder. Connect SPI1_MISO pin to ground and reset the board. Wait three seconds and remove the connection between SPI1_MISO and ground. on FEZ Raptor, SPI1_MISO is pin 8 on socket 3. Open up the Device Manager, look under Ports, and find a COM port similar to \"Bossa Program Port\" or \"GPS Detect\". In the G400 Bootloader Installer folder, run Flash Bootloader.bat . When prompted, enter the number of the COM port found under Device Manager. For example: for COM10, enter just 10. You will see \"Bootloader Update Complete\" when the update is finished. The update will take several minutes. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, hold the LDR0 signal low while resetting the board. Download the G400 firmware and follow Loading the Firmware steps. Tip The upload takes several seconds to start. Wait about a minute to start seeing the upload progress. G400 Based products G400 Development Board The development system used for evaluating the G400 SoM. Schematic G400 TH Module A though-hole version of G400. Schematic"
  },
  "tinyclr/porting/intro.html": {
    "href": "tinyclr/porting/intro.html",
    "title": "Porting TinyCLR",
    "keywords": "Porting TinyCLR TinyCLR OS can be ported to new devices. We provide the precompiled .NET interpreter and runtime for several architectures. Currently only Cortex M4 is supported, but more will be supported in the future. To get started we'll build the FEZ firmware. Clone the ports repo to your computer. Download and install GCC . The latest version we have tested is 6-2017-q2-update . Download and extract the contents of CMSIS into the CMSIS folder of the cloned repo. While the file extension is *.pack , it's actually a zip that you can extract once you rename it to *.zip . Download and extract the latest TinyCLR OS Core Library into the Core folder of the cloned repo. Open a command prompt, change the directory to the cloned repo, and then execute build.bat FEZ . The compiled firmware can then be found in the repo directory under build\\release\\FEZ . The build system automatically produces firmware images in hex format (.hex), a raw binary (.bin), a binary meant to be loaded by our GHI Bootloader with its U command (.glb), and, for some devices, a binary meant to be loaded by the same bootloader with the X command (.ghi). For the FEZ firmware we built, flash the FEZ Firmware.glb to your board following the instructions on the bootloader page. When you restart it, it should be running TinyCLR OS and you can deploy to it from Visual Studio. Creating your own Devices To create a new firmware for a board that a Target already exists for, you just need to create a new folder under Devices to define your board. You can do this easily by copying an existing board, like the FEZ, and making the changes you need for your board. Make sure you update the scatterfile to place the final firmware image in memory where it needs to be. For example, the FEZ scatterfile expects the GHI Bootloader to be present but you need to place your firmware's image at the start of flash. Creating a new Target To port to a new board with a new Target , make sure it is one of the architectures that we have made a core library available for. Then, like above, you'll need to make a new folder for your device under the Devices folder. You'll also need to create a new folder under Targets that implements the needed APIs. The TinyCLR runtime requires you to provide a few APIs for it to function correctly: deployment, interrupt, power, and time. The runtime also makes a few APIs available to you automatically: the API provider itself; a memory allocator; a recurring task creator; and a way to interact with managed objects, arguments, and events. Beyond that, you can provide whatever APIs you need like GPIO and SPI. See the native API document for details on APIs. On top of providing several APIs, you must call all the functions under TinyCLR_Startup_* to properly initialize the system. The main.cpp provided in the repo that our existing ports use and the build system includes is a good starting point."
  },
  "hardware/legacy_products/gadgeteer/fez_reaper.html": {
    "href": "hardware/legacy_products/gadgeteer/fez_reaper.html",
    "title": "FEZ Raptor",
    "keywords": "FEZ Raptor FEZ Reaper is a .NET Gadgeteer product, that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Reaper is the G80 System on Chip (SoC). Resources Schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading Bootloader v2 The G80 SoC ships with the Bootloader loaded and locked. No further steps are necessary. Loading the Firmware To activate bootloader v2, press and hold both LDR0 and LDR1 buttons down while resetting the board. Download the G80 firmware and follow Loading the Firmware steps."
  },
  "hardware/legacy_products/netmf/intro.html": {
    "href": "hardware/legacy_products/netmf/intro.html",
    "title": "NETMF Intro",
    "keywords": "NETMF Intro .NET Micro Framework (NETMF) is a subset of the full .NET. Initiated by Microsoft for SPOT watches and then later open sourced. The latest working version Visual Studio working with our NETMF products is VS2013. Tip We discourage the use of NETMF on our products in favor of TinyCLR OS . Learn more about using NETMF devices with TinyCLR OS . To use NETMF, install: Visual Studio 20013 (community edition is also supported) Unzip and install netmfvs2013.vsix and MicroFramewrokSDK.msi from here One of the available NETMF SDKs . The latest is recommended. The NETMF for Beginners guide is a good starting point. Available NETMF SDKs Release notes are found within the SDKs. Date NETMF Core Rev SDK Jun 27, 2016 4.3 QFE2 GHI Electronics NETMF SDK 2016 R1 Aug 31, 2015 4.3 QFE2 GHI Electronics NETMF SDK 2015 R1 Oct 29, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R5 Oct 8, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R4 Sep 15, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R3 Jul 31, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R2 Jan 29, 2014 4.3 RTM NETMF and Gadgeteer Package 2014 R1 Oct 23, 2013 4.3 RTM NETMF and Gadgeteer Package 2013 R3 Aug 27, 2013 4.3 RTM NETMF and Gadgeteer Package 2013 R2 Apr 30, 2013 4.3 RTM NETMF and Gadgeteer Package 2013 R1 Update 1 Feb 14, 2013 4.2 QFE2 NETMF and Gadgeteer Package 2013 R1 Feb 17, 2012 4.1 RTM NETMF 4.1 SDK, for Embedded Master, USBizi and ChipworkX (Includes IoT book for FEZ Panda) With TinyCLR OS Most NETMF devices are still useable today, and with the latest technologies. To use TinyCLR OS, you need to load a new bootloader and the TinyCLR OS firmware. Loading the Bootloader Before loading the TinyCLR OS firmware, we need load the GHI Electronics' Bootloader Version 2 onto the mainboard. Each mainboard has specific instructions on loading the bootloader. Those instructions, and the firmware file, are found on the individual mainboard's pages. Tip If you have never used TinyCLR OS before, start here"
  },
  "hardware/products/g80.html": {
    "href": "hardware/products/g80.html",
    "title": "G80",
    "keywords": "G80 The G80 System on Chip (SoC) is a low-cost chipsets running the .NET Micro Framework. It is programmed using Microsoft's Visual Studio using C# or Visual Basic which allows developers to take advantage of the extensive built-in NETMF libraries and GHI Electronics added extensions. To use G80 SoC, follow the setup instructions on the NETMF intro page Datasheet Using the NETMF software We discourage the use of NETMF software on our products in favor for TinyCLR OS. Read more about the use of NETMF and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using NETMF devices with TinyCLR OS Loading Bootloader v2 The G80 SoC ships with the Bootloader loaded and locked. No further steps are necessary. Loading the Firmware To activate bootloader v2, LDR0 signals needs to be low while resetting the board. Download the G80 firmware and follow Loading the Firmware steps. G80 Based products G80 Development Board The development system used for evaluating the EMX SoM. Schematics G80 TH Module A though-hole version of G80. Schematics FEZ Panda II A Arduino-pinout compatible single board computer. Schematics"
  },
  "tinyclr/accessories/adafruit_display_shield.html": {
    "href": "tinyclr/accessories/adafruit_display_shield.html",
    "title": "Adafruit Display Shield",
    "keywords": "Adafruit Display Shield The Adafruit 1.8\" Color TFT Shield w/microSD and Joystick plugs right on top of FEZ, or any other Arduino-pinout compatible board. To use this shield, just plug it on top of your Arduno-pinout compatible board, like the FEZ . The driver is found here . You are now ready to use the shield Display18.Display n18 = new Display18.Display(FEZ.GpioPin.A0, FEZ.GpioPin.A1, FEZ.SpiBus.Spi1); int count = 0; while (true) { count++; n18.DrawLargeText(10, 10, \"Count \" + count, Display18.Color.Green); Thread.Sleep(30); }"
  },
  "tinyclr/accessories/pololu_zumo_robot.html": {
    "href": "tinyclr/accessories/pololu_zumo_robot.html",
    "title": "Pololu Zumo Robot",
    "keywords": "Pololu Zumo Robot The Pololu Zumo Robot from Pololu is one of our favorites, especially the pre-assembled version. Drop your FEZ on top of the Zumo Robot, or any other Arduino-compatible board, and you are ready to make the robot follow lines and dance around. The driver is found here . You are now ready for some serious dancing! public static void Main() { bool state = false; while (!ZumoBot.ButtonIsPressed()) { state = !state; ZumoBot.SetLed(state); ZumoBot.Beep(); Thread.Sleep(500); } Thread.Sleep(300); ZumoBot.SetLed(false); Thread.Sleep(300); ZumoBot.SetLed(true); Thread.Sleep(300); ZumoBot.SetLed(false); Thread.Sleep(300); ZumoBot.SetLed(true); while (true) { long left = ZumoBot.Reflectors.GetLevel(0); long right = ZumoBot.Reflectors.GetLevel(5); //Debug.WriteLine(\">\" + ZumoBot.Reflectors.GetLevel(0)); //System.Diagnostics.Debug.WriteLine(\"l: \" + left + \" r: \" + right); if (left < 8000 && right < 8000) { ZumoBot.Motors.Move(40, 40); } else { // backup and turn ZumoBot.Motors.MoveBackward(); Thread.Sleep(500); ZumoBot.Motors.Stop(); Thread.Sleep(1000); ZumoBot.Motors.TurnLeft(); Thread.Sleep(500); ZumoBot.Motors.Stop(); Thread.Sleep(1000); } Thread.Sleep(30); } }"
  },
  "index.html": {
    "href": "index.html",
    "title": "",
    "keywords": "Welcome to http://docs.ghielectronics.com where you can find tutorials, samples, documentation, and API references for all GHI Electronics products. This documentation covers three main categories: Hardware: This includes every hardware GHI Electronics makes. It includes al needed resources and instructions of the use of these products. It also covers bootloaders. TinyCLR: Everything you need to use and/or port TinyCLR OS. BrainPad: Courses and learning material for the STEM/STEAM focused BrainPad. The GHI Electronics websites: The main website: https://www.ghielectronics.com/ TinyCLR OS: http://www.tinyclr.com BrainPad: http://www.brainpad.com The comunity forum: https://forums.ghielectronics.com/ You may obtain further assistance by contacting us directly or through our community forums . Note This is a new docuemntaion system and some of the available docs are still in progress. Please check back frequently."
  },
  "hardware/legacy_products/gadgeteer/fez_cerberus.html": {
    "href": "hardware/legacy_products/gadgeteer/fez_cerberus.html",
    "title": "FEZ Cerberus",
    "keywords": "FEZ Cerberus FEZ Cerberus is a .NET Gadgeteer product, that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Cerberus is the G30 System on Chip (SoC). FEZ Cerberus is the mother of the Cerb Family . Resources Schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading Bootloader v2 Download the bootloader file Press and hold BOOT button down while resetting the board. If there is no BOOT button, there will be shunt-footprint labeled BOOT or LDR. Short the 2 pads with a wire while resetting the board. The system will now detect an ST DFU device. Read more on uploading DFU files on STM32 microcontrollers. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, set PA15 pin low. Download the Cerb firmware and follow Loading the Firmware steps. The Cerb Family The FEZ Cerberus come in different form factor, together called the Cerb family. The entire family run the same software. FEZ Cerberus The mother of the family! FEZ Cerbuino Bee An arduino-pinout compatible for accepting shields and also has some Gadgeteer socket option. FEZ Cerbuino Net An arduino-pinout compatible for accepting shields and also has some Gadgeteer socket option. FEZ Cerb40 DIP40 formfactor board. Not really a Gadgeteer board but it is very small! FEZ Cerbot A robot with reflective sensors and tons of LEDs. Gadgeteer sockets are used as an easy way to add features."
  },
  "tinyclr/boards/fez.html": {
    "href": "tinyclr/boards/fez.html",
    "title": "FEZ",
    "keywords": "FEZ  FEZ is the official TinyCLR OS board and reference design. Its port, called FEZCLR , has the latest and greatest software, and should be used as a reference for starting new ports.  Find Hardware resources and other 3rd party software on the FEZ hardware page  FEZ includes the GHI Electronics bootloader for making software update easier. The board comes pre-loaded with the loader. In case you erased the board and want to reload the bootloader, you can download it here . To load the bootloader file onto FEZ, use the DFU tools as explained here  Using TinyCLR OS This requires loading the GHI Bootloader v2 and the FEZCLR firmware.  Loading Bootloader v2 The loader comes loaded by default and does not need to be updated. However, if the loader was erased and needs to be loaded: Download and save the bootloader file . Press and hold BOOT0 button while resetting the FEZ. Follow the instructions for Uploading DFU Files .  ## Loading the Firmware Press and hold the BTN1 button down while resetting the board. Download the FEZCLR firmware and follow Loading the Firmware steps."
  },
  "hardware/legacy_products/gadgeteer/fez_cobra_ii.html": {
    "href": "hardware/legacy_products/gadgeteer/fez_cobra_ii.html",
    "title": "FEZ Cobra II",
    "keywords": "FEZ Cobra II FEZ Cobra II is a .NET Gadgeteer product, that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Cobra II is the G120 System on Module (SoM). Resources Schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading Bootloader v2 Download the bootloader file Press and keep holding the LDR0 and LDR1 buttons while reseting the board. Then release the buttons. The PC will now detect a virtual serial (COM) device. If you need drivers, they are in the NETMF SDK. Open any terminal software, we recommend Tera Term . Select serial and pick the COM port associated with your board. Enter E and you will see back \"Erase all memory! Are you sure?\" now enter Y . (The bootloader is case sensitive) Enter X and you will see CCCC ... showing on the terminal. Now go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the bootloader file you have downloaded above. You will see File Transfer Finished Successfully . Reset your board, you are now running GHI Electronics bootloader v2! Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, press and hold the LDR0 button while resetting the board. Download the G120 firmware and follow Loading the Firmware steps."
  },
  "hardware/legacy_products/netmf/usbizi.html": {
    "href": "hardware/legacy_products/netmf/usbizi.html",
    "title": "USBizi",
    "keywords": "USBizi USBizi was the first single chip .NET Micro Framework (NETMF) on the market. It was available in 100pin and 144pin LQFP packages. We are no longer making the chip available but we are making all bootloader binaries (move to new server) available for free, including for commercial use. Resources User Manual Using the NETMF software We discourage the use of NETMF software on our products in favor for TinyCLR OS, Read more . Using TinyCLR OS If haven't yet, read about using .NET NETMF devices with TinyCLR OS Loading Bootloader v2 (coming soon) Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, set .... to be completed! Download the USBizi firmware and follow Loading the Firmware steps. USBizi Based products USBizi DevSys The original development board for USBizi. FEZ Panda An Arduino-poinout compatible board. Schematic FEZ Panda II An Arduino-poinout compatible board. Schematic FEZ Rhino Schematic FEZ Mini Schematic USBizi was the core of many of GHI Electronics' products, FEZ Panda, FEZ Panda II, FEZ Domino, FEZ Rhino and FEZ Mini. Move resources from old server here"
  },
  "hardware/products/g120.html": {
    "href": "hardware/products/g120.html",
    "title": "G120",
    "keywords": "G120 G120 and G120E are .NET Micro Framework (NETMF) System on Modules. Datasheet Using the NETMF software We discourage the use of NETMF software on our products in favor for TinyCLR OS. Read more about the use of NETMF and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using NETMF devices with TinyCLR OS Loading Bootloader v2 Download the bootloader file Set theLDR0 and LDR1 signals low while reseting the board. The PC will now detect a virtual serial (COM) device. If you need drivers, they are in the NETMF SDK. Open any terminal software, we recommend Tera Term . Select serial and pick the COM port associated with your board. Enter E and you will see back \"Erase all memory! Are you sure?\" now enter Y . (The bootloader is case sensitive) Enter X and you will see CCCC ... showing on the terminal. Now go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the bootloader file you have downloaded above. You will see File Transfer Finished Successfully . Reset your board, you are now running GHI Electronics bootloader version 2! Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, hold the LDR0 signal low while resetting the board. Download the G120 firmware and follow Loading the Firmware steps. G120 Based products G120 Development Board The development system used for evaluating the EMX SoM. Schematic G120 TH Module A though-hole version of G120. Schematic G120 Cobra III An Arduino-pinout compatible single board computer. Schematic G120 Cobra II A single board computer. Schematic"
  },
  "brainpad/intro.html": {
    "href": "brainpad/intro.html",
    "title": "BrainPad Intro",
    "keywords": "BrainPad Intro The BrainPad is a revolutionized board for STEM and STEAM programs. It is very simple with much to offer out of the box, yet it is expandable. It is simple enough that a beginner can start with, but powerful that an advanced user can use it to expand their knowledge. It works with higher elementary kids to a retired person. Visit the official BrainPad website at www.brainpad.com This video shows a 6-year-old using a PC for the first time! And her first PC experience was in programming the BrainPad. The BrainPad design is based on the TinYCLR OS's official FEZ hardware. This means that the BrainPad will always receive the latest TinyCLR OS updates. The Future Plan We want your feedback. After years of work with hundreds of students, the BrainPad setup is simple and works through the TinyCLR OS ecosystem of boards. However, we are constantly working on making the use of the BrainPad yet simpler. This video shows one of the schools we worked with: The Community We have been working with local and online communities for years. Hop on our forum and share the discussion now. Or talk to us directly about our next local community gathering. Teachers and students like you are also interested in STEM & STEAM. Firmware Update Using TinyCLR Config (coming soon) Manual Loading the Firmware TinyCLR Config tool should be used to update the firmware. As a backup, use the instructions on the bootloader page for manual update. Here is a video that shows the manual firmware update. It also includes the steps needed for the old BrainPad and steps for updating the bootloader. The BrainPad uses the FEZCLR firmware Advance Hardware Info Advance hardware info are found on the hardware page. Also, learn about the magic TinyCLR OS . The Original BrainPad The Original (old) BrainPad (the large one) has been decommissioned. It has served well in working with schools to help us make a lot of decisions. Tip You can determine if you have the old BrainPad by looking for the traffic light in the top right corner. Only the old BrainPad has the traffic light. As a bonus, we will continue to support the original BrainPad with the new software. However, emulating the old display with the new software is severely effecting the system's performance. The display will not be enabled by default. We do not recommend the use of display on the old BrainPad. Using the Traffic Light The new software does not include the traffic light as the new BrainPad doesn't have a traffic light. However, this can be added as shown in this video."
  },
  "hardware/legacy_products/gadgeteer/fez_spider.html": {
    "href": "hardware/legacy_products/gadgeteer/fez_spider.html",
    "title": "FEZ Spider",
    "keywords": "FEZ Spider FEZ Spider is a .NET Gadgeteer product, that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Spider is the EMX System on Module (SoM). Resources Schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading Bootloader v2 Tip The EMX bootloader version 1 doesn't always work with Windows 7 and newer (Error code 10). You can use the serial option to update the loader. This is a one-time procedure. You should have no issues after the bootloader V2 is loaded. To update using USB Download the bootloader file Set the board's configuration switches in boot mode. That is by setting switches #1, #2 and #3 to the on position. Connect the FEZ Spider to a power module (red module) and then to a PC. The PC will now detect a virtual serial (COM) device. If you need drivers, they are in the NETMF SDK. Open any terminal software, we recommend Tera Term . Select serial and pick the COM port associated with your board. Enter E and you will see back \"Erase all memory! Are you sure?\" now enter Y . (The bootloader is case sensitive) Enter X and you will see CCCC ... showing on the terminal. Now go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the bootloader file you have downloaded above. You will see File Transfer Finished Successfully . Change the configuration switches back to the off position and reset the board. You are now running GHI Electronics bootloader v2! To update using Serial Connect a USB-serial module to socket 11. Follow the exact same steps above except you need to also switch #4 to on (serial mode) The drivers for the USB-serial module should load automatically. If not, get them from http://www.ftdichip.com/ Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, set the configuration switch #1 to the on position and then reset your board. Make sure to set back ot off after loading the firmware. Download the EMX firmware and follow Loading the Firmware steps."
  },
  "hardware/legacy_products/netmf/emx.html": {
    "href": "hardware/legacy_products/netmf/emx.html",
    "title": "EMX System on Module",
    "keywords": "EMX System on Module EMX is a NETMF System on Module. Resources User Manual Using the NETMF software We discourage the use of NETMF software on our products in favor for TinyCLR OS, Read more about the use of NETMF and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET NETMF devices with TinyCLR OS Loading Bootloader v2 Tip The bootloader version 1 doesn't always work with Windows 7 and newer (Error code 10). You can use the serial option to update the loader. This is a one-time procedure. You should have no issues after the bootloader V2 is loaded. To update using USB Download the bootloader file Set EMX in boot mode, by making pins 3,7 and 53 low and reset EMX. (Pin3=P0.4 | Pin7=P2.5 | Pin53=P2.11) The PC will now detect a virtual serial (COM) device. If you need drivers, they are in the NETMF SDK. Open any terminal software, we recommend Tera Term . Select serial and pick the COM port associated with your board. Enter E and you will see back \"Erase all memory! Are you sure?\" now enter Y . (The bootloader is case sensitive) Enter X and you will see CCCC ... showing on the terminal. Now go to File -> Transfer -> XMODEM -> Send and then check the 1K option. Select the bootloader file you have downloaded above. You will see File Transfer Finished Successfully . Change the configuration switches back to the off position and reset the board. You are now running GHI Electronics bootloader v2! To update using Serial Connect a development PC to COM1 on EMX, Pin5 and Pin6 (through RS232 converter or a USB-Serial TTL cable). SET LMODE pin low. Follow the steps above to load the firmware. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, set Pin3 low (double check) and then reset your board. Download the EMX firmware and follow Loading the Firmware steps. EMX Based products EMX Dev Sys The development system used for evaluating the EMX SoM. Schematics FEZ Cobra A single board computer Schematics"
  },
  "hardware/legacy_products/gadgeteer/fez_raptor.html": {
    "href": "hardware/legacy_products/gadgeteer/fez_raptor.html",
    "title": "FEZ Raptor",
    "keywords": "FEZ Raptor FEZ Raptor is a .NET Gadgeteer product, that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Spider is the G400S System on Module (SoM). Resources Schematic Using the Gadgeteer software We discourage the use of NETMF and Gadgeteer software technologies on our products in favor for TinyCLR OS. Read more about the use of NETMF, Gadgeteer and TinyCLR OS. Using TinyCLR OS If haven't yet, read about using .NET Gadgeteer devices with TinyCLR OS Loading GHI Bootloader v2 Follow the exact same steps found on the G400 page. Loading the Firmware Tip First make sure you have bootloader v2 loaded. This needs to be done only once. To activate bootloader v2, press and hold the LDR0 button while resetting the board. Download the G400 firmware and follow Loading the Firmware steps."
  }
}